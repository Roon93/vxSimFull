---- VALUE Matches (443 in 0 files) ----
Shell.c (target\src\ostool):07k,23oct01,fmk  Do not call symFindByValue and print symbol name if symbol
Shell.c (target\src\ostool):                 value = -1 SPR 22254
Shell.c (target\src\ostool):05h,01apr87,gae  made assign() not print "new value" message (duplicated
Shell.c (target\src\ostool):		   normal "value" message for expressions.
Shell.c (target\src\ostool):#define YYSTYPE VALUE		/* type of parse stack */
Shell.c (target\src\ostool):#define	RV(value)	(getRv (&(value), &tmpVal2))
Shell.c (target\src\ostool):#define NULLVAL		(VALUE *) NULL
Shell.c (target\src\ostool):typedef struct		/* VALUE */
Shell.c (target\src\ostool):	} value;
Shell.c (target\src\ostool):    } VALUE;
Shell.c (target\src\ostool): VALUE tmpVal1;	/* used by BIN_OP above for expression evaluation */
Shell.c (target\src\ostool): VALUE tmpVal2;	/* used by BIN_OP above for expression evaluation */
Shell.c (target\src\ostool): VALUE usymVal;	/* value of U_SYMBOL which has been seen */
Shell.c (target\src\ostool):/* Value type.  */
Shell.c (target\src\ostool):# define YY_INITIAL_VALUE(Value) Value
Shell.c (target\src\ostool):#ifndef YY_INITIAL_VALUE
Shell.c (target\src\ostool):# define YY_INITIAL_VALUE(Value) /* Nothing. */
Shell.c (target\src\ostool):#define yypact_value_is_default(Yystate) \
Shell.c (target\src\ostool):#define yytable_value_is_error(Yytable_value) \
Shell.c (target\src\ostool):#define YYBACKUP(Token, Value)                                  \
Shell.c (target\src\ostool):      yylval = (Value);                                         \
Shell.c (target\src\ostool):# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
Shell.c (target\src\ostool):                  Type, Value); \
Shell.c (target\src\ostool):| Print this symbol's value on YYOUTPUT.  |
Shell.c (target\src\ostool):yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
Shell.c (target\src\ostool):  if (!yyvaluep)
Shell.c (target\src\ostool):    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
Shell.c (target\src\ostool):yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
Shell.c (target\src\ostool):  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
Shell.c (target\src\ostool):# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
Shell.c (target\src\ostool):   Do not make this value too large; the results are undefined if
Shell.c (target\src\ostool):      if (!yypact_value_is_default (yyn))
Shell.c (target\src\ostool):                && !yytable_value_is_error (yytable[yyx + yyn]))
Shell.c (target\src\ostool):yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
Shell.c (target\src\ostool):  YYUSE (yyvaluep);
Shell.c (target\src\ostool):  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
Shell.c (target\src\ostool):/* The semantic value of the lookahead symbol.  */
Shell.c (target\src\ostool):       'yyvs': related to semantic values.
Shell.c (target\src\ostool):    /* The semantic value stack.  */
Shell.c (target\src\ostool):  /* The variables used to return semantic value and location from the
Shell.c (target\src\ostool):  /* In all cases, when you get here, the value and location stacks
Shell.c (target\src\ostool):  if (yypact_value_is_default (yyn))
Shell.c (target\src\ostool):      if (yytable_value_is_error (yyn))
Shell.c (target\src\ostool):  /* If YYLEN is nonzero, implement the default value of the action:
Shell.c (target\src\ostool):    { printValue (&(yyvsp[0])); CHECK; }
Shell.c (target\src\ostool):    { (yyval) = (yyvsp[0]); (yyval).value.rv = newString((char*)(yyvsp[0]).value.rv);
Shell.c (target\src\ostool):    { VALUE tmp;
Shell.c (target\src\ostool):    { (yyval).value.rv = (int)getLv (&(yyvsp[0]));
Shell.c (target\src\ostool):    { setRv (&(yyval), RV((yyvsp[-4]))->value.rv ? &(yyvsp[-2])
Shell.c (target\src\ostool):    { VALUE tmp;
Shell.c (target\src\ostool):    { VALUE tmp;
Shell.c (target\src\ostool):			    (yyval) = newSym ((char *)(yyvsp[-3]).value.rv, (yyvsp[0]).type); CHECK;
Shell.c (target\src\ostool):      if (!yypact_value_is_default (yyn))
Shell.c (target\src\ostool): VALUE *getRv ();
Shell.c (target\src\ostool): VALUE evalExp ();
Shell.c (target\src\ostool):	    printf ("undefined symbol: %s\n", (char *) yylval.value.rv);
Shell.c (target\src\ostool):		printf ("undefined symbol: %s\n", (char *)usymVal.value.rv);
Shell.c (target\src\ostool):    VALUE *pY1;
Shell.c (target\src\ostool):    VALUE *pY2;
Shell.c (target\src\ostool):    VALUE yy;
Shell.c (target\src\ostool):* assign - make assignment of new value to a cell
Shell.c (target\src\ostool):    FAST VALUE *pLv;	/* lhs to be assigned into */
Shell.c (target\src\ostool):    FAST VALUE *pRv;	/* rhs value */
Shell.c (target\src\ostool):    VALUE val;
Shell.c (target\src\ostool):	/* make value agree in type */
Shell.c (target\src\ostool):		* (char *)getLv (pLv) = val.value.byte;
Shell.c (target\src\ostool):		* (short *)getLv (pLv) = val.value.word;
Shell.c (target\src\ostool):		*getLv (pLv) = val.value.rv;
Shell.c (target\src\ostool):		* (float *)getLv (pLv) = val.value.fp;
Shell.c (target\src\ostool):		* (double *)getLv (pLv) = val.value.dp;
Shell.c (target\src\ostool): VALUE newSym (name, type)
Shell.c (target\src\ostool):    VALUE value;
Shell.c (target\src\ostool):	value.side	= LHS;
Shell.c (target\src\ostool):	value.type	= type;
Shell.c (target\src\ostool):	value.value.lv	= (int *) address;
Shell.c (target\src\ostool):    return (value);
Shell.c (target\src\ostool):* printSym - print symbolic value
Shell.c (target\src\ostool):    void *    symVal;  /* symbol value      */
Shell.c (target\src\ostool):    /* Only search for symbol value and print symbol name if value is not -1 */
Shell.c (target\src\ostool):	    (symValueGet (symId, &symVal) == OK) &&
Shell.c (target\src\ostool): VALUE newArgList ()
Shell.c (target\src\ostool):    VALUE value;
Shell.c (target\src\ostool):    value.side	   = RHS;
Shell.c (target\src\ostool):    value.type	   = T_INT;
Shell.c (target\src\ostool):    value.value.rv = nArgs;
Shell.c (target\src\ostool):    return (value);
Shell.c (target\src\ostool):    VALUE *pArgList;
Shell.c (target\src\ostool):    FAST VALUE *pNewArg;
Shell.c (target\src\ostool):    VALUE val;
Shell.c (target\src\ostool):	    nArgs++;		/* borrow second slot for double-word value  */
Shell.c (target\src\ostool):        (nArgs - pArgList->value.rv) == MAX_FUNC_ARGS)
Shell.c (target\src\ostool):	/* push arg value on top of arg stack */
Shell.c (target\src\ostool):			  val.value.fp : val.value.dp,
Shell.c (target\src\ostool):		    rv = val.value.byte;
Shell.c (target\src\ostool):		    rv = val.value.word;
Shell.c (target\src\ostool):		    rv = val.value.rv;
Shell.c (target\src\ostool): VALUE funcCall (pV, pArgList)
Shell.c (target\src\ostool):    VALUE *pV;
Shell.c (target\src\ostool):    VALUE *pArgList;
Shell.c (target\src\ostool):    VALUE value;
Shell.c (target\src\ostool):				      : (FUNCPTR) pV->value.rv;
Shell.c (target\src\ostool):    for (argNum = pArgList->value.rv, i = 0; i < MAX_FUNC_ARGS; argNum++, i++)
Shell.c (target\src\ostool):    value.side = RHS;
Shell.c (target\src\ostool):    value.type = pV->type;
Shell.c (target\src\ostool):		    value.value.byte = (char) rv;
Shell.c (target\src\ostool):		    value.value.word = (short) rv;
Shell.c (target\src\ostool):		    value.value.rv = rv;
Shell.c (target\src\ostool):	    value.value.fp = (* (float (*)())pFunc) (a[0], a[1], a[2], a[3],
Shell.c (target\src\ostool):	    value.value.dp = (* (double (*)())pFunc) (a[0], a[1], a[2], a[3],
Shell.c (target\src\ostool):    nArgs = pArgList->value.rv;
Shell.c (target\src\ostool):    return (value);
Shell.c (target\src\ostool):* checkLv - check that a value can be used as left value
Shell.c (target\src\ostool): BOOL checkLv (pValue)
Shell.c (target\src\ostool):    VALUE *pValue;
Shell.c (target\src\ostool):    if (pValue->side != LHS)
Shell.c (target\src\ostool):* checkRv - check that a value can be used as right value
Shell.c (target\src\ostool): BOOL checkRv (pValue)
Shell.c (target\src\ostool):    VALUE *pValue;
Shell.c (target\src\ostool):    if (pValue->side == LHS)
Shell.c (target\src\ostool):	return (checkLv (pValue));
Shell.c (target\src\ostool):* getRv - get a value's right value 
Shell.c (target\src\ostool): VALUE *getRv (pValue, pRv)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    FAST VALUE *pRv;			/* where to put value */
Shell.c (target\src\ostool):    if (pValue->side == RHS)
Shell.c (target\src\ostool):	*pRv = *pValue;
Shell.c (target\src\ostool):	pRv->type = pValue->type;
Shell.c (target\src\ostool):	switch (pValue->type)
Shell.c (target\src\ostool):		pRv->value.byte = *(char *)pValue->value.lv;
Shell.c (target\src\ostool):		pRv->value.word = *(short *)pValue->value.lv;
Shell.c (target\src\ostool):		pRv->value.rv = *pValue->value.lv;
Shell.c (target\src\ostool):		pRv->value.fp = *(float *)pValue->value.lv;
Shell.c (target\src\ostool):		pRv->value.dp = *(double *)pValue->value.lv;
Shell.c (target\src\ostool):* getLv - get a value's left value (address)
Shell.c (target\src\ostool): int *getLv (pValue)
Shell.c (target\src\ostool):    VALUE *pValue;
Shell.c (target\src\ostool):    return (checkLv (pValue) ? pValue->value.lv : 0);
Shell.c (target\src\ostool):    FAST VALUE *pVal1;
Shell.c (target\src\ostool):    FAST VALUE *pVal2;
Shell.c (target\src\ostool):    pVal1->value.lv = (int *)pVal2->value.rv;
Shell.c (target\src\ostool):    FAST VALUE *pVal1;
Shell.c (target\src\ostool):    FAST VALUE *pVal2;
Shell.c (target\src\ostool):	    pVal1->value.byte = (pVal2->side == LHS) ?
Shell.c (target\src\ostool):			    *(char *)pVal2->value.lv : pVal2->value.byte;
Shell.c (target\src\ostool):	    pVal1->value.word = (pVal2->side == LHS) ?
Shell.c (target\src\ostool):			    *(short *)pVal2->value.lv : pVal2->value.word;
Shell.c (target\src\ostool):	    pVal1->value.rv = (pVal2->side == LHS) ?
Shell.c (target\src\ostool):			    *pVal2->value.lv : pVal2->value.rv;
Shell.c (target\src\ostool):	    pVal1->value.fp = (pVal2->side == LHS) ?
Shell.c (target\src\ostool):			    *(float *)pVal2->value.lv : pVal2->value.fp;
Shell.c (target\src\ostool):	    pVal1->value.dp = (pVal2->side == LHS) ?
Shell.c (target\src\ostool):			    *(double *)pVal2->value.lv : pVal2->value.dp;
Shell.c (target\src\ostool):* printLv - print left-hand side value
Shell.c (target\src\ostool): void printLv (pValue)
Shell.c (target\src\ostool):    VALUE *pValue;
Shell.c (target\src\ostool):    FAST int *lv = getLv (pValue);
Shell.c (target\src\ostool):* printRv - print right-hand side value
Shell.c (target\src\ostool):*                 ^ only if value is printable
Shell.c (target\src\ostool): void printRv (pValue)
Shell.c (target\src\ostool):    VALUE *pValue;
Shell.c (target\src\ostool):    VALUE val;
Shell.c (target\src\ostool):    (void)getRv (pValue, &val);
Shell.c (target\src\ostool):    switch (pValue->type)
Shell.c (target\src\ostool):	    rv = val.value.byte;
Shell.c (target\src\ostool):	    rv = val.value.word;
Shell.c (target\src\ostool):	    rv = val.value.rv;
Shell.c (target\src\ostool):	    printf ("%g", val.value.fp);
Shell.c (target\src\ostool):	    printf ("%g", val.value.dp);
Shell.c (target\src\ostool):* printValue - print out value
Shell.c (target\src\ostool): void printValue (pValue)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    if (pValue->side == LHS)
Shell.c (target\src\ostool):	if (checkLv (pValue) && checkRv (pValue))
Shell.c (target\src\ostool):	    printLv (pValue);
Shell.c (target\src\ostool):	    printf (": value = ");
Shell.c (target\src\ostool):	    printRv (pValue);
Shell.c (target\src\ostool):    else if (checkRv (pValue))
Shell.c (target\src\ostool):	printf ("value = ");
Shell.c (target\src\ostool):	printRv (pValue);
Shell.c (target\src\ostool): VALUE evalUnknown ();
Shell.c (target\src\ostool): VALUE evalByte ();
Shell.c (target\src\ostool): VALUE evalWord ();
Shell.c (target\src\ostool): VALUE evalInt ();
Shell.c (target\src\ostool): VALUE evalFloat ();
Shell.c (target\src\ostool): VALUE evalDouble ();
Shell.c (target\src\ostool):    VALUE (*eval) ();
Shell.c (target\src\ostool): VALUE evalExp (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    VALUE *p1 = pValue1;
Shell.c (target\src\ostool):    VALUE *p2 = pValue2;
Shell.c (target\src\ostool):    if (pValue2 == NULLVAL) /* unary expresions must set pValue2 to something */
Shell.c (target\src\ostool):	p2 = pValue2 = pValue1;
Shell.c (target\src\ostool):    /* make sure values have the same type */
Shell.c (target\src\ostool):    return ((evalType[(int)pValue1->type].eval) (pValue1, op, pValue2));
Shell.c (target\src\ostool): VALUE evalUnknown (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    return (*pValue1);	/* have to return something */
Shell.c (target\src\ostool): VALUE evalByte (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    VALUE *p1 = pValue1;
Shell.c (target\src\ostool):    VALUE *p2 = pValue2;
Shell.c (target\src\ostool):    VALUE result;
Shell.c (target\src\ostool): VALUE evalWord (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    VALUE *p1 = pValue1;
Shell.c (target\src\ostool):    VALUE *p2 = pValue2;
Shell.c (target\src\ostool):    VALUE result;
Shell.c (target\src\ostool): VALUE evalInt (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    FAST int e1 = pValue1->value.rv;
Shell.c (target\src\ostool):    FAST int e2 = pValue2->value.rv;
Shell.c (target\src\ostool):    VALUE result;
Shell.c (target\src\ostool):    result.type     = pValue1->type;
Shell.c (target\src\ostool):    result.value.rv = rv;
Shell.c (target\src\ostool): VALUE evalFloat (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    VALUE *p1 = pValue1;
Shell.c (target\src\ostool):    VALUE *p2 = pValue2;
Shell.c (target\src\ostool):    VALUE result;
Shell.c (target\src\ostool): VALUE evalDouble (pValue1, op, pValue2)
Shell.c (target\src\ostool):    VALUE *pValue1;
Shell.c (target\src\ostool):    VALUE *pValue2;
Shell.c (target\src\ostool):    FAST double e1 = pValue1->value.dp;
Shell.c (target\src\ostool):    FAST double e2 = pValue2->value.dp;
Shell.c (target\src\ostool):    VALUE result;
Shell.c (target\src\ostool):    result.value.dp = dp;
Shell.c (target\src\ostool):* typeConvert - change value to specified type
Shell.c (target\src\ostool): void typeConvert (pValue, type, side)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):	pValue->side = RHS;
Shell.c (target\src\ostool):	pValue->type = type;
Shell.c (target\src\ostool):	if (pValue->side == LHS)
Shell.c (target\src\ostool):	    pValue->type = type;
Shell.c (target\src\ostool):	    (convType [(int) type]) (pValue);
Shell.c (target\src\ostool):    else if (pValue->side == LHS)
Shell.c (target\src\ostool):	pValue->type = type;
Shell.c (target\src\ostool):* convUnknown - convert value to unknown
Shell.c (target\src\ostool): void convUnknown (pValue)
Shell.c (target\src\ostool):    VALUE *pValue;
Shell.c (target\src\ostool):* convByte - convert value to byte
Shell.c (target\src\ostool): void convByte (pValue)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    char value;
Shell.c (target\src\ostool):    if ((int)pValue->type > (int)T_BYTE)
Shell.c (target\src\ostool):	convWord (pValue);
Shell.c (target\src\ostool):	value = pValue->value.word;
Shell.c (target\src\ostool):	pValue->value.byte = value;
Shell.c (target\src\ostool):	pValue->type = T_BYTE;
Shell.c (target\src\ostool):* convWord - convert value to word
Shell.c (target\src\ostool): void convWord (pValue)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    short value;
Shell.c (target\src\ostool):    if ((int)pValue->type < (int)T_WORD)
Shell.c (target\src\ostool):	value = pValue->value.byte;
Shell.c (target\src\ostool):	pValue->value.word = value;
Shell.c (target\src\ostool):	pValue->type = T_WORD;
Shell.c (target\src\ostool):    else if ((int)pValue->type > (int)T_WORD)
Shell.c (target\src\ostool):	convInt (pValue);
Shell.c (target\src\ostool):	value = pValue->value.rv;
Shell.c (target\src\ostool):	pValue->value.word = value;
Shell.c (target\src\ostool):	pValue->type = T_WORD;
Shell.c (target\src\ostool):* convInt - convert value to integer
Shell.c (target\src\ostool): void convInt (pValue)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    int value;
Shell.c (target\src\ostool):    if ((int)pValue->type < (int)T_INT)
Shell.c (target\src\ostool):	convWord (pValue);
Shell.c (target\src\ostool):	value = pValue->value.word;
Shell.c (target\src\ostool):	pValue->value.rv = value;
Shell.c (target\src\ostool):	pValue->type = T_INT;
Shell.c (target\src\ostool):    else if ((int)pValue->type > (int)T_INT)
Shell.c (target\src\ostool):	convFloat (pValue);
Shell.c (target\src\ostool):	value = pValue->value.fp;
Shell.c (target\src\ostool):	pValue->value.rv = value;
Shell.c (target\src\ostool):	pValue->type = T_INT;
Shell.c (target\src\ostool):* convFloat - convert value to float
Shell.c (target\src\ostool): void convFloat (pValue)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    float value;
Shell.c (target\src\ostool):    if ((int)pValue->type < (int)T_FLOAT)
Shell.c (target\src\ostool):	convInt (pValue);
Shell.c (target\src\ostool):	value = pValue->value.rv;
Shell.c (target\src\ostool):	pValue->value.fp = value;
Shell.c (target\src\ostool):	pValue->type = T_FLOAT;
Shell.c (target\src\ostool):    else if ((int)pValue->type > (int)T_FLOAT)
Shell.c (target\src\ostool):	convDouble (pValue);
Shell.c (target\src\ostool):	value = pValue->value.dp;
Shell.c (target\src\ostool):	pValue->value.fp = value;
Shell.c (target\src\ostool):	pValue->type = T_FLOAT;
Shell.c (target\src\ostool):* convDouble - convert value to double
Shell.c (target\src\ostool): void convDouble (pValue)
Shell.c (target\src\ostool):    FAST VALUE *pValue;
Shell.c (target\src\ostool):    double value;
Shell.c (target\src\ostool):    if ((int)pValue->type < (int)T_DOUBLE)
Shell.c (target\src\ostool):	convFloat (pValue);
Shell.c (target\src\ostool):	value = pValue->value.fp;
Shell.c (target\src\ostool):	pValue->value.dp = value;
Shell.c (target\src\ostool):	pValue->type = T_DOUBLE;
