/* gccMathLib.c - math support routines for gcc */

/* Copyright 1984-1992 Wind River Systems, Inc. */
#include "copyright_wrs.h"

/*
modification history
--------------------
01b,20sep92,kdl	 added C versions of gcc2.2 compare functions (were in
		 gccMathALib.s);  fixed "sign" test of unsigned value in 
		 __floatunssisf and __floatunssidf.
01a,30jul92,kdl	 created.
*/

/*
DESCRIPTION

This library contains various support routines for using gcc.  The
compiler will generate subroutine calls to the functions in this file
when the software floating point option is used.  The function names 
are those which are automatically generated by the gcc compiler.

* gnulib support for software floating point.
* Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.
* Permission is granted to do *anything* you want with this file,
* commercial or otherwise, provided this message remains intact.  So there!
* I would appreciate receiving any updates/patches/changes that anyone
* makes, and am willing to be the repository for said changes (am I
* making a big mistake?).
*
* Pat Wood
* Pipeline Associates, Inc.
* pipeline!phw@motown.com or
* sun!pipeline!phw or
* uunet!motown!pipeline!phw
*
* 05/01/91 -- V1.0 -- first release to gcc mailing lists
* 05/04/91 -- V1.1 -- added float and double prototypes and return values
*                  -- fixed problems with adding and subtracting zero
*                  -- fixed rounding in truncdfsf2
*                  -- fixed SWAP define and tested on 386
*  Hacked (mostly just stripped-down) to work on the m68k by Michael Tiemann
*  tiemann@cygnus.com

AUTHOR
Adapted from libraries supplied by Cygnus Support, originally written
by Pat Wook, Pipeline Associates Inc.

NOMANUAL
*/


#include "vxWorks.h"

/* externals */

extern double	__floatsidf (int l);
extern int	__fixdfsi (double foo);
extern int	__cmpdf2  (double num1, double num2);
extern int	__cmpsf2  (float num1, float num2);

/******************************************************************************
*
* __floatsisf - convert integer to single-precision float
*
* RETURNS: value expressed as a float.
*
* NOMANUAL
*
*/

float __floatsisf
    (
    int    l
    )
    {
    double foo;


    foo = __floatsidf (l);

    return (foo);
    }


/******************************************************************************
*
* __fixsfsi - convert single-precision float to integer
*
* RETURNS: value expressed as an integer.
*
* NOMANUAL
*
*/

int __fixsfsi
    (
    float  a1
    )
    {
    double foo;


    foo = a1;

    return (__fixdfsi (foo));
    }

/******************************************************************************
*
* __floatunssisf - convert unsigned integer to single-precision float
* 
* RETURNS: value expressed as a float.
*
* NOMANUAL
*/

float __floatunssisf
    (
    unsigned l
    )
    {
    float    foo;
    
    foo = __floatsisf (l);		/* __floatsisf expects signed value */

    if ((l & _ARCH_INT_MIN) != 0)	/* test high-order (sign) bit */
  	{
    	foo +=4.29496729600000000000e+09;
					/* adjust result if false negative */
  	}

    return (foo);
    }

/******************************************************************************
*
* __floatunssidf - convert unsigned integer to double
*
* RETURNS: value expressed as a double.
*
* NOMANUAL
*/

double __floatunssidf
    (
    unsigned 	l
    )
    {
    double 	foo;


    foo = __floatsidf (l);		/* __floatsidf expects signed value */
  
    if ((l & _ARCH_INT_MIN) != 0)	/* test high-order (sign) bit */
  	{
    	foo +=4.29496729600000000000e+09;	
					/* adjust result if false negative */
  	}

    return (foo);
    }

/*******************************************************************************
*
* __eqdf2 - equality test for two doubles
*
* RETURNS: zero if two numbers are equal, non-zero otherwise.
*
* NOMANUAL
*/

int __eqdf2
    (
    double	num1,
    double	num2
    )
    {

    return (__cmpdf2 (num1, num2));		/* cmpdf2 returns 0 if equal */
    }

/*******************************************************************************
*
* __eqsf2 - equality test for two floats
*
* RETURNS: zero if two numbers are equal, non-zero otherwise.
*
* NOMANUAL
*/

int __eqsf2
    (
    float	num1,
    float	num2
    )
    {

    return (__cmpsf2 (num1, num2));		/* cmpsf2 returns 0 if equal */
    }

/*******************************************************************************
*
* __nedf2 - inequality test for two doubles
*
* RETURNS: non-zero if two numbers are not equal, zero otherwise.
*
* NOMANUAL
*/

int __nedf2
    (
    double	num1,
    double	num2
    )
    {

    return (__cmpdf2 (num1, num2) != 0);	/* return zero if not equal */
    }

/*******************************************************************************
*
* __nesf2 - inequality test for two floats
*
* RETURNS: non-zero if two numbers are not equal, zero otherwise.
*
* NOMANUAL
*/

int __nesf2
    (
    float	num1,
    float	num2
    )
    {

    return (__cmpsf2 (num1, num2) != 0);	/* return zero if not equal */
    }

/*******************************************************************************
*
* __gtdf2 - greater-than test for two doubles
*
* RETURNS: positive value if first number is greater than second, zero or
*	   negative otherwise.
*
* NOMANUAL
*/

int __gtdf2
    (
    double	num1,
    double	num2
    )
    {

    return (__cmpdf2 (num1, num2) > 0);
    }

/*******************************************************************************
*
* __gtsf2 - greater-than test for two floats
*
* RETURNS: positive value if first number is greater than second, zero or
*	   negative otherwise.
*
* NOMANUAL
*/

int __gtsf2
    (
    float	num1,
    float	num2
    )
    {

    return (__cmpsf2 (num1, num2) > 0);
    }

/*******************************************************************************
*
* __gedf2 - greater-than-or-equal test for two doubles
*
* RETURNS: positive value or zero if first number is greater than second, 
*	   negative otherwise.
*
* NOMANUAL
*/

int __gedf2
    (
    double	num1,
    double	num2
    )
    {

    return ((__cmpdf2 (num1, num2) >= 0) - 1);
    }

/*******************************************************************************
*
* __gesf2 - greater-than-or-equal test for two floats
*
* RETURNS: positive value or zero if first number is greater than second,
*	   negative otherwise.
*
* NOMANUAL
*/

int __gesf2
    (
    float	num1,
    float	num2
    )
    {

    return ((__cmpsf2 (num1, num2) >= 0) - 1);
    }

/*******************************************************************************
*
* __ltdf2 - less-than test for two doubles
*
* RETURNS: negative value if first number is less than second, zero or
*	   positive otherwise.
*
* NOMANUAL
*/

int __ltdf2
    (
    double	num1,
    double	num2
    )
    {

    if (__cmpdf2 (num1, num2) < 0)
	return (-1);
    else
	return (0);
    }

/*******************************************************************************
*
* __ltsf2 - less-than test for two floats
*
* RETURNS: negative value if first number is less than second, zero or
*	   positive otherwise.
*
* NOMANUAL
*/

int __ltsf2
    (
    float	num1,
    float	num2
    )
    {

    if (__cmpsf2 (num1, num2) < 0)
	return (-1);
    else
	return (0);
    }

/*******************************************************************************
*
* __ledf2 - less-than-or-equal test for two doubles
*
* RETURNS: negative value or zero if first number is less than second,
*	   positive otherwise.
*
* NOMANUAL
*/

int __ledf2
    (
    double	num1,
    double	num2
    )
    {

    if (__cmpdf2 (num1, num2) <= 0)
	return (0);
    else
	return (1);
    }

/*******************************************************************************
*
* __lesf2 - less-than-or-equal test for two floats
*
* RETURNS: negative value or zero if first number is less than second,
*	   positive otherwise.
*
* NOMANUAL
*/

int __lesf2
    (
    float	num1,
    float	num2
    )
    {

    if (__cmpsf2 (num1, num2) <= 0)
	return (0);
    else
	return (1);
    }

























