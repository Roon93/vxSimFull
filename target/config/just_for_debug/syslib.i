ccpentium -mcpu=pentium -march=pentium -ansi  -O2 -fvolatile -nostdlib -fno-builtin -fno-defer-pop -Wall -I/h   -I. -Id:\Tornado2.2\target\config\all -Id:\Tornado2.2\target/h -Id:\Tornado2.2\target/src/config -Id:\Tornado2.2\target/src/drv -DCPU=PENTIUM -DTOOL_FAMILY=gnu -DTOOL=gnu   -E  -c sysLib.c
# 1 "sysLib.c"
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "sysLib.c" 2

 
# 181 "sysLib.c"

 
# 220 "sysLib.c"

 

# 1 "d:/Tornado2.2/target/h/vxWorks.h" 1
 

 

 
# 53 "d:/Tornado2.2/target/h/vxWorks.h"





































 




 




 





 




 





 









 







 






 




























 





# 1 "d:/Tornado2.2/target/h/types/vxCpu.h" 1
 

 

 








 
# 75 "d:/Tornado2.2/target/h/types/vxCpu.h"

 













 

 










 






























































































# 207 "d:/Tornado2.2/target/h/types/vxCpu.h"




















































# 273 "d:/Tornado2.2/target/h/types/vxCpu.h"










# 296 "d:/Tornado2.2/target/h/types/vxCpu.h"


# 306 "d:/Tornado2.2/target/h/types/vxCpu.h"























 
# 338 "d:/Tornado2.2/target/h/types/vxCpu.h"











# 178 "d:/Tornado2.2/target/h/vxWorks.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxArch.h" 1
 

 

 
# 32 "d:/Tornado2.2/target/h/types/vxArch.h"

 








































































# 1 "d:/Tornado2.2/target/h/arch/i86/archI86.h" 1
 

 
 
# 14 "d:/Tornado2.2/target/h/arch/i86/archI86.h"






















# 60 "d:/Tornado2.2/target/h/arch/i86/archI86.h"


 








# 107 "d:/Tornado2.2/target/h/types/vxArch.h" 2


























 















 











# 179 "d:/Tornado2.2/target/h/vxWorks.h" 2

# 1 "d:/Tornado2.2/target/h/types/vxParams.h" 1
 

 

 
# 15 "d:/Tornado2.2/target/h/types/vxParams.h"

 













































# 181 "d:/Tornado2.2/target/h/vxWorks.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxTypesBase.h" 1
 

 

 
# 24 "d:/Tornado2.2/target/h/types/vxTypesBase.h"

 
















# 1 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stddef.h" 1 3
 
# 19 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stddef.h" 3

 






 








 







 

 




 


 





 



# 91 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stddef.h" 3

 





 


















 





 

 





















typedef long int ptrdiff_t;









 




 

 


































typedef long unsigned int size_t;






















 




 





























 
# 267 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stddef.h" 3

















typedef short unsigned int wchar_t;
























typedef unsigned int wint_t;




 

 

# 346 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stddef.h" 3



 













 








# 43 "d:/Tornado2.2/target/h/types/vxTypesBase.h" 2

 






struct __timer;































































 






 




















 










































































 






















































































































 






 
































# 182 "d:/Tornado2.2/target/h/vxWorks.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxTypes.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/types/vxTypes.h"

 
# 56 "d:/Tornado2.2/target/h/types/vxTypes.h"








# 1 "d:/Tornado2.2/target/h/types/vxANSI.h" 1
 

 

 








 
# 25 "d:/Tornado2.2/target/h/types/vxANSI.h"








 










# 1 "d:/Tornado2.2/target/h/types/vxCpu.h" 1
 

 

 








 
# 75 "d:/Tornado2.2/target/h/types/vxCpu.h"

 







# 348 "d:/Tornado2.2/target/h/types/vxCpu.h"

# 45 "d:/Tornado2.2/target/h/types/vxANSI.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxArch.h" 1
 

 

 
# 32 "d:/Tornado2.2/target/h/types/vxArch.h"

 








# 160 "d:/Tornado2.2/target/h/types/vxArch.h"

# 46 "d:/Tornado2.2/target/h/types/vxANSI.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxParams.h" 1
 

 

 
# 15 "d:/Tornado2.2/target/h/types/vxParams.h"

 







# 61 "d:/Tornado2.2/target/h/types/vxParams.h"

# 47 "d:/Tornado2.2/target/h/types/vxANSI.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxTypesBase.h" 1
 

 

 
# 24 "d:/Tornado2.2/target/h/types/vxTypesBase.h"

 








# 376 "d:/Tornado2.2/target/h/types/vxTypesBase.h"

# 48 "d:/Tornado2.2/target/h/types/vxANSI.h" 2







# 65 "d:/Tornado2.2/target/h/types/vxTypes.h" 2


typedef int ssize_t;




typedef unsigned long time_t;




typedef long fpos_t;




typedef signed char int8_t;




typedef unsigned char uint8_t;




typedef short int16_t;




typedef unsigned short uint16_t;




typedef long int32_t;




typedef unsigned long uint32_t;




typedef long long int64_t;




typedef unsigned long long uint64_t;



 

typedef unsigned char	uchar_t;
typedef unsigned short	ushort_t;
typedef unsigned int	uint_t;
typedef unsigned long	ulong_t;

typedef	struct	_quad { long val[2]; } quad;
typedef	long	daddr_t;
typedef	char *	caddr_t;
typedef	char *	addr_t;
typedef	long	swblk_t;

 

typedef short		dev_t;
typedef unsigned short	gid_t;
typedef	unsigned long	ino_t;
typedef int		mode_t;
typedef unsigned long	nlink_t;
typedef long		off_t;
typedef int		pid_t;
typedef unsigned short	uid_t;







# 183 "d:/Tornado2.2/target/h/vxWorks.h" 2
# 1 "d:/Tornado2.2/target/h/types/vxTypesOld.h" 1
 

 

 
# 58 "d:/Tornado2.2/target/h/types/vxTypesOld.h"

 
# 72 "d:/Tornado2.2/target/h/types/vxTypesOld.h"








# 1 "d:/Tornado2.2/target/h/sys/types.h" 1
 

 
 








 
# 31 "d:/Tornado2.2/target/h/sys/types.h"








# 1 "d:/Tornado2.2/target/h/types/vxTypes.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/types/vxTypes.h"

 
# 56 "d:/Tornado2.2/target/h/types/vxTypes.h"


# 150 "d:/Tornado2.2/target/h/types/vxTypes.h"

# 40 "d:/Tornado2.2/target/h/sys/types.h" 2







# 81 "d:/Tornado2.2/target/h/types/vxTypesOld.h" 2

 

typedef	char		INT8;
typedef	short		INT16;
typedef	int		INT32;
typedef	long long	INT64;

typedef	unsigned char	UINT8;
typedef	unsigned short	UINT16;
typedef	unsigned int	UINT32;
typedef	unsigned long long UINT64;

typedef	unsigned char	UCHAR;
typedef unsigned short	USHORT;
typedef	unsigned int	UINT;
typedef unsigned long	ULONG;

typedef	int		BOOL;
typedef	int		STATUS;
typedef int 		ARGINT;

typedef void		VOID;







typedef int 		(*FUNCPTR) ();	    
typedef void 		(*VOIDFUNCPTR) ();  
typedef double 		(*DBLFUNCPTR) ();   
typedef float 		(*FLTFUNCPTR) ();   



 




typedef union
    {
    long pm_int;
    void *pm_v;
    const void *pm_cv;
    char *pm_c;
    unsigned char *pm_uc;

    signed char *pm_sc;
    const char *pm_cc;
    const unsigned char *pm_cuc;
    const signed char *pm_csc;
    short *pm_s;
    ushort_t *pm_us;
    const short *pm_cs;
    const ushort_t *pm_cus;
    int *pm_i;
    uint_t *pm_ui;
    const int *pm_ci;
    const uint_t *pm_cui;
    long *pm_l;
    ulong_t *pm_ul;
    const long *pm_cl;
    const ulong_t *pm_cul;

    int8_t *pm_i8;
    uint8_t *pm_ui8;
    const int8_t *pm_ci8;
    const uint8_t *pm_cui8;
    int16_t *pm_i16;
    uint16_t *pm_ui16;
    const int16_t *pm_ci16;
    const uint16_t *pm_cui16;
    int32_t *pm_i32;
    uint32_t *pm_ui32;
    const int32_t *pm_ci32;
    const uint32_t *pm_cui32;








    } pointer_mix_t;













 





 
# 198 "d:/Tornado2.2/target/h/types/vxTypesOld.h"





typedef long	fd_mask;





typedef	struct fd_set
    {
    fd_mask	fds_bits[((unsigned int)(((2048)+(( (sizeof(fd_mask) * 8))-1)))/(unsigned int)( (sizeof(fd_mask) * 8)))];
    } fd_set;







 

typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	unsigned short	ushort;


 

typedef char		TBOOL;		 


 
















typedef	unsigned char INSTR;		 
























 


# 293 "d:/Tornado2.2/target/h/types/vxTypesOld.h"












# 184 "d:/Tornado2.2/target/h/vxWorks.h" 2













 












 





 

# 1 "d:/Tornado2.2/target/h/tool/gnu/toolMacros.h" 1
 

 

 


















 









 













# 219 "d:/Tornado2.2/target/h/vxWorks.h" 2



 



















# 224 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/vme.h" 1
 

 

 
# 22 "d:/Tornado2.2/target/h/vme.h"

 
# 33 "d:/Tornado2.2/target/h/vme.h"








 































# 225 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/memLib.h" 1
 

 

 
# 49 "d:/Tornado2.2/target/h/memLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"








 











































































































































 











# 59 "d:/Tornado2.2/target/h/memLib.h" 2

 







 



typedef struct mem_part *PART_ID;

 

typedef struct
    {

    unsigned long numBytesFree,	    
		  numBlocksFree,    
		  maxBlockSizeFree, 
		  numBytesAlloc,    
		  numBlocksAlloc;   

    }  MEM_PART_STATS;


 

 



 




 




 






 









 

 

extern PART_ID memSysPartId;

 

extern FUNCPTR  smMemPartOptionsSetRtn;
extern FUNCPTR  smMemPartFindMaxRtn;
extern FUNCPTR  smMemPartReallocRtn;
extern FUNCPTR  smMemPartShowRtn;

 



extern STATUS 	memInit (char *pPool, unsigned poolSize);
extern STATUS 	memPartLibInit (char *pPool, unsigned poolSize);
extern PART_ID 	memPartCreate (char *pPool, unsigned poolSize);
extern void 	memPartInit (PART_ID partId, char *pPool, unsigned poolSize);
extern STATUS 	memPartAddToPool (PART_ID partId, char *pPool,
				  unsigned poolSize);
extern void 	memAddToPool (char *pPool, unsigned poolSize);
extern void *	memPartAlloc (PART_ID partId, unsigned nBytes);
extern void *   memPartAlignedAlloc (PART_ID partId, unsigned nBytes,
				     unsigned alignment);
extern void *	memalign (unsigned alignment, unsigned size);
extern void *   valloc (unsigned size);
extern STATUS 	memPartFree (PART_ID partId, char *pBlock);
extern STATUS 	memPartOptionsSet (PART_ID partId, unsigned options);
extern int 	memFindMax (void);
extern int 	memPartFindMax (PART_ID partId);
extern void *	memPartRealloc (PART_ID partId, char *pBlock, unsigned nBytes);
extern void 	memOptionsSet (unsigned options);
extern STATUS 	cfree (char *pBlock);
extern void 	memShowInit (void);
extern void 	memShow (int type);
extern STATUS 	memPartShow (PART_ID partId, int type);
extern STATUS   memPartInfoGet (PART_ID	partId, MEM_PART_STATS * ppartStats);


# 187 "d:/Tornado2.2/target/h/memLib.h"









# 226 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/sysLib.h" 1
 

 

 
# 69 "d:/Tornado2.2/target/h/sysLib.h"









# 1 "d:/Tornado2.2/target/h/bootLib.h" 1
 

 

 
# 27 "d:/Tornado2.2/target/h/bootLib.h"








 
















typedef struct				 
    {
    char bootDev [40];	 
    char hostName [20];	 
    char targetName [20];	 
    char ead [50];	 
    char bad [50];	 
    char had [30];		 
    char gad [30];		 
    char bootFile [160];	 
    char startupScript [160];	 
    char usr [20];		 
    char passwd [20];	 
    char other [80];	 
    int  procNum;			 
    int  flags;				 
    int  unitNum;                        
    } BOOT_PARAMS;

 



extern STATUS 	bootBpAnchorExtract (char *string, char ** pAnchorAdrs);
extern STATUS 	bootLeaseExtract (char *string, u_long *pLeaseLen, 
                                  u_long *pLeaseStart);
extern STATUS 	bootNetmaskExtract (char *string, int *pNetmask);
extern STATUS 	bootScanNum (char ** ppString, int *pValue, BOOL hex);
extern STATUS 	bootStructToString (char *paramString, BOOT_PARAMS
		*pBootParams);
extern char *	bootStringToStruct (char *bootString, BOOT_PARAMS *pBootParams);
extern void 	bootParamsErrorPrint (char *bootString, char *pError);
extern void 	bootParamsPrompt (char *string);
extern void 	bootParamsShow (char *paramString);


# 100 "d:/Tornado2.2/target/h/bootLib.h"







# 79 "d:/Tornado2.2/target/h/sysLib.h" 2
# 1 "d:/Tornado2.2/target/h/ttyLib.h" 1
 

 

 










# 1 "d:/Tornado2.2/target/h/types/vxTypes.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/types/vxTypes.h"

 
# 56 "d:/Tornado2.2/target/h/types/vxTypes.h"


# 150 "d:/Tornado2.2/target/h/types/vxTypes.h"

# 17 "d:/Tornado2.2/target/h/ttyLib.h" 2
# 1 "d:/Tornado2.2/target/h/sioLib.h" 1
 

 

 
# 22 "d:/Tornado2.2/target/h/sioLib.h"




# 1 "d:/Tornado2.2/target/h/types/vxTypes.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/types/vxTypes.h"

 
# 56 "d:/Tornado2.2/target/h/types/vxTypes.h"


# 150 "d:/Tornado2.2/target/h/types/vxTypes.h"

# 27 "d:/Tornado2.2/target/h/sioLib.h" 2






 











 




 
# 60 "d:/Tornado2.2/target/h/sioLib.h"







 





 




 





 

 

 











 




 
 

 















 
# 133 "d:/Tornado2.2/target/h/sioLib.h"








 
# 159 "d:/Tornado2.2/target/h/sioLib.h"





 
# 179 "d:/Tornado2.2/target/h/sioLib.h"





 

typedef struct sio_drv_funcs SIO_DRV_FUNCS;

typedef struct sio_chan				 
    {
    SIO_DRV_FUNCS * pDrvFuncs;
     
    } SIO_CHAN;

struct sio_drv_funcs				 
    {
    int		(*ioctl)
			(
			SIO_CHAN *	pSioChan,
			int		cmd,
			void *		arg
			);

    int		(*txStartup)
			(
			SIO_CHAN *	pSioChan
			);

    int		(*callbackInstall)
			(
			SIO_CHAN *	pSioChan,
			int		callbackType,
			STATUS		(*callback)(void *, ...),
			void *		callbackArg
			);

    int		(*pollInput)
			(
			SIO_CHAN *	pSioChan,
			char *		inChar
			);

    int		(*pollOutput)
			(
			SIO_CHAN *	pSioChan,
			char 		outChar
			);
    };


 



















# 18 "d:/Tornado2.2/target/h/ttyLib.h" 2







extern STATUS ttyDrv	   ();
extern STATUS ttyDevCreate (char *name, SIO_CHAN *pChan, int rdBufSize,
			    int wrtBufSize);














# 80 "d:/Tornado2.2/target/h/sysLib.h" 2

# 1 "d:/Tornado2.2/target/h/drv/timer/timerDev.h" 1
 

 

 








 











 




extern	STATUS	sysClkConnect (FUNCPTR routine, int arg);
extern	void	sysClkDisable (void);
extern	void	sysClkEnable (void);
extern	int	sysClkRateGet (void);
extern	STATUS	sysClkRateSet (int ticksPerSecond);
extern	STATUS	sysAuxClkConnect (FUNCPTR routine, int arg);
extern	void	sysAuxClkDisable (void);
extern	void	sysAuxClkEnable (void);
extern	int	sysAuxClkRateGet (void);
extern	STATUS	sysAuxClkRateSet (int ticksPerSecond);
extern	STATUS	sysTimestampConnect (FUNCPTR routine, int arg);
extern	STATUS	sysTimestampEnable (void);
extern	STATUS	sysTimestampDisable (void);
extern	UINT32	sysTimestampFreq (void);
extern	UINT32	sysTimestampPeriod (void);
extern	UINT32	sysTimestamp (void);
extern	UINT32	sysTimestampLock (void);



# 72 "d:/Tornado2.2/target/h/drv/timer/timerDev.h"









# 82 "d:/Tornado2.2/target/h/sysLib.h" 2

typedef struct   
    {
    char *ifName;  		     	 
    FUNCPTR attachRtn;  		 
    char *arg1;				 
    int arg2;				 
    int arg3;				 
    int arg4;
    int arg5;
    int arg6;
    int arg7;
    int arg8;
    } NETIF;



 






 







 

 







 










                                         










 



extern int 	sysBus;		 
extern int 	sysCpu;		 
extern int 	sysProcNum;	 
extern char *	sysBootLine;	 
extern char *	sysExcMsg;	 
extern int	sysFlags;	 
extern BOOT_PARAMS sysBootParams;  

 

extern char	sysBootHost[];	 
extern char	sysBootFile[];	 

 



extern char *	sysModel (void);
extern char *	sysBspRev (void);
extern void 	sysHwInit (void);
extern void 	sysHwInit2 (void);
extern char *	sysMemTop (void);
extern char *	sysPhysMemTop (void);
extern STATUS 	sysToMonitor (int startType);
extern int 	sysProcNumGet (void);
extern void 	sysProcNumSet (int procNum);
extern BOOL 	sysBusTas (char *adrs);
extern STATUS 	sysNvRamGet (char *string, int strLen, int offset);
extern STATUS 	sysNvRamSet (char *string, int strLen, int offset);
extern STATUS 	sysScsiInit (void);
extern STATUS 	sysScsiConfig (void);
extern void	sysSerialHwInit (void);
extern void	sysSerialHwInit2 (void);
extern SIO_CHAN * sysSerialChanGet (int channel);
extern void	sysSerialReset (void);
extern STATUS	sysLocalToBusAdrs (int adrsSpace, char *localAdrs,
				   char **pBusAdrs);
extern STATUS	sysBusToLocalAdrs (int adrsSpace, char *busAdrs,
				   char **pLocalAdrs);
extern STATUS	sysIntDisable (int intLevel);
extern STATUS	sysIntEnable (int intLevel);
extern int	sysBusIntAck (int intLevel);
extern STATUS	sysBusIntGen (int level, int vector);
extern STATUS	sysMailboxConnect (FUNCPTR routine, int arg);
extern STATUS	sysMailboxEnable (char *mailboxAdrs);
extern int	tyCoDrv (void);
extern int	tyCoDevCreate (char *name, int channel, int rdBufSize,
			       int wrtBufSize);



 





extern UCHAR	sysInByte		(int port);
extern USHORT	sysInWord		(int port);
extern ULONG	sysInLong		(int port);
extern void	sysInWordString		(int port, short *pData, int count);
extern void	sysInLongString		(int port, long *pData, int count);
extern void	sysOutByte		(int port, char data);
extern void	sysOutWord		(int port, short data);
extern void	sysOutLong		(int port, long data);
extern void	sysOutWordString	(int port, short *pData, int count);
extern void	sysOutLongString	(int port, long *pData, int count);


# 234 "d:/Tornado2.2/target/h/sysLib.h"

 

extern void	sysNanoDelay		(UINT32 nanoseconds);
extern void	sysReboot		(void);
extern void	sysDelay		(void);
extern void	sysWait			(void);
extern STATUS	sysIntDisablePIC	(int intLevel);
extern STATUS	sysIntEnablePIC		(int intLevel);

 

extern void 	sysFaultTableInit	(void (*func)());
extern UINT32 	sysFaultVecSet		(INSTR *vector, UINT32 faultNo, 
					 UINT32 type);
extern void 	sysExcInfoPrint		(UINT32 type);

 

extern void	sysLoadGdt		(char *sysGdtr);



# 307 "d:/Tornado2.2/target/h/sysLib.h"









# 227 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/string.h" 1
 

 

 
# 19 "d:/Tornado2.2/target/h/string.h"











# 40 "d:/Tornado2.2/target/h/string.h"



extern void *	memchr (const void *__s, int __c, size_t __n);
extern int 	memcmp (const void *__s1, const void *__s2, size_t __n);
extern void *	memcpy (void *__s1, const void *__s2, size_t __n);
extern void *	memmove (void *__s1, const void *__s2, size_t __n);
extern void *	memset (void *__s, int __c, size_t __n);

extern char *	strcat (char *__s1, const char *__s2);
extern char *	strchr (const char *__s, int __c);
extern int 	strcmp (const char *__s1, const char *__s2);
extern int 	strcoll (const char *__s1, const char *__s2);
extern char *	strcpy (char *__s1, const char *__s2);
extern size_t 	strcspn (const char *__s1, const char *__s2);
extern size_t 	strlen (const char *__s);
extern char *	strncat (char *__s1, const char *__s2, size_t __n);
extern int 	strncmp (const char *__s1, const char *__s2, size_t __n);
extern char *	strncpy (char *__s1, const char *__s2, size_t __n);
extern char *	strpbrk (const char *__s1, const char *__s2);
extern char *	strrchr (const char *__s, int __c);
extern size_t 	strspn (const char *__s1, const char *__s2);
extern char *	strstr (const char *__s1, const char *__s2);
extern char *	strtok (char *__s, const char *__sep);
extern size_t 	strxfrm (char *__s1, const char *__s2, size_t __n);
extern char *	strerror(int __errcode);


extern char *	strtok_r (char *__s, const char *__sep, char **__ppLast);



extern int	strerror_r (int __errcode, char *__buf);
extern void 	bcopy (const char *source, char *dest, int nbytes);
extern void 	bcopyBytes (char *source, char *dest, int nbytes);
extern void 	bcopyWords (char *source, char *dest, int nwords);
extern void 	bcopyLongs (char *source, char *dest, int nlongs);
extern void 	bfill (char *buf, int nbytes, int ch);
extern void 	bfillBytes (char *buf, int nbytes, int ch);
extern void 	bzero (char *buffer, int nbytes);
extern int 	bcmp (char *buf1, char *buf2, int nbytes);
extern void 	binvert (char *buf, int nbytes);
extern void 	bswap (char *buf1, char *buf2, int nbytes);
extern void 	uswab (char *source, char *destination, int nbytes);
extern void 	swab (char *source, char *dest, int nbytes);
extern char *	index (const char *s, int c);
extern char *	rindex (const char *s, int c);



# 138 "d:/Tornado2.2/target/h/string.h"







# 228 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/intLib.h" 1
 

 

 
# 48 "d:/Tornado2.2/target/h/intLib.h"










# 1 "d:/Tornado2.2/target/h/regs.h" 1
 

 

 
# 41 "d:/Tornado2.2/target/h/regs.h"

















































# 1 "d:/Tornado2.2/target/h/arch/i86/regsI86.h" 1
 

 

 
# 22 "d:/Tornado2.2/target/h/arch/i86/regsI86.h"














typedef struct			 
    {
    ULONG edi;			 
    ULONG esi;			 
    ULONG ebp;			 
    ULONG esp;			 
    ULONG ebx;			 
    ULONG edx;			 
    ULONG ecx;			 
    ULONG eax;			 
    ULONG eflags;		 
    INSTR *pc;			 
    } REG_SET;

typedef struct cpuid		 
    {
    int highestValue;		 
    int vendorId[3];		 
    int signature;		 
    int featuresEbx;		 
    int featuresEcx;		 
    int featuresEdx;		 
    int cacheEax;		 
    int cacheEbx;		 
    int cacheEcx;		 
    int cacheEdx;		 
    int serialNo64[2];		 
    int brandString[12];	 
    } CPUID;

typedef struct mtrr_fix		 
    {
    char type[8];
    } MTRR_FIX;

typedef struct mtrr_var		 
    {
    long long int base;
    long long int mask;
    } MTRR_VAR;

typedef struct mtrr		 
    {
    int cap[2];			 
    int deftype[2];		 
    MTRR_FIX fix[11];		 
    MTRR_VAR var[8];		 
    } MTRR;
typedef MTRR *		MTRR_ID;

typedef struct gdt		 
    {
    unsigned short	limit00;
    unsigned short	base00;
    unsigned char	base01;
    unsigned char	type;
    unsigned char	limit01;
    unsigned char	base02;
    } GDT;

typedef struct tss		 
    {
    UINT16 link;		 
    UINT16 link_pad;
    UINT32 esp0;		 
    UINT16 ss0;			 
    UINT16 ss0_pad;
    UINT32 esp1;		 
    UINT16 ss1;			 
    UINT16 ss1_pad;
    UINT32 esp2;		 
    UINT16 ss2;			 
    UINT16 ss2_pad;
    UINT32 cr3;			 
    INSTR * eip;		 
    UINT32 eflags;		 
    UINT32 eax;			 
    UINT32 ecx;			 
    UINT32 edx;			 
    UINT32 ebx;			 
    UINT32 esp;			 
    UINT32 ebp;			 
    UINT32 esi;			 
    UINT32 edi;			 
    UINT16 es;			 
    UINT16 es_pad;
    UINT16 cs;			 
    UINT16 cs_pad;
    UINT16 ss;			 
    UINT16 ss_pad;
    UINT16 ds;			 
    UINT16 ds_pad;
    UINT16 fs;			 
    UINT16 fs_pad;
    UINT16 gs;			 
    UINT16 gs_pad;
    UINT16 ldt;			 
    UINT16 ldt_pad;
    UINT16 tflag;		 
    UINT16 iomapb;		 
    UINT32 iobmap[32 + 1];
    UINT32 reserved0;		 
    UINT32 reserved1;
    UINT32 reserved2;
    UINT32 reserved3;
    UINT32 reserved4;
    UINT32 reserved5;
    UINT32 reserved6;
    UINT32 reserved7;
    } TSS;

typedef struct segdesc		 
    {
    UINT16	limitLW;	 
    UINT16	baseLW;		 
    UCHAR	baseMB;		 
    UCHAR	type;		 
    UCHAR	limitUB;	 
    UCHAR	baseUB;		 
    } SEGDESC;

typedef struct callGate		 
    {
    UINT16	offsetLo;
    UINT16	selector;
    UCHAR 	params;
    UCHAR 	type;
    UINT16	offsetHi;
    } CALL_GATE;


 














 










 












 












 















 











 














 













 













































 














 

 








 

















































































 
















































































 































































































 







 









 



 









 





 

 










 









 

 











































































 










































































 












 














 










 








 




 






 



 




 




 



 




 



 




 

































 
















# 91 "d:/Tornado2.2/target/h/regs.h" 2















typedef struct regindex
    {
    char	*regName;	 
    int		regOff;		 







    } REG_INDEX;








# 59 "d:/Tornado2.2/target/h/intLib.h" 2


 





 

extern int intCnt;		 


 



 
# 85 "d:/Tornado2.2/target/h/intLib.h"






 



extern STATUS 	intConnect (VOIDFUNCPTR *vector, VOIDFUNCPTR routine,
	       	    	    int parameter);
extern FUNCPTR 	intHandlerCreate (FUNCPTR routine, int parameter);
extern void 	intLockLevelSet (int newLevel);
extern int 	intLockLevelGet (void);
extern BOOL 	intContext (void);
extern int 	intCount (void);
extern void 	intVecBaseSet (FUNCPTR *baseAddr);
extern FUNCPTR *intVecBaseGet (void);
extern void 	intVecSet (FUNCPTR *vector, FUNCPTR function);
extern FUNCPTR 	intVecGet (FUNCPTR *vector);
extern int 	intLevelSet (int level);
extern int 	intLock (void);
extern int 	intUnlock (int oldSR);
extern int 	intRegsLock (REG_SET *pRegs);
extern void 	intRegsUnlock (REG_SET *pRegs, int lockKey);
extern STATUS   intVecTableWriteProtect (void);

























extern int	intDisable (int);
extern int	intEnable (int);







# 1 "d:/Tornado2.2/target/h/arch/i86/intI86Lib.h" 1
 

 

 














 
















extern FUNCPTR 	intHandlerCreateI86 (FUNCPTR routine, int parameter,
				     FUNCPTR routineBoi, int parameterBoi,
				     FUNCPTR routineEoi, int parameterEoi);
extern void 	intVecSet2 (FUNCPTR * vector, FUNCPTR function,
			    int idtGate, int idtSelector);
extern void	intVecGet2 (FUNCPTR * vector, FUNCPTR * pFunction, 
			    int * pIdtGate, int * pIdtSelector);
















# 147 "d:/Tornado2.2/target/h/intLib.h" 2







# 206 "d:/Tornado2.2/target/h/intLib.h"







# 229 "sysLib.c" 2
# 1 "config.h" 1
 

 

 
# 145 "config.h"

 











 






# 1 "d:/Tornado2.2/target/config/all/configAll.h" 1
 

 

 
# 184 "d:/Tornado2.2/target/config/all/configAll.h"

 








# 1 "d:/Tornado2.2/target/h/smLib.h" 1
 

 
 
# 34 "d:/Tornado2.2/target/h/smLib.h"








 




 

 






 


					 




 






 




 




 



					 




					 





					 




					 
					 








					 

					 








 







 

typedef struct sm_cpu_desc	 
    {
    int		status;		 
    int		intType;	 
    int		intArg1;	 
    int		intArg2;	 
    int		intArg3;	 
    int		reserved1;	 
    int		reserved2;	 
    } SM_CPU_DESC;


 

typedef struct sm_hdr		 
    {
    int		tasType;	 
    int		maxCpus;	 
    int		cpuTable;	 
    int		reserved1;	 
    int		reserved2;	 
    int		reserved3;	 
    int		reserved4;	 
    int		reserved5;	 
    int		reserved6;	 
    int		reserved7;	 
    int		reserved8;	 
    } SM_HDR;


 

typedef struct sm_anchor	 
    {
    UINT	readyValue;      
    int		version;         
    int		masterCpu;       
    int		smHeader;	 
    int		smPktHeader;     
    int 	smObjHeader;     
    int		user1;           
    int		user2;           
    int		reserved1;       
    int		reserved2;       
    int		reserved3;       
    } SM_ANCHOR;

 

typedef struct sm_desc		 
    {
    int		status;		 
    SM_ANCHOR	*anchorLocalAdrs; 
    SM_HDR	*headerLocalAdrs; 
    SM_CPU_DESC	*cpuTblLocalAdrs; 
    int		base;		 
    int		cpuNum;		 
    int		ticksPerBeat;	 
    int		intType;	 
    int		intArg1;	 
    int		intArg2;	 
    int		intArg3;	 
    int		maxCpus;	 
    FUNCPTR	tasRoutine;	 
    FUNCPTR	tasClearRoutine; 
    } SM_DESC;


 

typedef struct sm_info		 
    {
    int		version;	 
    int		tasType;	 
    int		maxCpus;	 
    int		attachedCpus;	 
    } SM_INFO;


 

typedef struct sm_cpu_info	 
    {
    int		cpuNum;		 
    int		status;		 
    int		intType;	 
    int		intArg1;	 
    int		intArg2;	 
    int		intArg3;	 
    } SM_CPU_INFO;

typedef struct sm_region	 
    {
    SM_ANCHOR *	anchor;		 
    } SM_REGION;





 

extern int	smCurMaxTries;     
extern VOIDFUNCPTR smUtilTasClearRtn;
extern FUNCPTR smUtilUser1Rtn;
extern FUNCPTR smUtilUser2Rtn;

 



extern void	smLibInit (void * pRgnCfgTbl, UINT objSize, UINT netSize);
extern STATUS 	smSetup (SM_ANCHOR *anchorLocalAdrs, char *smLocalAdrs,
			 int tasType, int maxCpus, int	* pMemUsed);
extern STATUS	smAttach (SM_DESC *pSmDesc);
extern STATUS 	smDetach (SM_DESC *pSmDesc);
extern void 	smInit (SM_DESC *pSmDesc, SM_ANCHOR *anchorLocalAdrs,
			int ticksPerBeat, int intType, int intArg1,
			int intArg2, int intArg3);
extern BOOL 	smIsAlive (SM_ANCHOR *pAnchor, int *pHeader, int base,
			   int heartBeats, int ticksPerBeat);
extern STATUS 	smLockTake (int * lockLocalAdrs, FUNCPTR tasRoutine,
			   int numTries, int * pOldLvl);
extern void	smLockGive (int *lockLocalAdrs, FUNCPTR tasClearRoutine,
			    int oldLvl);
extern STATUS 	smInfoGet (SM_DESC *pSmDesc, SM_INFO *pInfo);
extern STATUS 	smCpuInfoGet (SM_DESC *pSmDesc, int cpuNum,
			      SM_CPU_INFO *pCpuInfo);



# 276 "d:/Tornado2.2/target/h/smLib.h"









# 195 "d:/Tornado2.2/target/config/all/configAll.h" 2

# 1 "d:/Tornado2.2/target/h/iv.h" 1
 

 

 
# 38 "d:/Tornado2.2/target/h/iv.h"

















































# 1 "d:/Tornado2.2/target/h/arch/i86/ivI86.h" 1
 

 

 
# 14 "d:/Tornado2.2/target/h/arch/i86/ivI86.h"









 






















 

 




 




 































# 88 "d:/Tornado2.2/target/h/iv.h" 2




















# 197 "d:/Tornado2.2/target/config/all/configAll.h" 2

 
 
 
 
 








































 
 











 

 















































 






# 327 "d:/Tornado2.2/target/config/all/configAll.h"


 
 
 
 
 


# 426 "d:/Tornado2.2/target/config/all/configAll.h"

 
 
 
 
 






















 
























 


# 490 "d:/Tornado2.2/target/config/all/configAll.h"


# 500 "d:/Tornado2.2/target/config/all/configAll.h"


# 510 "d:/Tornado2.2/target/config/all/configAll.h"











# 529 "d:/Tornado2.2/target/config/all/configAll.h"


# 540 "d:/Tornado2.2/target/config/all/configAll.h"


# 550 "d:/Tornado2.2/target/config/all/configAll.h"












# 570 "d:/Tornado2.2/target/config/all/configAll.h"











# 592 "d:/Tornado2.2/target/config/all/configAll.h"





 



 







 













 



 











 































 








 
 
 
 
 

 




 
 
 
 
 

 








 






 







# 733 "d:/Tornado2.2/target/config/all/configAll.h"

 




 




 




 




 




 








































# 808 "d:/Tornado2.2/target/config/all/configAll.h"


 









 










 





 












 

 
 
 
 
 











 


 
 
 
 
 

# 932 "d:/Tornado2.2/target/config/all/configAll.h"




     



















 


                                          
                                          








 
























 





























 






 


# 1042 "d:/Tornado2.2/target/config/all/configAll.h"

 








 








 


# 1073 "d:/Tornado2.2/target/config/all/configAll.h"

 






 





 












# 166 "config.h" 2
# 1 "pc.h" 1
 

 

 
# 59 "pc.h"

 











# 1 "d:/Tornado2.2/target/h/drv/intrCtl/i8259.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/drv/intrCtl/i8259.h"








 




 





 




 


















extern VOID	i8259Init	(void);
extern int	sysIntLevel	(int arg);
extern VOID	sysIntLock	(void);
extern VOID	sysIntUnlock	(void);
extern VOID 	i8259IntBoi 	(int irqNo);
extern VOID 	i8259IntBoiEem	(int irqNo);
extern VOID 	i8259IntBoiSmm	(int irqNo);
extern VOID 	i8259IntEoiSmm	(int irqNo);
extern VOID 	i8259IntEoiMaster (int irqNo);
extern VOID 	i8259IntEoiSlave (int irqNo);
extern VOID 	i8259IntEoiSlaveNfnm (int irqNo);
extern VOID 	i8259IntEoiSlaveSfnm (int irqNo);


# 89 "d:/Tornado2.2/target/h/drv/intrCtl/i8259.h"









# 73 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/timer/i8253.h" 1
 

 

 













 




 





 












# 74 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/timer/mc146818.h" 1
 

 

 


















typedef struct
    {
    int rate;
    char bits;
    } CLK_RATE;




 






 





 










 






 










# 75 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/timer/timerDev.h" 1
 

 

 








 





# 80 "d:/Tornado2.2/target/h/drv/timer/timerDev.h"

# 76 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/timer/timestampDev.h" 1
 

 

 







 




# 1 "d:/Tornado2.2/target/h/drv/timer/timerDev.h" 1
 

 

 








 





# 80 "d:/Tornado2.2/target/h/drv/timer/timerDev.h"

# 19 "d:/Tornado2.2/target/h/drv/timer/timestampDev.h" 2

# 77 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/fdisk/nec765Fd.h" 1
 

 
 
# 16 "d:/Tornado2.2/target/h/drv/fdisk/nec765Fd.h"











# 1 "d:/Tornado2.2/target/h/blkIo.h" 1
 

 

 
# 21 "d:/Tornado2.2/target/h/blkIo.h"










typedef struct		 
    {
    FUNCPTR		bd_blkRd;		 
    FUNCPTR		bd_blkWrt;		 
    FUNCPTR		bd_ioctl;		 
    FUNCPTR		bd_reset;		 
    FUNCPTR		bd_statusChk;		 
    BOOL		bd_removable;		 
    ULONG		bd_nBlocks;		 
    ULONG		bd_bytesPerBlk;		 
    ULONG		bd_blksPerTrack;	 
    ULONG		bd_nHeads;		 
    int			bd_retry;		 
    int			bd_mode;		 
    BOOL		bd_readyChanged;	 
    } BLK_DEV;







# 28 "d:/Tornado2.2/target/h/drv/fdisk/nec765Fd.h" 2

typedef struct fdDev
    {
    BLK_DEV blkDev;
    int fdType;		 
    int drive;		 
    int blkOffset;	 
    } FD_DEV;

typedef struct fdType
    {
    int sectors;	 
    int sectorsTrack;	 
    int heads;		 
    int cylinders;	 
    int secSize;	 
    char gap1;		 
    char gap2;		 
    char dataRate;	 
    char stepRate;	 
    char headUnload;	 
    char headLoad;	 
    char mfm;		 
    char sk;		 
    char *name;		 
    } FD_TYPE;

typedef struct fdRaw
    {				 
    UINT cylinder;		 
    UINT head;			 
    UINT sector;			 
    char *pBuf;			 
    UINT nSecs;			 
    UINT direction;		 
    } FD_RAW;


 



 






 








 











 










 


















 




 



STATUS		fdDrv		(int vector, int level);
BLK_DEV		*fdDevCreate	(int fdType, int drive, int nBlks, int offset);
STATUS		fdRawio		(int drive, int fdType, FD_RAW *pFdRaw);
STATUS		usrFdConfig	(int type, int drive, char *fileName);



















# 78 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/serial/pcConsole.h" 1
 

 

 
# 14 "d:/Tornado2.2/target/h/drv/serial/pcConsole.h"










# 1 "d:/Tornado2.2/target/h/tyLib.h" 1
 

 

 
# 53 "d:/Tornado2.2/target/h/tyLib.h"








# 1 "d:/Tornado2.2/target/h/iosLib.h" 1
 

 

 
# 36 "d:/Tornado2.2/target/h/iosLib.h"









# 1 "d:/Tornado2.2/target/h/ioLib.h" 1
 

 

 
# 89 "d:/Tornado2.2/target/h/ioLib.h"









# 1 "d:/Tornado2.2/target/h/limits.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/limits.h"










 








# 1 "d:/Tornado2.2/target/h/tool/gnu/limits.h" 1



 



 



 




 





 



 












 

 




 



 








 



 













 




# 96 "d:/Tornado2.2/target/h/tool/gnu/limits.h"




# 37 "d:/Tornado2.2/target/h/limits.h" 2


































# 99 "d:/Tornado2.2/target/h/ioLib.h" 2
# 1 "d:/Tornado2.2/target/h/net/uio.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/uio.h"

 





















struct iovec {
	caddr_t	iov_base;
	int	iov_len;
};

enum	uio_rw { UIO_READ, UIO_WRITE };

 
enum uio_seg {
	UIO_USERSPACE,		 
	UIO_SYSSPACE,		 
	UIO_USERISPACE		 
};

struct uio {
	struct	iovec *uio_iov;
	int	uio_iovcnt;
	off_t	uio_offset;
	int	uio_resid;
	enum	uio_seg uio_segflg;
	enum	uio_rw uio_rw;



};
















# 100 "d:/Tornado2.2/target/h/ioLib.h" 2
# 1 "d:/Tornado2.2/target/h/fcntl.h" 1
 

 

 
# 15 "d:/Tornado2.2/target/h/fcntl.h"









# 1 "d:/Tornado2.2/target/h/sys/fcntlcom.h" 1
 

 
 





 

















 























 









 












 









 










 










 


 



















 









 
struct flock {
	short	l_type;		 
	short	l_whence;	 
	long	l_start;	 
	long	l_len;		 
	short	l_pid;		 
	short	l_xxx;		 
};


 
struct eflock {
	short	l_type;		 
	short	l_whence;	 
	long	l_start;	 
	long	l_len;		 
	short	l_pid;		 
	short	l_xxx;		 
	long	l_rpid;		 
	long	l_rsys;		 
};



 







# 25 "d:/Tornado2.2/target/h/fcntl.h" 2





extern int      open (const char *name, int flags, int mode );
extern int      creat (const char *name, int mode );














# 101 "d:/Tornado2.2/target/h/ioLib.h" 2
# 1 "d:/Tornado2.2/target/h/unistd.h" 1
 

 

 
# 20 "d:/Tornado2.2/target/h/unistd.h"
















 









 



extern STATUS 		unlink (char *name);
extern STATUS 		close (int fd);
extern int 		read (int fd, char *buffer, size_t maxbytes);
extern int 		write (int fd, char *buffer, size_t nbytes);
extern int 		lseek (int fd, long offset, int whence);
extern STATUS 		chdir (char *pathname);
extern STATUS 		pause (void);
extern BOOL 		isatty (int fd);
extern STATUS 		rmdir (const char *dirName);
extern char *		getcwd (char *buffer, int size);
extern int    		ftruncate (int fildes, off_t length);
extern unsigned int	sleep (unsigned int);
extern unsigned int	alarm (unsigned int);


# 79 "d:/Tornado2.2/target/h/unistd.h"







# 102 "d:/Tornado2.2/target/h/ioLib.h" 2









 















 




















































 










 


 


















 








 









 

 

typedef struct		 
    {
    int entryNum;		 
    char name[(255 + 1)];	 
    int nChars;			 
    short day;			 
    short month;		 
    short year;			 
    } REQ_DIR_ENTRY;

 
						 
typedef struct
    {
    ULONG  inode;		 
    char * fileName;		 
    } INODE_TO_NAME_IOCTL;
					 
 













 

extern int ioMaxLinkLevels;	 
						 
 







extern STATUS 	ioFullFileNameGet ();

extern STATUS 	ioDefPathCat (char *name);
extern STATUS 	ioDefPathSet (char *name);
extern char *	getwd (char *pathname);
extern int 	ioGlobalStdGet (int stdFd);
extern int 	ioTaskStdGet (int taskId, int stdFd);
extern int 	ioctl (int fd, int function, int arg);
extern int      readv (int fd, struct iovec *iov, int iovcnt);
extern void 	ioDefDevGet (char *devName);
extern void 	ioDefDirGet (char *dirName);
extern void 	ioDefPathGet (char *pathname);
extern void 	ioGlobalStdSet (int stdFd, int newFd);
extern void 	ioTaskStdSet (int taskId, int stdFd, int newFd);
extern int      writev (int fd, struct iovec *iov, int iovcnt);


# 314 "d:/Tornado2.2/target/h/ioLib.h"


 









 


















# 46 "d:/Tornado2.2/target/h/iosLib.h" 2
# 1 "d:/Tornado2.2/target/h/dllLib.h" 1
 

 

 
# 20 "d:/Tornado2.2/target/h/dllLib.h"









 

typedef struct dlnode		 
    {
    struct dlnode *next;	 
    struct dlnode *previous;	 
    } DL_NODE;


 

typedef struct			 
    {
    DL_NODE *head;	 
    DL_NODE *tail;	 
    } DL_LIST;

 

 
# 61 "d:/Tornado2.2/target/h/dllLib.h"






 
# 79 "d:/Tornado2.2/target/h/dllLib.h"






 
# 97 "d:/Tornado2.2/target/h/dllLib.h"






 
# 115 "d:/Tornado2.2/target/h/dllLib.h"






 
# 131 "d:/Tornado2.2/target/h/dllLib.h"







 



extern DL_LIST *dllCreate (void);
extern DL_NODE *dllEach (DL_LIST *pList, FUNCPTR routine, int routineArg);
extern DL_NODE *dllGet (DL_LIST *pList);
extern STATUS 	dllDelete (DL_LIST *pList);
extern STATUS 	dllInit (DL_LIST *pList);
extern STATUS 	dllTerminate (DL_LIST *pList);
extern int 	dllCount (DL_LIST *pList);
extern void 	dllAdd (DL_LIST *pList, DL_NODE *pNode);
extern void 	dllInsert (DL_LIST *pList, DL_NODE *pPrev, DL_NODE *pNode);
extern void 	dllRemove (DL_LIST *pList, DL_NODE *pNode);


# 167 "d:/Tornado2.2/target/h/dllLib.h"






# 47 "d:/Tornado2.2/target/h/iosLib.h" 2


 









typedef struct 		 
    {
    DL_NODE	node;		 
    short	drvNum;		 
    char *	name;		 
    } DEV_HDR;


 




extern STATUS 	iosInit (int max_drivers, int max_files, char *nullDevName);
extern void 	iosShowInit (void);
extern DEV_HDR *iosDevFind (char *name, char ** pNameTail);
extern DEV_HDR *iosFdDevFind (int fd);
extern DEV_HDR *iosNextDevGet (DEV_HDR *pDev);
extern STATUS 	iosClose (int fd);
extern STATUS 	iosDevAdd (DEV_HDR *pDevHdr, char *name, int drvnum);
extern STATUS 	iosDrvRemove (int drvnum, BOOL forceClose);
extern int 	iosCreate (DEV_HDR *pDevHdr, char *fileName, int mode);
extern int 	iosDelete (DEV_HDR *pDevHdr, char *fileName);
extern int 	iosDrvInstall (FUNCPTR pCreate, FUNCPTR pDelete, FUNCPTR pOpen,
			       FUNCPTR pClose, FUNCPTR pRead, FUNCPTR pWrite,
			       FUNCPTR pIoctl);
extern int 	iosFdNew (DEV_HDR *pDevHdr, char *name, int value);
extern int 	iosFdValue (int fd);
extern int 	iosIoctl (int fd, int function, int arg);
extern int 	iosOpen (DEV_HDR *pDevHdr, char *fileName, int flags, int mode);
extern int 	iosRead (int fd, char *buffer, int maxbytes);
extern int 	iosWrite (int fd, char *buffer, int nbytes);
extern void 	iosDevDelete (DEV_HDR *pDevHdr);
extern void 	iosDevShow (void);
extern void 	iosDrvShow (void);
extern void 	iosFdFree (int fd);
extern STATUS 	iosFdSet (int fd, DEV_HDR *pDevHdr, char *name, int value);
extern void 	iosFdShow (void);


# 125 "d:/Tornado2.2/target/h/iosLib.h"







# 62 "d:/Tornado2.2/target/h/tyLib.h" 2
# 1 "d:/Tornado2.2/target/h/rngLib.h" 1
 

 

 
# 29 "d:/Tornado2.2/target/h/rngLib.h"









 

 

typedef struct		 
    {
    int pToBuf;		 
    int pFromBuf;	 
    int bufSize;	 
    char *buf;		 
    } RING;

 

typedef RING *RING_ID;


 








 
# 75 "d:/Tornado2.2/target/h/rngLib.h"


# 88 "d:/Tornado2.2/target/h/rngLib.h"

 
# 100 "d:/Tornado2.2/target/h/rngLib.h"


# 127 "d:/Tornado2.2/target/h/rngLib.h"

 



extern BOOL 	rngIsEmpty (RING_ID ringId);
extern BOOL 	rngIsFull (RING_ID ringId);
extern RING_ID 	rngCreate (int nbytes);
extern int 	rngBufGet (RING_ID rngId, char *buffer, int maxbytes);
extern int 	rngBufPut (RING_ID rngId, char *buffer, int nbytes);
extern int 	rngFreeBytes (RING_ID ringId);
extern int 	rngNBytes (RING_ID ringId);
extern void 	rngDelete (RING_ID ringId);
extern void 	rngFlush (RING_ID ringId);
extern void 	rngMoveAhead (RING_ID ringId, int n);
extern void 	rngPutAhead (RING_ID ringId, char byte, int offset);


# 159 "d:/Tornado2.2/target/h/rngLib.h"







# 63 "d:/Tornado2.2/target/h/tyLib.h" 2
# 1 "d:/Tornado2.2/target/h/selectLib.h" 1
 

 

 
# 32 "d:/Tornado2.2/target/h/selectLib.h"









# 1 "d:/Tornado2.2/target/h/sys/times.h" 1
 

 

 
# 23 "d:/Tornado2.2/target/h/sys/times.h"












 




struct timeval
    {
    long tv_sec;	 
    long tv_usec;	 
    };

struct timezone
    {
    int	tz_minuteswest;	 
    int	tz_dsttime;	 
    };













# 42 "d:/Tornado2.2/target/h/selectLib.h" 2

 





typedef enum
    {
    SELREAD,
    SELWRITE
    } SELECT_TYPE;

# 1 "d:/Tornado2.2/target/h/private/selectLibP.h" 1
 

 

 













# 1 "d:/Tornado2.2/target/h/lstLib.h" 1
 

 

 
# 28 "d:/Tornado2.2/target/h/lstLib.h"












 

typedef struct node		 
    {
    struct node *next;		 
    struct node *previous;	 
    } NODE;


 

typedef struct			 
    {
    NODE node;			 
    int count;			 
    } LIST;

 


 




extern void	lstLibInit (void);
extern NODE *	lstFirst (LIST *pList);
extern NODE *	lstGet (LIST *pList);
extern NODE *	lstLast (LIST *pList);
extern NODE *	lstNStep (NODE *pNode, int nStep);
extern NODE *	lstNext (NODE *pNode);
extern NODE *	lstNth (LIST *pList, int nodenum);
extern NODE *	lstPrevious (NODE *pNode);
extern int 	lstCount (LIST *pList);
extern int 	lstFind (LIST *pList, NODE *pNode);
extern void 	lstAdd (LIST *pList, NODE *pNode);
extern void 	lstConcat (LIST *pDstList, LIST *pAddList);
extern void 	lstDelete (LIST *pList, NODE *pNode);
extern void 	lstExtract (LIST *pSrcList, NODE *pStartNode, NODE *pEndNode,
	  		    LIST *pDstList);
extern void 	lstFree (LIST *pList);
extern void 	lstInit (LIST *pList);
extern void 	lstInsert (LIST *pList, NODE *pPrev, NODE *pNode);


# 105 "d:/Tornado2.2/target/h/lstLib.h"









# 20 "d:/Tornado2.2/target/h/private/selectLibP.h" 2
# 1 "d:/Tornado2.2/target/h/private/semLibP.h" 1
 

 

 
# 20 "d:/Tornado2.2/target/h/private/semLibP.h"










# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 31 "d:/Tornado2.2/target/h/private/semLibP.h" 2
# 1 "d:/Tornado2.2/target/h/semLib.h" 1
 

 

 
# 34 "d:/Tornado2.2/target/h/semLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 44 "d:/Tornado2.2/target/h/semLib.h" 2

 






 











 

typedef enum		 
    {
    SEM_EMPTY,			 
    SEM_FULL			 
    } SEM_B_STATE;

typedef struct semaphore *SEM_ID;

 



extern STATUS 	semGive (SEM_ID semId);
extern STATUS 	semTake (SEM_ID semId, int timeout);
extern STATUS 	semFlush (SEM_ID semId);
extern STATUS 	semDelete (SEM_ID semId);
extern int 	semInfo (SEM_ID semId, int idList[], int maxTasks);
extern STATUS 	semBLibInit (void);
extern SEM_ID 	semBCreate (int options, SEM_B_STATE initialState);
extern STATUS 	semCLibInit (void);
extern SEM_ID 	semCCreate (int options, int initialCount);
extern STATUS 	semMLibInit (void);
extern SEM_ID 	semMCreate (int options);
extern STATUS   semMGiveForce (SEM_ID semId);
extern STATUS 	semOLibInit (void);
extern SEM_ID 	semCreate (void);
extern void 	semShowInit (void);
extern STATUS 	semShow (SEM_ID semId, int level);


# 115 "d:/Tornado2.2/target/h/semLib.h"








# 32 "d:/Tornado2.2/target/h/private/semLibP.h" 2
# 1 "d:/Tornado2.2/target/h/qLib.h" 1
 

 

 
# 28 "d:/Tornado2.2/target/h/qLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 38 "d:/Tornado2.2/target/h/qLib.h" 2
# 1 "d:/Tornado2.2/target/h/qClass.h" 1
 

 

 
# 22 "d:/Tornado2.2/target/h/qClass.h"












 

typedef struct q_class		 
    {
    FUNCPTR createRtn;		 
    FUNCPTR initRtn;		 
    FUNCPTR deleteRtn;		 
    FUNCPTR terminateRtn;	 
    FUNCPTR putRtn;		 
    FUNCPTR getRtn;		 
    FUNCPTR removeRtn;		 
    FUNCPTR resortRtn;		 
    FUNCPTR advanceRtn;		 
    FUNCPTR getExpiredRtn;	 
    FUNCPTR keyRtn;		 
    FUNCPTR calibrateRtn;	 
    FUNCPTR infoRtn;		 
    FUNCPTR eachRtn;		 
    struct q_class *valid;	 
    } Q_CLASS;

typedef Q_CLASS *Q_CLASS_ID;	 

 

 
# 70 "d:/Tornado2.2/target/h/qClass.h"

















# 39 "d:/Tornado2.2/target/h/qLib.h" 2

 





 

extern Q_CLASS_ID		qFifoClassId;
extern Q_CLASS_ID		qPriListClassId;
extern Q_CLASS_ID		qPriListFromTailClassId;
extern Q_CLASS_ID		qPriDeltaClassId;
extern Q_CLASS_ID		qPriHeapClassId;
extern Q_CLASS_ID		qPriBMapClassId;

 








 

 








typedef struct		 
    {
    UINT     qPriv1;			 
    UINT     qPriv2;			 
    UINT     qPriv3;			 
    UINT     qPriv4;			 
    } Q_NODE;


 








typedef struct		 
    {
    Q_NODE  *pFirstNode;		 
    UINT     qPriv1;			 
    UINT     qPriv2;			 
    Q_CLASS *pQClass;			 
    } Q_HEAD;





 


 
# 121 "d:/Tornado2.2/target/h/qLib.h"




 
# 134 "d:/Tornado2.2/target/h/qLib.h"





 
# 152 "d:/Tornado2.2/target/h/qLib.h"





 












 
# 179 "d:/Tornado2.2/target/h/qLib.h"





 
# 194 "d:/Tornado2.2/target/h/qLib.h"





 
# 215 "d:/Tornado2.2/target/h/qLib.h"





 
# 232 "d:/Tornado2.2/target/h/qLib.h"





 
# 246 "d:/Tornado2.2/target/h/qLib.h"





 
# 266 "d:/Tornado2.2/target/h/qLib.h"





 
# 290 "d:/Tornado2.2/target/h/qLib.h"







extern Q_HEAD *	qCreate (Q_CLASS *pQClass, ...);
extern Q_NODE *	qEach (Q_HEAD *pQHead, FUNCPTR routine, int routineArg);
extern Q_NODE *	qFirst (Q_HEAD *pQHead);
extern Q_NODE *	qGet (Q_HEAD *pQHead);
extern Q_NODE *	qGetExpired (Q_HEAD *pQHead);
extern STATUS 	qDelete (Q_HEAD *pQHead);
extern STATUS 	qInit (Q_HEAD *pQHead, Q_CLASS *pQClass, ...);
extern STATUS 	qTerminate (Q_HEAD *pQHead);
extern ULONG 	qKey (Q_HEAD *pQHead, Q_NODE *pQNode, int keyType);
extern int 	qInfo (Q_HEAD *pQHead, Q_NODE *nodeArray [ ], int maxNodes);
extern void 	qAdvance (Q_HEAD *pQHead);
extern void 	qCalibrate (Q_HEAD *pQHead, ULONG keyDelta);
extern void 	qPut (Q_HEAD *pQHead, Q_NODE *pQNode, ULONG key);
extern STATUS 	qRemove (Q_HEAD *pQHead, Q_NODE *pQNode);
extern void 	qResort (Q_HEAD *pQHead, Q_NODE *pQNode, ULONG newKey);


# 332 "d:/Tornado2.2/target/h/qLib.h"









# 33 "d:/Tornado2.2/target/h/private/semLibP.h" 2
# 1 "d:/Tornado2.2/target/h/private/classLibP.h" 1
 

 
 
# 13 "d:/Tornado2.2/target/h/private/classLibP.h"










# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 24 "d:/Tornado2.2/target/h/private/classLibP.h" 2

# 1 "d:/Tornado2.2/target/h/classLib.h" 1
 

 

 
# 21 "d:/Tornado2.2/target/h/classLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 31 "d:/Tornado2.2/target/h/classLib.h" 2
# 1 "d:/Tornado2.2/target/h/objLib.h" 1
 

 

 
# 33 "d:/Tornado2.2/target/h/objLib.h"









# 1 "d:/Tornado2.2/target/h/errno.h" 1
 

 

 







 
# 36 "d:/Tornado2.2/target/h/errno.h"










 








































 



 

	 












	 


















 






 



 










 


 




 




extern int *	__errno(void);






# 176 "d:/Tornado2.2/target/h/errno.h"














# 43 "d:/Tornado2.2/target/h/objLib.h" 2
# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 44 "d:/Tornado2.2/target/h/objLib.h" 2


 









 

typedef struct obj_core  *OBJ_ID;		 


 
# 75 "d:/Tornado2.2/target/h/objLib.h"


# 91 "d:/Tornado2.2/target/h/objLib.h"


 



extern STATUS 	objShow (OBJ_ID objId, int showType);















# 32 "d:/Tornado2.2/target/h/classLib.h" 2


 






typedef struct obj_class *CLASS_ID;		 

extern CLASS_ID classClassId;			 

 



extern STATUS 	classLibInit (void);
extern STATUS 	classMemPartIdSet (CLASS_ID classId, PART_ID memPartId);
extern void 	classShowInit (void);
extern STATUS 	classShow (CLASS_ID classId, int level);


















# 26 "d:/Tornado2.2/target/h/private/classLibP.h" 2
# 1 "d:/Tornado2.2/target/h/private/objLibP.h" 1
 

 

 
















# 1 "d:/Tornado2.2/target/h/objLib.h" 1
 

 

 
# 33 "d:/Tornado2.2/target/h/objLib.h"


# 112 "d:/Tornado2.2/target/h/objLib.h"

# 23 "d:/Tornado2.2/target/h/private/objLibP.h" 2









typedef struct obj_core		 
    {
    struct obj_class *pObjClass;	 
    } OBJ_CORE;






 



extern OBJ_ID 	objCreate (CLASS_ID classId, ...);
extern STATUS 	objInit (CLASS_ID classId, OBJ_ID objId, ...);
extern STATUS 	objDelete (OBJ_ID objId);
extern STATUS 	objDestroy (OBJ_ID objId, BOOL dealloc, int timeout);
extern STATUS 	objFree (CLASS_ID classId, char *pObject);
extern STATUS 	objTerminate (OBJ_ID objId);
extern void *	objAlloc (CLASS_ID classId);
extern void *	objAllocExtra (CLASS_ID classId, unsigned nExtraBytes,
			       void ** ppExtra);
extern void 	objCoreInit (OBJ_CORE *pObjCore, CLASS_ID pObjClass);
extern void 	objCoreTerminate (OBJ_CORE *pObjCore);


# 72 "d:/Tornado2.2/target/h/private/objLibP.h"









# 27 "d:/Tornado2.2/target/h/private/classLibP.h" 2

 









typedef struct obj_class	 
    {
    OBJ_CORE		objCore;	 
    struct mem_part	*objPartId;	 
    unsigned		objSize;	 
    unsigned		objAllocCnt;	 
    unsigned		objFreeCnt;	 
    unsigned		objInitCnt;	 
    unsigned		objTerminateCnt; 
    int			coreOffset;	 
    FUNCPTR		createRtn;	 
    FUNCPTR		initRtn;	 
    FUNCPTR		destroyRtn;	 
    FUNCPTR		showRtn;	 
    FUNCPTR		instRtn;	 
    } OBJ_CLASS;


 



extern CLASS_ID	classCreate (unsigned objectSize, int coreOffset,
			     FUNCPTR createRtn, FUNCPTR initRtn,
			     FUNCPTR destroyRtn);
extern STATUS	classInit (OBJ_CLASS *pObjClass, unsigned objectSize,
			   int coreOffset, FUNCPTR createRtn, FUNCPTR initRtn,
			   FUNCPTR destroyRtn);
extern STATUS	classDestroy (CLASS_ID classId);
extern STATUS	classInstConnect (CLASS_ID classId, FUNCPTR instRtn);
extern STATUS	classShowConnect (CLASS_ID classId, FUNCPTR showRtn);
extern STATUS   classInstrument ( OBJ_CLASS * pObjClass, 
				  OBJ_CLASS * pObjInstClass );



# 83 "d:/Tornado2.2/target/h/private/classLibP.h"








   







# 34 "d:/Tornado2.2/target/h/private/semLibP.h" 2

# 1 "d:/Tornado2.2/target/h/private/eventLibP.h" 1
 

 

 






















extern VOIDFUNCPTR eventEvtRtn;  

 

typedef struct eventsCb
    {
    UINT32 wanted;	 
    volatile UINT32 received;	 
    UINT8  options;	 
    UINT8  sysflags;	 
    UINT8  pad[2];	 
    } EVENTS;		 

 



 




 

typedef struct eventsResourceCb
    {
    UINT32 registered;	 
    int    taskId;	 
    UINT8  options;	 
    UINT8  pad[3];	 
    } EVENTS_RSRC;	 





 














extern void 	eventLibInit	(void);
extern void 	eventInit	(EVENTS_RSRC * pEvRsrc);
extern void 	eventTerminate 	(const EVENTS_RSRC * pEvRsrc);
extern void 	semEvLibInit	(void);
extern void 	msgQEvLibInit	(void);
extern STATUS 	eventStart	(OBJ_ID objId, EVENTS_RSRC * pEvRsrc,
				 FUNCPTR isRsrcFree, UINT32 events,
				 UINT8 options);
extern STATUS	eventRsrcSend	(int taskId, UINT32 events);
extern STATUS	eventRsrcShow	(EVENTS_RSRC * pEvRsrc);
extern STATUS   eventTaskShow	(EVENTS	* pEvents);


# 104 "d:/Tornado2.2/target/h/private/eventLibP.h"
















# 36 "d:/Tornado2.2/target/h/private/semLibP.h" 2





 













typedef struct semaphore  
    {
    OBJ_CORE	objCore;	 
    UINT8	semType;	 
    UINT8	options;	 
    UINT16	recurse;	 
    Q_HEAD	qHead;		 
    union
	{
	UINT		 count;	 
	struct windTcb	*owner;	 
	} state;
    EVENTS_RSRC	events;		 

    } SEMAPHORE;




 
# 84 "d:/Tornado2.2/target/h/private/semLibP.h"



 
# 97 "d:/Tornado2.2/target/h/private/semLibP.h"







 

extern OBJ_CLASS	semClass;		 
extern OBJ_CLASS	semInstClass;		 
extern CLASS_ID		semClassId;		 
extern CLASS_ID		semInstClassId;		 
extern FUNCPTR		semGiveTbl [];		 
extern FUNCPTR		semTakeTbl [];		 
extern FUNCPTR		semFlushTbl [];		 
extern FUNCPTR		semGiveDeferTbl [];	 
extern FUNCPTR		semFlushDeferTbl [];	 
extern int		semMGiveKernWork;	 

extern FUNCPTR  semSmShowRtn;	 
extern FUNCPTR  semSmInfoRtn;	 

 



extern STATUS	semLibInit (void);
extern STATUS	semTerminate (SEM_ID semId);
extern STATUS	semDestroy (SEM_ID semId, BOOL dealloc);
extern STATUS	semGiveDefer (SEM_ID semId);
extern STATUS	semFlushDefer (SEM_ID semId);
extern STATUS	semInvalid (SEM_ID semId);
extern STATUS	semIntRestrict (SEM_ID semId);
extern STATUS	semQInit (SEMAPHORE *pSemaphore, int options);
extern STATUS	semQFlush (SEM_ID semId);
extern void	semQFlushDefer (SEM_ID semId);
extern STATUS	semBInit (SEMAPHORE *pSem,int options,SEM_B_STATE initialState);
extern STATUS	semBCoreInit (SEMAPHORE *pSemaphore, int options,
			      SEM_B_STATE initialState);
extern STATUS	semBGive (SEM_ID semId);
extern STATUS	semBTake (SEM_ID semId, int timeout);
extern void	semBGiveDefer (SEM_ID semId);
extern STATUS	semMInit (SEMAPHORE *pSem, int options);
extern STATUS	semMCoreInit (SEMAPHORE *pSemaphore, int options);
extern STATUS	semMGive (SEM_ID semId);
extern STATUS	semMTake (SEM_ID semId, int timeout);
extern STATUS	semMGiveKern (SEM_ID semId);
extern STATUS	semMPendQPut (SEM_ID semId, int timeout);
extern STATUS	semCInit (SEMAPHORE *pSem,int options,int initialCount);
extern STATUS	semCCoreInit (SEMAPHORE *pSemaphore, int options,
			      int initialCount);
extern STATUS	semCGive (SEM_ID semId);
extern STATUS	semCTake (SEM_ID semId, int timeout);
extern void	semCGiveDefer (SEM_ID semId);
extern STATUS	semOTake (SEM_ID semId);


# 185 "d:/Tornado2.2/target/h/private/semLibP.h"


# 201 "d:/Tornado2.2/target/h/private/semLibP.h"












# 21 "d:/Tornado2.2/target/h/private/selectLibP.h" 2

typedef struct selWkNode
    {
    NODE		linkedListHooks; 
    BOOL		dontFree;	 
    int			taskId;		 
    int			fd;		 
    SELECT_TYPE		type;		 
    } SEL_WAKEUP_NODE;

typedef struct
    {
    SEMAPHORE		listMutex;	 
    SEL_WAKEUP_NODE	firstNode;	 
    LIST		wakeupList;	 
    } SEL_WAKEUP_LIST;

typedef struct selContext
    {
    SEMAPHORE	wakeupSem;		 
    BOOL     	pendedOnSelect;		 

    fd_set     *pReadFds;		 
    fd_set     *pWriteFds;		 

     

    fd_set     *pOrigReadFds;		 
    fd_set     *pOrigWriteFds;		 
    int		width;			 

     
# 63 "d:/Tornado2.2/target/h/private/selectLibP.h"

    } SEL_CONTEXT;


 



extern void	selectInit		(int numFiles);
extern void	selTaskDeleteHookAdd 	(void);
















# 56 "d:/Tornado2.2/target/h/selectLib.h" 2

 



extern SELECT_TYPE  selWakeupType 	(SEL_WAKEUP_NODE *pWakeupNode);
extern STATUS 	    selNodeAdd 	      	(SEL_WAKEUP_LIST *pWakeupList,
			    		 SEL_WAKEUP_NODE *pWakeupNode);
extern STATUS 	    selNodeDelete 	(SEL_WAKEUP_LIST *pWakeupList,
			       		 SEL_WAKEUP_NODE *pWakeupNode);
extern int 	    selWakeupListLen 	(SEL_WAKEUP_LIST *pWakeupList);
extern void 	    selWakeup 		(SEL_WAKEUP_NODE *pWakeupNode);
extern void 	    selWakeupAll 	(SEL_WAKEUP_LIST *pWakeupList, 
					 SELECT_TYPE type);
extern void 	    selWakeupListInit 	(SEL_WAKEUP_LIST *pWakeupList);
extern void 	    selWakeupListTerm 	(SEL_WAKEUP_LIST *pWakeupList);
extern int	    select 		(int width, fd_set *pReadFds, 
					 fd_set *pWriteFds, fd_set *pExceptFds,
					 struct timeval *pTimeOut);


# 89 "d:/Tornado2.2/target/h/selectLib.h"







# 64 "d:/Tornado2.2/target/h/tyLib.h" 2
# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 65 "d:/Tornado2.2/target/h/tyLib.h" 2


 

typedef struct		 
    {
    DEV_HDR	devHdr;		 

    RING_ID	rdBuf;		 
    SEMAPHORE	rdSyncSem;	 
    SEMAPHORE	mutexSem;	 
    struct			 
	{
	unsigned char xoff;      
	unsigned char pending;   
        unsigned char canceled;  
	unsigned char flushingRdBuf;  
	}	rdState;

    RING_ID	wrtBuf;		 
    SEMAPHORE	wrtSyncSem;	 
    struct			 
	{
	unsigned char busy;      
	unsigned char xoff;      
	unsigned char cr;        
        unsigned char canceled;  
	unsigned char flushingWrtBuf;  
	unsigned char wrtBufBusy;  
	}	wrtState;

    UINT8	lnNBytes;	 
    UINT8	lnBytesLeft;	 

    unsigned short options;	 
    FUNCPTR	txStartup;	 
    FUNCPTR	protoHook;	 
    int		protoArg;	 
    SEL_WAKEUP_LIST selWakeupList; 
    int		numOpen;	 
    } TY_DEV;

 

typedef TY_DEV * TY_DEV_ID;

 



extern STATUS 	tyDevInit (TY_DEV_ID pTyDev, int rdBufSize, int wrtBufSize,
			   FUNCPTR txStartup);
extern STATUS 	tyITx (TY_DEV_ID pTyDev, char *pChar);
extern STATUS 	tyIRd (TY_DEV_ID pTyDev, char inchar);
extern STATUS 	tyIoctl (TY_DEV_ID pTyDev, int request, int arg);
extern int 	tyRead (TY_DEV_ID pTyDev, char *buffer, int maxbytes);
extern int 	tyWrite (TY_DEV_ID pTyDev, char *buffer, int nbytes);
extern void 	tyAbortFuncSet (FUNCPTR func);
extern void 	tyAbortSet (char ch);
extern void 	tyBackspaceSet (char ch);
extern void 	tyDeleteLineSet (char ch);
extern void 	tyEOFSet (char ch);
extern void 	tyMonitorTrapSet (char ch);


# 145 "d:/Tornado2.2/target/h/tyLib.h"







# 25 "d:/Tornado2.2/target/h/drv/serial/pcConsole.h" 2



 

typedef struct 
    {
    BOOL	curMode;		 
    int		kbdMode;		 
    UINT16	kbdFlags;		 
    UINT16	kbdState;		 
    int		currCon;		 		
    FUNCPTR 	kbdHook;		 
    BOOL	convertChar;		 
    } KBD_CON_DEV;
   
 

typedef struct 
    {
    UCHAR *	memBase;		 
    UCHAR *	selReg;			 
    UCHAR *	valReg;			 
    int 	row, col;		 
    UCHAR *	curChrPos;      	 
    UCHAR	curAttrib;		 
    UCHAR	defAttrib;      	 
    int 	nrow, ncol;		 
    int 	scst, sced;		 
    BOOL	rev;			 
    BOOL	autoWrap;		 
    BOOL	sv_rev;			 
    int 	sv_row, sv_col;		 
    UCHAR	sv_curAttrib;	 	 
    BOOL	scrollCheck;     	 
    UCHAR *	charSet;         	 
    int		vgaMode;         	 
    BOOL	colorMode;       	 
    BOOL	insMode;         	 
    char	tab_stop [80];      	 
    UINT16	escFlags;		 
    int 	escParaCount;	 	 
    int 	escPara[16];  	 
    BOOL	escQuestion;     	 
    char	escResp[10];     	 
    FUNCPTR     vgaHook;		 
    } VGA_CON_DEV;


 

typedef struct				 
    {
    TY_DEV	tyDev;
    BOOL	created;		 
    KBD_CON_DEV * ks;			 
    VGA_CON_DEV * vs;			 
    } PC_CON_DEV;

 







 











 














 




 














 











 










































 


extern	void	kbdIntr (void);
extern  void 	kbdHrdInit (void);
extern	int	pcConDrv (void);
extern	int	pcConDevCreate (char *name, register int channel, int rdBufSize,
			      int wrtBufSize);
extern  void	vgaHrdInit (void);
extern	int 	vgaWriteString (register PC_CON_DEV * pPcCoDv);


# 214 "d:/Tornado2.2/target/h/drv/serial/pcConsole.h"









# 79 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/parallel/lptDrv.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/drv/parallel/lptDrv.h"










 

# 1 "d:/Tornado2.2/target/h/iosLib.h" 1
 

 

 
# 36 "d:/Tornado2.2/target/h/iosLib.h"


# 131 "d:/Tornado2.2/target/h/iosLib.h"

# 30 "d:/Tornado2.2/target/h/drv/parallel/lptDrv.h" 2


typedef struct lptDev		 
    {
    DEV_HDR	devHdr;
    BOOL	created;	 
    BOOL	autofeed;	 
    BOOL	inservice;	 
    ULONG	data;		 
    ULONG	stat;		 
    ULONG	ctrl;		 
    int 	intCnt;		 
    int 	retryCnt;	 
    int		busyWait;	 
    int 	strobeWait;	 
    int 	timeout;	 
    int 	intLevel;	 
    SEM_ID	muteSem;	 
    SEM_ID	syncSem;	 
    } LPT_DEV;

typedef struct lptResource	 
    {
    int		ioBase;		 
    int		intVector;	 
    int		intLevel;	 
    BOOL	autofeed;        
    int		busyWait;        
    int		strobeWait;      
    int		retryCnt;        
    int		timeout;         
    int		regDelta;	 
    } LPT_RESOURCE;

 



 





 





 





 








 








 




extern LPT_RESOURCE lptResources[];

 



STATUS	lptDrv (int channels, LPT_RESOURCE *pResource);
STATUS	lptDevCreate (char *name, int channel);


















# 80 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/pcmcia/pcmciaLib.h" 1
 

 
 

 














# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 22 "d:/Tornado2.2/target/h/drv/pcmcia/pcmciaLib.h" 2


 







# 1 "d:/Tornado2.2/target/h/dllLib.h" 1
 

 

 
# 20 "d:/Tornado2.2/target/h/dllLib.h"


# 172 "d:/Tornado2.2/target/h/dllLib.h"

# 33 "d:/Tornado2.2/target/h/drv/pcmcia/pcmciaLib.h" 2


# 1 "d:/Tornado2.2/target/h/dosFsLib.h" 1
 

 

 
# 30 "d:/Tornado2.2/target/h/dosFsLib.h"









# 1 "d:/Tornado2.2/target/h/cbioLib.h" 1
 

 

 
# 19 "d:/Tornado2.2/target/h/cbioLib.h"








 


 



typedef	unsigned long block_t ;		 
typedef	unsigned long cookie_t ;	 
typedef struct cbioDev * CBIO_DEV_ID ;   

typedef enum                             
        {CBIO_READ, CBIO_WRITE}          
        CBIO_RW;


typedef struct cbioParams	 
    {
    BOOL	cbioRemovable;	 
    block_t 	nBlocks;	 
    size_t 	bytesPerBlk;	 
    size_t	blockOffset;	 
    short	blocksPerTrack;	 
    short	nHeads;		 
    short	retryCnt;	 
    block_t 	lastErrBlk;	 
    int 	lastErrno;	 
    } CBIO_PARAMS;


 



 
extern STATUS cbioLibInit
    (
    void
    );

 
extern	STATUS cbioBlkRW		
    (
    CBIO_DEV_ID		dev,
    block_t		startBlock,
    block_t		numBlocks,
    addr_t		buffer,
    CBIO_RW		rw,
    cookie_t *		pCookie
    );


 
extern STATUS cbioBytesRW		
    (
    CBIO_DEV_ID 	dev,
    block_t		startBlock,
    off_t		offset,
    addr_t		buffer,
    size_t		nBytes,
    CBIO_RW		rw,
    cookie_t *		pCookie
    );


 
extern STATUS cbioBlkCopy		
    (
    CBIO_DEV_ID 	dev,
    block_t		srcBlock,
    block_t		dstBlock,
    block_t		numBlocks
    );


 
extern STATUS cbioIoctl			
    (
    CBIO_DEV_ID		dev,
    int			command,
    addr_t		arg
    );


 
extern int cbioModeGet  
    (
    CBIO_DEV_ID dev
    );


 
extern STATUS cbioModeSet  
    (
    CBIO_DEV_ID dev,
    int mode
    );


 
extern int cbioRdyChgdGet 
    (
    CBIO_DEV_ID dev
    );


 
extern STATUS cbioRdyChgdSet  
    (
    CBIO_DEV_ID dev,
    BOOL status
    );


 
extern STATUS cbioLock  
    (
    CBIO_DEV_ID	dev,
    int		timeout	 
    );


 
extern STATUS cbioUnlock 
    (
    CBIO_DEV_ID	dev
    );


 
extern STATUS cbioParamsGet		
    (
    CBIO_DEV_ID dev,
    CBIO_PARAMS * pCbioParams		
    );


 
extern STATUS cbioShow	
    (
    CBIO_DEV_ID dev
    );

              
extern STATUS cbioDevVerify                     
    (                                           
    CBIO_DEV_ID device                          
    );                                          
                                                
        
extern CBIO_DEV_ID cbioWrapBlkDev               
    (                                           
    BLK_DEV * pDevice                            
    );                                          

 












 











# 40 "d:/Tornado2.2/target/h/dosFsLib.h" 2


 


 











 




 




 








 

 
 

typedef struct           
    {                            
    enum
        { _AUTO=0, _FAT12=12, _FAT16=16, _FAT32=32 }
                fatType;         
    const char * sysId ;         
    int         secPerClust;     
    short       nResrvd;         
    short       maxRootEnts;     
    char        nFats;           
    ULONG       secPerFat;       
    ULONG       nClust;          
    ULONG       nHidden;         
    ULONG       volSerial ;      
    int         secPerTrack;     
    char        nHeads;          
    char        mediaByte;       
    char        volLabel[ 11 ];  
    } DOS_VOL_CONFIG;

  




typedef struct DOS_VOLUME_DESC *        DOS_VOLUME_DESC_ID;

 








 
 



































 

 

 

extern STATUS dosFsLibInit( int ignored );
extern STATUS dosFsDevCreate ( char * pDevName, CBIO_DEV_ID cbio,
			       u_int maxFiles, u_int autoChkLevel );
extern STATUS dosFsVolUnmount ( void * pDev );
extern STATUS dosFsShow( void * dev, u_int level );
extern STATUS dosFsVolFormat( void * pDev, int opt, FUNCPTR pPromptFunc );
extern void dosFsFmtLibInit( void );
extern void dosChkLibInit( void );
extern STATUS dosDirOldLibInit( void );
extern STATUS dosVDirLibInit ( void );
extern STATUS dosFsFatInit ( void );
extern DOS_VOLUME_DESC_ID dosFsVolDescGet (void * pDevNameOrPVolDesc, 
                                           u_char **   ppTail);

extern STATUS dosFsLastAccessDateEnable (DOS_VOLUME_DESC_ID dosVolDescId, 
                                  BOOL enable);

extern STATUS dosSetVolCaseSens  
    (
    DOS_VOLUME_DESC_ID pVolDesc,
    BOOL sensitivity  
    );

 








 


# 206 "d:/Tornado2.2/target/h/dosFsLib.h"


# 220 "d:/Tornado2.2/target/h/dosFsLib.h"






 


typedef	void * DOS_VOL_DESC ;

 

typedef struct		 
    {
    UINT8		dospt_status;		 
    UINT8		dospt_startHead;	 
    short		dospt_startSec;		 
    UINT8		dospt_type;		 
    UINT8		dospt_endHead;		 
    short		dospt_endSec;		 
    ULONG		dospt_absSec;		 
    ULONG		dospt_nSectors;		 
    } __attribute__((packed, aligned(2))) DOS_PART_TBL;


 
 
typedef struct           
    {
    int         dosdt_year;              
    int         dosdt_month;             
    int         dosdt_day;               
    int         dosdt_hour;              
    int         dosdt_minute;            
    int         dosdt_second;            
    } DOS_DATE_TIME;

 




 


 





 
extern DOS_VOL_DESC *	dosFsDevInit (char *pDevName, BLK_DEV *pBlkDev,
		                      DOS_VOL_CONFIG *pConfig);
extern STATUS 		dosFsInit (int maxFiles);
extern DOS_VOL_DESC *	dosFsMkfs (char *pVolName, BLK_DEV *pBlkDev);

 








# 36 "d:/Tornado2.2/target/h/drv/pcmcia/pcmciaLib.h" 2
# 1 "d:/Tornado2.2/target/h/drv/pcmcia/pccardLib.h" 1
  

 

 





























typedef struct pccardEnabler
    {
    int		type;		 
    void	*pResource;	 
    int		resourceNumEnt;	 
    FUNCPTR	enableRtn;	 
    FUNCPTR	showRtn;	 
    } PCCARD_ENABLER;

typedef struct pccardResource
    {
    int		vcc;		 
    int		vpp;		 
    int		ioStart[2];	 
    int		ioStop[2];	 
    int		ioExtraws;	 
    int		memStart;	 
    int		memStop;	 
    int		memExtraws;	 
    int		memOffset;	 
    int		memLength;	 
    } PCCARD_RESOURCE;

typedef struct ataResource	 
    {
    PCCARD_RESOURCE resource;	 
    int		ctrlType;	 
    int		drives;		 
    int		intVector;	 
    int		intLevel;	 
    int		configType;	 
    int		semTimeout;	 
    int		wdgTimeout;	 
    int		sockTwin;	 
    int		pwrdown;	 
    } ATA_RESOURCE;

typedef struct sramResource	 
    {
    PCCARD_RESOURCE resource;	 
    } SRAM_RESOURCE;

typedef struct eltResource	 
    {
    PCCARD_RESOURCE resource;	 
    int		intVector;	 
    int		intLevel;	 
    int		rxFrames;	 
    int		connector;	 
    } ELT_RESOURCE;

typedef struct tffsResource	 
    {
    PCCARD_RESOURCE resource;	 
    } TFFS_RESOURCE;


 



extern STATUS	pccardMount		(int sock, char *pName);
extern STATUS	pccardMkfs		(int sock, char *pName);
extern STATUS	pccardEltEnabler	(int sock, ELT_RESOURCE *pEltResource,
			 		 int numEnt, FUNCPTR showRtn);
extern STATUS	pccardAtaEnabler	(int sock, ATA_RESOURCE *pAtaResource,
			 		 int numEnt, FUNCPTR showRtn);
extern STATUS	pccardSramEnabler	(int sock, SRAM_RESOURCE *pSramResource,
			 		 int numEnt, FUNCPTR showRtn);
extern STATUS	pccardTffsEnabler	(int sock, TFFS_RESOURCE *pTffsResource,
			 		 int numEnt, FUNCPTR showRtn);
extern void	pccardShowInit		(void);


# 119 "d:/Tornado2.2/target/h/drv/pcmcia/pccardLib.h"










# 37 "d:/Tornado2.2/target/h/drv/pcmcia/pcmciaLib.h" 2












typedef struct pcmciaCard		 
    {
    int		type;			 
    int		sock;			 
    int		ctrl;			 
    BOOL	detected;		 
    BOOL	installed;		 
    BOOL	changed;		 
    int		regBase;		 
    int		regMask;		 
    int		cardStatus;		 
    int		initStatus;		 
    FUNCPTR	cscIntr;		 
    FUNCPTR	showRtn;		 
    DL_LIST	cisTupleList;		 
    DL_LIST	cisConfigList;		 
    PCCARD_RESOURCE *pResource;		 
    BLK_DEV	*pBlkDev;		 
    NETIF	*pNetIf;		 
    DOS_VOL_DESC *pDos;			 
    } PCMCIA_CARD;

typedef struct pcmciaChip		 
    {
    int		type;			 
    char	*name;			 
    BOOL	installed;		 
    int		socks;			 
    int		flags;			 
    int		intLevel;		 
    int		memWindows;		 
    int		ioWindows;		 
    FUNCPTR	reset;			 
    FUNCPTR	status;			 
    FUNCPTR	flagGet;		 
    FUNCPTR	flagSet;		 
    FUNCPTR	cscOn;			 
    FUNCPTR	cscOff;			 
    FUNCPTR	cscPoll;		 
    FUNCPTR	irqGet;			 
    FUNCPTR	irqSet;			 
    FUNCPTR	iowinGet;		 
    FUNCPTR	iowinSet;		 
    FUNCPTR	memwinGet;		 
    FUNCPTR	memwinSet;		 
    FUNCPTR	showRtn;		 
    } PCMCIA_CHIP;

typedef struct pcmciaCtrl
    {
    int		socks;			 
    int		memBase;		 
    PCMCIA_CHIP chip;			 
    PCMCIA_CARD card[8];	 
    } PCMCIA_CTRL;

typedef struct pcmciaIowin
    {
    int		window;
    int		flags;
    int		extraws;
    int		start;
    int		stop;
    } PCMCIA_IOWIN;

typedef struct pcmciaMemwin
    {
    int		window;
    int		flags;
    int		extraws;
    int		start;
    int		stop;
    int		cardstart;
    } PCMCIA_MEMWIN;

typedef struct pcmciaAdapter
    {
    int		type;			 
    int		ioBase;			 
    int		intVec;			 
    int		intLevel;		 
    FUNCPTR	initRtn;		 
    FUNCPTR	showRtn;		 
    } PCMCIA_ADAPTER;

typedef struct pcmciaMsg
    {
    VOIDFUNCPTR	func;			 
    int		arg [6];	 
    } PCMCIA_MSG;

 




 





 






 




 








 











 













 












 









 



extern STATUS 	pcmciaInit	(void);
extern STATUS 	pcmciaJobAdd	(VOIDFUNCPTR func, int arg1, int arg2, 
				 int arg3, int arg4, int arg5, int arg6);
extern void 	pcmciad		(void);
extern void 	pcmciaShowInit	(void);
extern void 	pcmciaShow	(int sock);


# 241 "d:/Tornado2.2/target/h/drv/pcmcia/pcmciaLib.h"









# 81 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/hdisk/ataDrv.h" 1
 

 
 
# 18 "d:/Tornado2.2/target/h/drv/hdisk/ataDrv.h"













# 1 "d:/Tornado2.2/target/h/wdLib.h" 1
 

 

 
# 21 "d:/Tornado2.2/target/h/wdLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 31 "d:/Tornado2.2/target/h/wdLib.h" 2

 

typedef struct wdog *WDOG_ID;		 

 



extern STATUS 	wdLibInit (void);
extern WDOG_ID 	wdCreate (void);
extern STATUS 	wdDelete (WDOG_ID wdId);
extern STATUS 	wdStart (WDOG_ID wdId, int delay, FUNCPTR pRoutine,
			 int parameter);
extern STATUS 	wdCancel (WDOG_ID wdId);
extern void 	wdShowInit (void);
extern STATUS 	wdShow (WDOG_ID wdId);


# 60 "d:/Tornado2.2/target/h/wdLib.h"







# 32 "d:/Tornado2.2/target/h/drv/hdisk/ataDrv.h" 2



extern ATA_RESOURCE ataResources[];
 













typedef struct ataParams 
    {
    short config;		 
    short cylinders;		 
    short removcyl;		 
    short heads;		 
    short bytesTrack;		 
    short bytesSec;		 
    short sectors;		 
    short bytesGap;		 
    short bytesSync;		 
    short vendstat;		 
    char  serial[20];		 
    short type;			 
    short size;			 
    short bytesEcc;		 
    char  rev[8];		 
    char  model[40];		 
    short multiSecs;		 
    short reserved48;		 
    short capabilities;		 
    short reserved50;		 
    short pioMode;		 
    short dmaMode;		 
    short valid;		 
    short currentCylinders;	 
    short currentHeads;		 
    short currentSectors;	 
    short capacity0;		 
    short capacity1;		 
    short multiSet;		 
    short sectors0;		 
    short sectors1;		 
    short singleDma;		 
    short multiDma;		 
    short advancedPio;		 
    short cycletimeDma;		 
    short cycletimeMulti;	 
    short cycletimePioNoIordy;	 
    short cycletimePioIordy;	 
    short reserved69;		 
    short reserved70;		 

     

    short pktCmdRelTime;	 
    short servCmdRelTime;	 
    short majorRevNum;		 
    short minorVersNum;		 
    short reserved75[53];	 
    short vendor[32];		 
    short reserved160[96];	 
    } ATA_PARAM;

typedef enum  
    {
    NON_DATA,  
    OUT_DATA,
    IN_DATA
    } t_data_dir;

 









 















typedef struct ataDev
    {
    BLK_DEV     blkDev;		 
    int         ctrl;		 
    int         drive;		 
    int         blkOffset;	 
    int		nBlocks;	 

    char *	pBuf;		 
    char *	pBufEnd;	 
    t_data_dir	direction;	 
    int		transCount;	 
    int		errNum;		 

     

    uint8_t	intReason;	 
    uint8_t	status;		 
    uint16_t	transSize;	 
    } ATA_DEV;

typedef struct ataDrive
    {
    ATA_PARAM	param;		 
    short	okMulti;	 
    short	okIordy;	 
    short	okDma;		 
    short	okLba;		 
    short	multiSecs;	 
    short	pioMode;	 
    short	singleDmaMode;	 
    short	multiDmaMode;	 
    short	rwMode;		 
    short	rwBits;		 
    short	rwPio;		 
    short	rwDma;		 

    uint8_t	state;		 
    uint8_t	diagCode;	 
    uint8_t	type;		 
    STATUS      (*Reset)	 
        (
        int ctrl,
        int dev
        );

    ATA_DEV     *pAtaDev;	 
    } ATA_DRIVE;

typedef struct ataCtrl
    {
    ATA_DRIVE	drive[2];	 
    SEMAPHORE	syncSem;	 
    SEMAPHORE	muteSem;	 
    WDOG_ID	wdgId;		 
    BOOL	wdgOkay;	 
    int		semTimeout;	 
    int		wdgTimeout;	 
    int		ctrlType;	 
    BOOL	installed;	 
    BOOL	changed;	 
    int		intLevel;	 
    int		intCount;	 
    int		intStatus;	 
    int		drives;		 
    UINT32	data;		 
    UINT32	error;		 
    UINT32	feature;	 
    UINT32	seccnt;		 
    UINT32	sector;		 
    UINT32	cylLo;		 
    UINT32	cylHi;		 
    UINT32	sdh;		 
    UINT32	command;	 
    UINT32	status;		 
    UINT32	aStatus;	 
    UINT32	dControl;	 
    UINT32	dAddress;	 

    int		configType;	 
    } ATA_CTRL;

typedef struct ataType
    {
    int cylinders;		 
    int heads;			 
    int sectors;		 
    int bytes;			 
    int precomp;		 
    } ATA_TYPE;

typedef struct ataRaw
    {				 
    UINT cylinder;		 
    UINT head;			 
    UINT sector;		 
    char *pBuf;			 
    UINT nSecs;			 
    UINT direction;		 
    } ATA_RAW;






 
















 



 





 


					 










 




 














 






 







 



















 
















 

































 

 

















 







 



 
 



 
 



 



 












 

















 




 





 




 















 





 

 



extern STATUS	ataDrv		(int ctrl, int drives, int vector, int level,
				 int configType, int semTimeout,
				 int wdgTimeout);
extern BLK_DEV	*ataDevCreate	(int ctrl, int drive, int nBlks, int offset);
extern STATUS	ataRawio	(int ctrl, int drive, ATA_RAW *pAtaRaw);
extern void	ataShowInit	(void);
extern STATUS	ataShow		(int ctrl, int drive);
extern int	usrAtaPartition	(int ctrl, int drive, DOS_PART_TBL *pPart);
extern STATUS   usrAtaConfig	(int ctrl, int drive, char *fileName);
extern void     usrAtaInit	(void);


# 534 "d:/Tornado2.2/target/h/drv/hdisk/ataDrv.h"










# 82 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/arch/i86/mmuI86Lib.h" 1
 

 

 
# 15 "d:/Tornado2.2/target/h/arch/i86/mmuI86Lib.h"

























typedef struct
    {
    unsigned present:1;
    unsigned rw:1;
    unsigned us:1;
    unsigned pwt:1;
    unsigned pcd:1;
    unsigned access:1;
    unsigned dirty:1;
    unsigned zero:2;
    unsigned avail:3;
    unsigned page:20;
    } PTE_FIELD;

typedef union pte
    {
    PTE_FIELD field;
    unsigned int bits;
    } PTE;

typedef struct mmuTransTblStruct
    {
    PTE *pDirectoryTable;
    } MMU_TRANS_TBL;
















 



extern STATUS	mmuI86LibInit (int pageSize);
extern STATUS	mmuI86Enable (BOOL enable);
extern void	mmuI86On ();
extern void	mmuI86Off ();
extern void	mmuI86TLBFlush ();
extern void	mmuI86PdbrSet (MMU_TRANS_TBL * transTbl);
extern MMU_TRANS_TBL *	mmuI86PdbrGet ();

extern void	vmBaseArch32LibInit (void);
extern void	vmBaseArch36LibInit (void);
extern STATUS	vmBaseArch32Map (void * virtAddr, void * physAddr,
		    UINT32 stateMask, UINT32 state, UINT32 len);
extern STATUS	vmBaseArch32Translate (void * virtAddr, void ** physAddr);
extern void	vmArch32LibInit (void);
extern void	vmArch36LibInit (void);
extern STATUS	vmArch32Map ();
extern STATUS	vmArch32Translate ();


# 122 "d:/Tornado2.2/target/h/arch/i86/mmuI86Lib.h"









# 83 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/arch/i86/ipiI86Lib.h" 1
 

 

 















 







 

extern char	ipiCallTbl [];		 


 



extern void	ipiVecInit (UINT32 intNum);
extern void	ipiHandler (UINT32 index);
extern STATUS	ipiConnect (UINT32 intNum, VOIDFUNCPTR routine);
extern STATUS	ipiStartup (UINT32 apicId, UINT32 vector, UINT32 nTimes);
extern STATUS	ipiShutdown (UINT32 apicId, UINT32 vector);
extern void	ipiStub (void);
extern void	ipiShutdownSup (void);
extern void	ipiHandlerTlbFlush (void);
extern void	ipiHandlerTscReset (void);
extern void	ipiHandlerShutdown (void);


# 63 "d:/Tornado2.2/target/h/arch/i86/ipiI86Lib.h"










# 84 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/intrCtl/loApic.h" 1
 

  

 















 


























 





 



 








 
















 




 












 








 









 







 



 










 

typedef struct			 
    {
    char    signature [4];	 
    UINT32  configTableAddr;	 
    UINT8   length;		 
    UINT8   specRev;		 
    UINT8   cksum;		 
    UINT8   featureByte[5];	 
    } MP_FPS;

typedef struct			 
    {
    char    mpSignature[4];	 
    UINT16  tableLength;	 
    UINT8   specRevision;	 
    UINT8   cksum;		 
    char    oemId[8];		 
    char    prodId[12];		 
    UINT32  oemTablePtr;	 
    UINT16  oemTableSize;	 
    UINT16  entryCount;		 
    UINT32  localApicBaseAddr;	 
    UINT16  extendedTableLength;  
    UINT8   extendedTableCksum;  
    UINT8   reserved;            
    } MP_HEADER; 

typedef struct			 
    {
    UINT8   entryType;		 
    UINT8   localApicId;	 
    UINT8   localApicVersion;	 
    UINT8   cpuFlags;		 
    UINT32  cpuSig;		 
    UINT32  featureFlags;	 
    UINT32  reserved[2];
    } MP_CPU;

typedef struct			 
    {
    UINT8  entryType;		 
    UINT8  ioApicId;		 
    UINT8  ioApicVersion;	 
    UINT8  ioApicFlags;		 
    UINT32 ioApicBaseAddress;	 
    } MP_IOAPIC;

 

extern UINT32	loApicBase;		 
extern UINT32	ioApicBase;		 
extern UINT32	ioApicData;		 
extern UINT32	loApicId;		 
extern UINT32	loApicVersion;		 
extern UINT32	loApicMaxLvt;		 




extern void	loApicInit	(void);
extern void	loApicEnable	(BOOL enable);
extern STATUS	loApicIpi	(INT32 apicId, INT32 shortHand, INT32 trigger, 
				 INT32 level, INT32 destMode, INT32 deliMode, 
				 INT32 vectorNo);



















# 85 "pc.h" 2
# 1 "d:/Tornado2.2/target/h/drv/intrCtl/ioApic.h" 1
 

  

 
# 14 "d:/Tornado2.2/target/h/drv/intrCtl/ioApic.h"









 





 







 




 





 



 



 





















 

extern UINT32	ioApicVersion;
extern UINT32	ioApicRedEntries;




extern STATUS   ioApicInit       (void);
extern VOID     ioApicEnable     (BOOL enable);
extern STATUS	ioApicIrqSet	 (INT32 irq, INT32 apicId);
extern STATUS   ioApicRedGet     (INT32 irq, INT32 * pUpper32, INT32 * pLower32);
extern STATUS   ioApicRedSet     (INT32 irq, INT32 upper32, INT32 lower32);
extern INT32    ioApicGet        (UINT32 index, UINT32 data, INT32 offset);
extern void     ioApicSet        (UINT32 index, UINT32 data, INT32 offset, INT32 value);


# 105 "d:/Tornado2.2/target/h/drv/intrCtl/ioApic.h"











# 86 "pc.h" 2











 





 























 

 
# 140 "pc.h"












 






 





 





 


































 










 



 








 



 















 







 



















 



 






# 299 "pc.h"











 


















 



 




















 





















# 167 "config.h" 2


 


    extern void sysHwInit0 (void);
    extern UINT8 sysInumTbl[];		 


 





 












# 204 "config.h"

 













 

 







 








 








 




 









 





 








 



















 


# 311 "config.h"


 











 




















 











 


# 375 "config.h"














# 459 "config.h"


















				 
				 








				 
				 














 






 







 







 







 







 






 

























 


























 











 




 










 
















 










 



















 
# 696 "config.h"




 




 





 

# 1 "configInum.h" 1
 

 

 






 












 


# 41 "configInum.h"


 









# 134 "configInum.h"









































 
































# 714 "config.h" 2





 













# 762 "config.h"












# 230 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/logLib.h" 1
 

 

 
# 23 "d:/Tornado2.2/target/h/logLib.h"








 




extern STATUS 	logFdAdd (int fd);
extern STATUS 	logFdDelete (int fd);
extern STATUS 	logInit (int fd, int maxMsgs);




extern int	logMsg (char *fmt, int arg1, int arg2,
			int arg3, int arg4, int arg5, int arg6);


extern void 	logFdSet (int fd);
extern void 	logShow (void);
extern void 	logTask (void);


# 62 "d:/Tornado2.2/target/h/logLib.h"








# 231 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/taskLib.h" 1
 

 

 
# 126 "d:/Tornado2.2/target/h/taskLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 136 "d:/Tornado2.2/target/h/taskLib.h" 2



# 1 "d:/Tornado2.2/target/h/excLib.h" 1
 

 

 
# 51 "d:/Tornado2.2/target/h/excLib.h"

















































# 1 "d:/Tornado2.2/target/h/arch/i86/excI86Lib.h" 1
 

 

 
# 14 "d:/Tornado2.2/target/h/arch/i86/excI86Lib.h"








 







typedef struct
    {
    UINT16 valid;	 
    UINT16 vecNum;	 
    ULONG errCode;	 
    INSTR * pc;		 
    ULONG eflags;	 
    UINT16 cs;		 
    UINT16 pad;		 
    ULONG esp;		 
    ULONG ss;		 
    ULONG esp0;		 
    ULONG cr2;		 
    ULONG cr3;		 
    ULONG esp00;	 
    ULONG esp01;	 
    ULONG esp02;	 
    ULONG esp03;	 
    ULONG esp04;	 
    ULONG esp05;	 
    ULONG esp06;	 
    ULONG esp07;	 
    ULONG reserved0;	 
    ULONG reserved1;	 
    ULONG reserved2;	 
    ULONG reserved3;	 
    } EXC_INFO;

 








 

extern FUNCPTR  excExcepHook;    

 



extern void	excStub (void);
extern void	excIntStub (void);
















# 101 "d:/Tornado2.2/target/h/excLib.h" 2

















typedef struct  excfaultTab
    {
    int faultType;		 
    int subtype;		 
    int signal;			 
    int code;			 
    } EXC_FAULT_TAB;

 


extern STATUS 	excShowInit (void);
extern void 	excHookAdd (FUNCPTR excepHook);
extern STATUS 	excJobAdd (VOIDFUNCPTR func, int arg1, int arg2, int arg3,
			   int arg4, int arg5, int arg6);















# 140 "d:/Tornado2.2/target/h/taskLib.h" 2
# 1 "d:/Tornado2.2/target/h/private/eventP.h" 1
 

 

 
# 80 "d:/Tornado2.2/target/h/private/eventP.h"








 

 







 





































 



typedef unsigned short event_t;



# 1 "d:/Tornado2.2/target/h/private/funcBindP.h" 1
 

 

 
# 47 "d:/Tornado2.2/target/h/private/funcBindP.h"











 

extern FUNCPTR     _func_ioTaskStdSet;
extern FUNCPTR     _func_bdall;
extern FUNCPTR     _func_dspTaskRegsShow;
extern VOIDFUNCPTR _func_dspRegsListHook;	 
extern FUNCPTR	   _func_dspMregsHook;		 
extern FUNCPTR     _func_excBaseHook;
extern FUNCPTR     _func_excInfoShow;
extern FUNCPTR     _func_excIntHook;
extern FUNCPTR     _func_excJobAdd;
extern FUNCPTR     _func_excPanicHook;
extern FUNCPTR     _func_fclose;
extern FUNCPTR     _func_fppTaskRegsShow;
extern FUNCPTR     _func_altivecTaskRegsShow;
extern FUNCPTR     _func_ftpLs;
extern FUNCPTR     _func_netLsByName;
extern FUNCPTR     _func_printErr;
extern FUNCPTR     _func_logMsg;
extern FUNCPTR     _func_memalign;
extern FUNCPTR     _func_pthread_setcanceltype;
extern FUNCPTR     _func_selPtyAdd;
extern FUNCPTR     _func_selPtyDelete;
extern FUNCPTR     _func_selTyAdd;
extern FUNCPTR     _func_selTyDelete;
extern FUNCPTR     _func_selWakeupAll;
extern FUNCPTR     _func_selWakeupListInit;
extern FUNCPTR     _func_selWakeupListTerm;
extern VOIDFUNCPTR _func_sigExcKill;
extern FUNCPTR     _func_sigprocmask;
extern FUNCPTR     _func_sigTimeoutRecalc;
extern FUNCPTR     _func_smObjObjShow;
extern FUNCPTR     _func_spy;
extern FUNCPTR     _func_spyStop;
extern FUNCPTR     _func_spyClkStart;
extern FUNCPTR     _func_spyClkStop;
extern FUNCPTR     _func_spyReport;
extern FUNCPTR     _func_spyTask;
extern FUNCPTR     _func_sseTaskRegsShow;
extern FUNCPTR     _func_symFindByValueAndType;    
extern FUNCPTR     _func_symFindByValue;           
extern FUNCPTR     _func_symFindSymbol;
extern FUNCPTR     _func_symNameGet;
extern FUNCPTR     _func_symValueGet;
extern FUNCPTR     _func_symTypeGet;
extern FUNCPTR     _func_taskCreateHookAdd;
extern FUNCPTR     _func_taskDeleteHookAdd;
extern FUNCPTR     _func_valloc;
extern FUNCPTR     _func_remCurIdGet;
extern FUNCPTR     _func_remCurIdSet;

extern FUNCPTR	   _dbgDsmInstRtn;

extern BOOL	   ftpErrorSuppress;
extern BOOL	   _procNumWasSet;

extern VOIDFUNCPTR _func_evtLogO;
extern VOIDFUNCPTR _func_evtLogOIntLock;

extern VOIDFUNCPTR _func_evtLogM0;
extern VOIDFUNCPTR _func_evtLogM1;
extern VOIDFUNCPTR _func_evtLogM2;
extern VOIDFUNCPTR _func_evtLogM3;

extern VOIDFUNCPTR _func_evtLogT0;
extern VOIDFUNCPTR _func_evtLogT0_noInt;
extern VOIDFUNCPTR _func_evtLogT1;
extern VOIDFUNCPTR _func_evtLogT1_noTS;
extern VOIDFUNCPTR _func_evtLogTSched;

extern VOIDFUNCPTR _func_evtLogString;
extern FUNCPTR     _func_evtLogPoint;
extern FUNCPTR	   _func_evtLogReserveTaskName;


# 141 "d:/Tornado2.2/target/h/private/funcBindP.h"

extern FUNCPTR     _func_tmrStamp;
extern FUNCPTR     _func_tmrStampLock;
extern FUNCPTR     _func_tmrFreq;
extern FUNCPTR     _func_tmrPeriod;
extern FUNCPTR     _func_tmrConnect;
extern FUNCPTR     _func_tmrEnable;
extern FUNCPTR     _func_tmrDisable;

extern VOIDFUNCPTR _func_trgCheck;
extern UINT32 evtAction;
extern UINT32 wvEvtClass;
extern UINT32 trgEvtClass;

extern BOOL   wvInstIsOn;              
extern BOOL   wvObjIsEnabled;          







# 145 "d:/Tornado2.2/target/h/private/eventP.h" 2

















































 












# 215 "d:/Tornado2.2/target/h/private/eventP.h"

 

 










 












 
















 

















 


















 
# 307 "d:/Tornado2.2/target/h/private/eventP.h"


# 326 "d:/Tornado2.2/target/h/private/eventP.h"

 
# 338 "d:/Tornado2.2/target/h/private/eventP.h"


# 357 "d:/Tornado2.2/target/h/private/eventP.h"

 
# 367 "d:/Tornado2.2/target/h/private/eventP.h"


# 381 "d:/Tornado2.2/target/h/private/eventP.h"

 

















 
















 








# 436 "d:/Tornado2.2/target/h/private/eventP.h"


 
















 
















 








# 493 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 515 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 536 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 559 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 580 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 601 "d:/Tornado2.2/target/h/private/eventP.h"

 
















 








# 636 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 655 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 675 "d:/Tornado2.2/target/h/private/eventP.h"

 








# 693 "d:/Tornado2.2/target/h/private/eventP.h"


















 














































 

 


     





     





     




 


     
# 792 "d:/Tornado2.2/target/h/private/eventP.h"



     





     





     
# 816 "d:/Tornado2.2/target/h/private/eventP.h"


     
# 827 "d:/Tornado2.2/target/h/private/eventP.h"



     






     





      





     

 


     
# 863 "d:/Tornado2.2/target/h/private/eventP.h"


     







     






     








     






     







     







     







     








     








     









     









     








     








     








     








     






     






     







     






     









     






     









     
# 1059 "d:/Tornado2.2/target/h/private/eventP.h"


     







     






     






     







     





     







     








     







     






     








     






     





     





 


     






     





     





     





     








     







     





     




     





     





     





     





     





     





     





     




     





     





     





     





     





     





     





     





     





     





     





     





     





     





     




     




 


     







     






     







     







     




     





     





     





     





     






     






 




     





     




     























 








# 1494 "d:/Tornado2.2/target/h/private/eventP.h"











 
# 1522 "d:/Tornado2.2/target/h/private/eventP.h"














# 141 "d:/Tornado2.2/target/h/taskLib.h" 2



# 1 "d:/Tornado2.2/target/h/stdlib.h" 1
 

 

 
# 37 "d:/Tornado2.2/target/h/stdlib.h"


















# 65 "d:/Tornado2.2/target/h/stdlib.h"

 















typedef struct { int quot; int rem; } div_t;




typedef struct { long quot; long rem; } ldiv_t;



typedef struct {		 
	unsigned char __state;
	unsigned short __wchar;
	} _Mbsave;



extern void	abort (void);
extern int	abs (int __i);
extern int	atexit (void (*__func)(void));
extern double	atof (const char *__s);
extern int	atoi (const char *__s);
extern long	atol (const char *__s);
extern void *	bsearch (const void *__key, const void *__base,
		         size_t __nelem, size_t __size,
		         int  (*__cmp)(const void *__ck, const void *__ce));
extern div_t	div (int __numer, int __denom);
extern long	labs (long __i);
extern ldiv_t	ldiv (long __numer, long __denom);
extern int	mblen (const char *__s, size_t __n);
extern size_t	mbstowcs (wchar_t *__wcs, const char *__s, size_t __n);
extern int	mbtowc (wchar_t *__pwc, const char *__s, size_t __n);
extern void	qsort (void *__base, size_t __nelem, size_t __size,
		       int  (*__cmp)(const void *__e1, const void *__e2));
extern int	rand (void);
extern void *	srand (unsigned int __seed);
extern double	strtod (const char *__s, char **__endptr);
extern long	strtol (const char *__s, char **__endptr, int __base);
extern unsigned long strtoul (const char *__s, char **__endptr, int __base);
extern int	system (const char *__s);
extern size_t	wcstombs (char *__s, const wchar_t *__wcs, size_t __n);
extern int	wctomb (char *__s, wchar_t __wchar);

extern void *	calloc (size_t __nelem, size_t __size);
extern void	exit (int __status);
extern void	free (void *__ptr);
extern char *	getenv (const char *__name);
extern void *	malloc (size_t __size);
extern void *	realloc (void *__ptr, size_t __size);



extern void     div_r (int numer, int denom, div_t * divStructPtr);
extern void     ldiv_r (long numer, long denom, ldiv_t * divStructPtr);




# 178 "d:/Tornado2.2/target/h/stdlib.h"









# 145 "d:/Tornado2.2/target/h/taskLib.h" 2


 












 







 













 







typedef struct wdb_info		 
    {
    int			wdbState;	 
    REG_SET *		wdbRegisters;	 
    struct
        {
	void *	wdb1;
	void *	wdb2;
	} wdbEvtList;			 
    int			bpAddr;		 
					 
    int			taskBpAddr;	 
    int			taskPc;		 
    int			taskFp;		 
    int			taskSp;		 
    VOIDFUNCPTR		wdbExitHook;	 
  } WDB_INFO;

typedef struct windTcb		 
    {
    Q_NODE		qNode;		 
    Q_NODE		tickNode;	 
    Q_NODE		activeNode;	 

    OBJ_CORE		objCore;	 
    char *		name;		 
    int			options;	 
    UINT		status;		 
    UINT		priority;	 
    UINT		priNormal;	 
    UINT		priMutexCnt;	 
    struct semaphore *	pPriMutex;	 

    UINT		lockCnt;	 
    UINT		tslice;		 

    UINT16		swapInMask;	 
    UINT16		swapOutMask;	 

    Q_HEAD *		pPendQ;		 

    UINT		safeCnt;	 
    Q_HEAD		safetyQHead;	 

    FUNCPTR		entry;		 

    char *		pStackBase;	 
    char *		pStackLimit;	 
    char *		pStackEnd;	 

    int			errorStatus;	 
    int			exitCode;	 

    struct sigtcb *	pSignalInfo;	 
    struct selContext *	pSelectContext;	 

    UINT		taskTicks;	 
    UINT		taskIncTicks;	 

    struct taskVar *	pTaskVar;	 
    struct rpcModList *	pRPCModList;	 
    struct fpContext *	pFpContext;	 

    struct __sFILE *	taskStdFp[3];	 
    int			taskStd[3];	 

    char **		ppEnviron;	 
    int                 envTblSize;      
    int                 nEnvVarEntries;  
    struct sm_obj_tcb *	pSmObjTcb;	 
    int			windxLock;	 
    void *		pComLocal;	 
    REG_SET *		pExcRegSet;	 
    EVENTS		events;		 
    WDB_INFO *		pWdbInfo;	 
    void *		pPthread;	 
    int			reserved1;	 
    int			reserved2;	 
    int			spare1;		 
    int			spare2;		 
    int			spare3;		 
    int			spare4;		 

     


# 284 "d:/Tornado2.2/target/h/taskLib.h"









































# 336 "d:/Tornado2.2/target/h/taskLib.h"










# 357 "d:/Tornado2.2/target/h/taskLib.h"


    EXC_INFO            excInfo;         

     

    REG_SET             regs;            











# 384 "d:/Tornado2.2/target/h/taskLib.h"

    struct dspContext *	pDspContext;	 
    WDB_INFO		wdbInfo;	 
    } WIND_TCB;

typedef struct 			 
    {
    int			td_id;		 
    char *		td_name;	 
    int			td_priority;	 
    int			td_status;	 
    int			td_options;	 
    FUNCPTR		td_entry;	 
    char *		td_sp;		 
    char *		td_pStackBase;	 
    char *		td_pStackLimit;	 
    char *		td_pStackEnd;	 
    int			td_stackSize;	 
    int			td_stackCurrent; 
    int			td_stackHigh;	 
    int			td_stackMargin;	 
    int			td_errorStatus;	 
    int			td_delay;	 
    EVENTS		td_events;	 
    } TASK_DESC;





 
# 426 "d:/Tornado2.2/target/h/taskLib.h"







 
# 442 "d:/Tornado2.2/target/h/taskLib.h"










 













 
# 475 "d:/Tornado2.2/target/h/taskLib.h"


# 486 "d:/Tornado2.2/target/h/taskLib.h"

 














 

extern CLASS_ID	taskClassId;		 
extern CLASS_ID taskInstClassId;  	 
extern WIND_TCB *taskIdCurrent;		 
extern BOOL     taskPriRangeCheck;       

 



extern STATUS 	taskLibInit (void);





extern int 	taskSpawn (char *name, int priority, int options, int stackSize,
		      	   FUNCPTR entryPt, int arg1, int arg2, int arg3,
		      	   int arg4, int arg5, int arg6, int arg7,
		      	   int arg8, int arg9, int arg10);


extern STATUS 	taskInit (WIND_TCB *pTcb, char *name, int priority, int options,
			  char *pStackBase, int stackSize, FUNCPTR entryPt,
			  int arg1, int arg2, int arg3, int arg4, int arg5,
			  int arg6, int arg7, int arg8, int arg9, int arg10);
extern STATUS 	taskActivate (int tid);
extern STATUS 	taskDelete (int tid);
extern STATUS 	taskDeleteForce (int tid);
extern STATUS 	taskSuspend (int tid);
extern STATUS 	taskResume (int tid);
extern STATUS 	taskRestart (int tid);
extern STATUS 	taskPrioritySet (int tid, int newPriority);
extern STATUS 	taskPriorityGet (int tid, int *pPriority);
extern STATUS 	taskLock (void);
extern STATUS 	taskUnlock (void);
extern STATUS 	taskSafe (void);
extern STATUS 	taskUnsafe (void);
extern STATUS 	taskDelay (int ticks);
extern STATUS 	taskOptionsSet (int tid, int mask, int newOptions);
extern STATUS 	taskOptionsGet (int tid, int *pOptions);
extern char *	taskName (int tid);
extern int 	taskNameToId (char *name);
extern STATUS 	taskIdVerify (int tid);
extern int 	taskIdSelf (void);
extern int 	taskIdDefault (int tid);
extern BOOL 	taskIsReady (int tid);
extern BOOL 	taskIsSuspended (int tid);
extern WIND_TCB *taskTcb (int tid);
extern int 	taskIdListGet (int idList [ ], int maxTasks);
extern STATUS 	taskInfoGet (int tid, TASK_DESC *pTaskDesc);
extern STATUS 	taskStatusString (int tid, char *pString);
extern STATUS 	taskOptionsString (int tid, char *pString);
extern STATUS 	taskRegsGet (int tid, REG_SET *pRegs);
extern STATUS 	taskRegsSet (int tid, REG_SET *pRegs);
extern void 	taskRegsShow (int tid);
extern void *	taskStackAllot (int tid, unsigned nBytes);
extern void 	taskShowInit (void);
extern STATUS 	taskShow (int tid, int level);


# 602 "d:/Tornado2.2/target/h/taskLib.h"









# 232 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/vxLib.h" 1
 

 

 
# 31 "d:/Tornado2.2/target/h/vxLib.h"


























# 1 "d:/Tornado2.2/target/h/arch/i86/vxI86Lib.h" 1
 

 

 
# 14 "d:/Tornado2.2/target/h/arch/i86/vxI86Lib.h"









 



 





extern void	vxMemProbeTrap		(void);
extern STATUS	vxMemProbeSup		(int length, char * adrs, char * pVal);
extern void	vxCpuShow		(void);
extern int	vxCr0Get		(void);
extern void	vxCr0Set		(int cr0);
extern int	vxCr2Get		(void);
extern void	vxCr2Set		(int cr2);
extern int	vxCr3Get		(void);
extern void	vxCr3Set		(int cr3);
extern int	vxCr4Get		(void);
extern void	vxCr4Set		(int cr4);
extern int	vxEflagsGet		(void);
extern void	vxEflagsSet		(int eflags);
extern void	vxDrGet			(int * pDr0, int * pDr1, int * pDr2, 
					 int * pDr3, int * pDr4, int * pDr5, 
					 int * pDr6, int * pDr7);
extern void	vxDrSet			(int dr0, int dr1, int dr2, int dr3, 
					 int dr4, int dr5, int dr6, int dr7);
extern void	vxDrShow		(void);
extern void	vxSseShow		(int);
extern int	vxTssGet		(void);
extern void	vxTssSet		(int value);
extern void	vxGdtrGet		(long long int * pGdtr);
extern void	vxIdtrGet		(long long int * pIdtr);
extern void	vxLdtrGet		(long long int * pLdtr);

extern STATUS	vxPowerModeSet		(UINT32 mode);
extern UINT32	vxPowerModeGet		(void);

extern void	vxShowInit		(void);


# 95 "d:/Tornado2.2/target/h/arch/i86/vxI86Lib.h"










# 58 "d:/Tornado2.2/target/h/vxLib.h" 2


 



extern STATUS 	vxMemProbe (char * adrs, int mode, int length, char * pVal);
extern BOOL 	vxTas (void * address);
extern STATUS 	vxMemArchProbe (void * adrs, int mode, int length, void * pVal);
extern STATUS 	(* _func_vxMemProbeHook)(void *, int, int, void *);

 
extern u_short	checksum (u_short * pAddr, int len);







# 88 "d:/Tornado2.2/target/h/vxLib.h"







# 233 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/errnoLib.h" 1
 

 

 
# 25 "d:/Tornado2.2/target/h/errnoLib.h"











 





extern STATUS   errnoOfTaskSet (int taskId, int errorValue);
extern STATUS   errnoSet (int errorValue);
extern int      errnoGet (void);
extern int      errnoOfTaskGet (int taskId);
















# 234 "sysLib.c" 2

# 1 "d:/Tornado2.2/target/h/stdio.h" 1
 

 
 

 
# 49 "d:/Tornado2.2/target/h/stdio.h"















# 1 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stdarg.h" 1 3
 
# 19 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stdarg.h" 3

 






 











 



typedef __builtin_va_list __gnuc_va_list;


 



 












 
 














# 96 "d:/Tornado2.2/host/x86-win32/lib/gcc-lib/i586-wrs-vxworks/2.9-PentiumIII-010221/include/stdarg.h" 3

 




 

 

 

typedef __gnuc_va_list va_list;

























# 65 "d:/Tornado2.2/target/h/stdio.h" 2



# 78 "d:/Tornado2.2/target/h/stdio.h"

 

struct __sbuf 			 
    {
    uchar_t * _base;		 
    int	      _size;		 
    };

typedef	struct __sFILE
    {
    OBJ_CORE		objCore;	 
    uchar_t *		_p;		 
    int			_r;		 
    int			_w;		 
    short		_flags;		 
    short		_file;		 
    struct __sbuf	_bf;		 
    int			_lbfsize;	 
    struct __sbuf	_ub;		 
    uchar_t *		_up;		 
    int			_ur;		 
    uchar_t		_ubuf[3];	 
    uchar_t		_nbuf[1];	 
    struct __sbuf	_lb;		 
    int			_blksize;	 
    int			_offset;	 
    int			taskId;		 
    } FILE;

 

extern CLASS_ID fpClassId;		 

 

























































extern void	clearerr (FILE *);
extern int	fclose (FILE *);
extern int	feof (FILE *);
extern int	ferror (FILE *);
extern int	fflush (FILE *);
extern int	fgetc (FILE *);
extern int	fgetpos (FILE *, fpos_t *);
extern char *	fgets (char *, size_t, FILE *);
extern FILE *	fopen (const char *, const char *);
extern int	fprintf (FILE *, const char *, ...);
extern int	fputc (int, FILE *);
extern int	fputs (const char *, FILE *);
extern int	fread (void *, size_t, size_t, FILE *);
extern FILE *	freopen (const char *, const char *, FILE *);
extern int	fscanf (FILE *, const char *, ...);
extern int	fseek (FILE *, long, int);
extern int	fsetpos (FILE *, const fpos_t *);
extern long	ftell (FILE *);
extern int	fwrite (const void *, size_t, size_t, FILE *);
extern int	getc (FILE *);
extern int	getchar (void);
extern char *	gets (char *);
extern void	perror (const char *);
extern int	printf (const char *, ...);
extern int	putc (int, FILE *);
extern int	putchar (int);
extern int	puts (const char *);
extern int	remove (const char *);
extern int	rename  (const char *, const char *);
extern void	rewind (FILE *);
extern int	scanf (const char *, ...);
extern void	setbuf (FILE *, char *);
extern int	setvbuf (FILE *, char *, int, size_t);
extern int	sprintf (char *, const char *, ...);
extern int	sscanf (const char *, const char *, ...);
extern FILE *	tmpfile (void);
extern char *	tmpnam (char *);
extern int	ungetc (int, FILE *);
extern int	vfprintf (FILE *, const char *, va_list);
extern int	vprintf (const char *, va_list);
extern int	vsprintf (char *, const char *, va_list);
extern int	__srget (FILE *);		 
extern int	__swbuf (int, FILE *);		 

 

extern FILE *	fdopen (int, const char *);
extern int	fileno (FILE *);

 

 



extern int	fdprintf (int fd, const char *fmt, ...);
extern int	vfdprintf (int fd, const char *fmt, va_list ap);
extern int	printErr (const char *fmt, ...);
extern int	getw (FILE *);
extern int	putw (int, FILE *);
extern void	setbuffer (FILE *, char *, int);
extern int	setlinebuf (FILE *);
extern FILE *   stdioFp (int std);
extern STATUS   stdioShow (FILE * fp, int level);
extern STATUS   stdioShowInit (void);
extern STATUS   stdioInit (void);




# 311 "d:/Tornado2.2/target/h/stdio.h"


 


extern FILE **	__stdin(void);		 
extern FILE **	__stdout(void);		 
extern FILE **	__stderr(void);		 











 











































# 236 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/cacheLib.h" 1
 

 

 
# 49 "d:/Tornado2.2/target/h/cacheLib.h"









# 1 "d:/Tornado2.2/target/h/vwModNum.h" 1
 

 

 
# 94 "d:/Tornado2.2/target/h/vwModNum.h"


# 253 "d:/Tornado2.2/target/h/vwModNum.h"

# 59 "d:/Tornado2.2/target/h/cacheLib.h" 2


 









 












 



 






typedef enum				 
    {







    INSTRUCTION_CACHE = 0,
    DATA_CACHE        = 1
    } CACHE_TYPE;

typedef	UINT	CACHE_MODE;		 

typedef	struct				 
    {
    FUNCPTR	enableRtn;		 
    FUNCPTR	disableRtn;		 
    FUNCPTR	lockRtn;		 
    FUNCPTR	unlockRtn;		 
    FUNCPTR	flushRtn;		 
    FUNCPTR	invalidateRtn;		 
    FUNCPTR	clearRtn;		 

    FUNCPTR	textUpdateRtn;		 
    FUNCPTR	pipeFlushRtn;		 
    FUNCPTR	dmaMallocRtn;		 
    FUNCPTR	dmaFreeRtn;		 
    FUNCPTR	dmaVirtToPhysRtn;	 
    FUNCPTR	dmaPhysToVirtRtn;	 
    } CACHE_LIB;

 

typedef	struct				 
    {
    FUNCPTR	flushRtn;		 
    FUNCPTR	invalidateRtn;		 
    FUNCPTR	virtToPhysRtn;		 
    FUNCPTR	physToVirtRtn;		 
    } CACHE_FUNCS;


 


































































 

extern CACHE_LIB	cacheLib;
extern CACHE_FUNCS	cacheNullFuncs;	 
extern CACHE_FUNCS	cacheDmaFuncs;	 
extern CACHE_FUNCS	cacheUserFuncs;	 

extern FUNCPTR		cacheDmaMallocRtn;
extern FUNCPTR		cacheDmaFreeRtn;
extern CACHE_MODE	cacheDataMode;	 
extern BOOL		cacheDataEnabled;
extern BOOL		cacheMmuAvailable;

 



extern STATUS	cacheLibInit (CACHE_MODE inst, CACHE_MODE data);

extern STATUS	cacheArchLibInit (CACHE_MODE inst, CACHE_MODE data);

extern STATUS	cacheEnable (CACHE_TYPE cache);
extern STATUS	cacheDisable (CACHE_TYPE cache);
extern STATUS	cacheLock (CACHE_TYPE cache, void * adrs, size_t bytes);
extern STATUS	cacheUnlock (CACHE_TYPE cache, void * adrs, size_t bytes);
extern STATUS	cacheFlush (CACHE_TYPE cache, void * adrs, size_t bytes);
extern STATUS	cacheInvalidate (CACHE_TYPE cache, void *adrs, size_t bytes);
extern STATUS	cacheClear (CACHE_TYPE cache, void * adrs, size_t bytes);
extern STATUS	cacheTextUpdate (void * adrs, size_t bytes);
extern STATUS	cachePipeFlush (void);

extern void *	cacheDmaMalloc (size_t bytes);
extern STATUS	cacheDmaFree (void * pBuf);

extern STATUS	cacheDrvFlush (CACHE_FUNCS * pFuncs, void * adrs, size_t bytes);
extern STATUS	cacheDrvInvalidate (CACHE_FUNCS * pFuncs, void * adrs,
				    size_t bytes);
extern void *   cacheDrvVirtToPhys (CACHE_FUNCS * pFuncs, void * adrs);
extern void *   cacheDrvPhysToVirt (CACHE_FUNCS * pFuncs, void * adrs);

extern void	cacheFuncsSet (void);


# 272 "d:/Tornado2.2/target/h/cacheLib.h"



 


























# 1 "d:/Tornado2.2/target/h/arch/i86/cacheI86Lib.h" 1
 

 
 
# 14 "d:/Tornado2.2/target/h/arch/i86/cacheI86Lib.h"



















extern STATUS cacheArchEnable (CACHE_TYPE cache);
extern STATUS cacheArchDisable (CACHE_TYPE cache);
extern STATUS cacheArchLock (CACHE_TYPE cache, void * address, size_t bytes);
extern STATUS cacheArchUnlock (CACHE_TYPE cache,
				void * address, size_t bytes);
extern STATUS cacheArchClear (CACHE_TYPE cache, void * address, size_t bytes);
extern STATUS cacheArchFlush (CACHE_TYPE cache, void * address, size_t bytes);
extern void * cacheArchDmaMalloc (size_t bytes);
extern STATUS cacheArchDmaFree (void * pBuf);
extern STATUS cacheArchTextUpdate (void * address, size_t bytes);
extern STATUS cacheArchClearEntry (CACHE_TYPE cache, void * address);

extern void cacheI86Reset (void);
extern void cacheI86Enable (void);
extern void cacheI86Disable (void);
extern void cacheI86Lock (void);
extern void cacheI86Unlock (void);
extern void cacheI86Clear (void);
extern void cacheI86Flush (void);
extern void cachePen4Clear (CACHE_TYPE cache, void * address, size_t bytes);
extern void cachePen4Flush (CACHE_TYPE cache, void * address, size_t bytes);


# 79 "d:/Tornado2.2/target/h/arch/i86/cacheI86Lib.h"









# 303 "d:/Tornado2.2/target/h/cacheLib.h" 2




















# 237 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/private/vmLibP.h" 1
 

 

 
# 16 "d:/Tornado2.2/target/h/private/vmLibP.h"














# 1 "d:/Tornado2.2/target/h/vmLib.h" 1
 

 

 
# 32 "d:/Tornado2.2/target/h/vmLib.h"















# 1 "d:/Tornado2.2/target/h/mmuLib.h" 1
 

 

 
# 26 "d:/Tornado2.2/target/h/mmuLib.h"












 



 





typedef struct mmuTransTblStruct * MMU_TRANS_TBL_ID;



STATUS mmu30LibInit (int pageSize);
STATUS mmu40LibInit (int pageSize);
STATUS mmu1eLibInit (int pageSize);

STATUS mmuLibInit (int pageSize);

STATUS mmuPro32LibInit (int pageSize);
STATUS mmuPro36LibInit (int pageSize);
STATUS mmuAm29kLibInit (int pageSize);
STATUS mmuPpcLibInit (int mmuType, int * pPhysMemDesc, int elementNb, int *);
STATUS mmuSh7750LibInit (int pageSize);
STATUS mmuSh7700LibInit (int pageSize);


# 81 "d:/Tornado2.2/target/h/mmuLib.h"







# 48 "d:/Tornado2.2/target/h/vmLib.h" 2

 











 



typedef struct phys_mem_desc
    {
    void *virtualAddr;
    void *physicalAddr;
    UINT len;
    UINT initialStateMask;       
    UINT initialState;           
    } PHYS_MEM_DESC;

extern PHYS_MEM_DESC sysPhysMemDesc[];
extern int sysPhysMemDescNumEnt;

typedef struct vm_context
    {
    OBJ_CORE	objCore;	
    MMU_TRANS_TBL_ID mmuTransTbl;   
    SEMAPHORE sem;
    NODE links;
    } VM_CONTEXT;

typedef VM_CONTEXT *VM_CONTEXT_ID;

 









 



 




 











 


 


 


 






 
# 146 "d:/Tornado2.2/target/h/vmLib.h"








 




 





 



 








 



extern STATUS		vmLibInit (int pageSize);
extern VM_CONTEXT_ID 	vmGlobalMapInit (PHYS_MEM_DESC *pMemDescArray, 
			  		 int numDescArrayElements, BOOL enable);
extern VM_CONTEXT *	vmContextCreate ();
extern STATUS 		vmContextDelete (VM_CONTEXT_ID context);
extern STATUS 		vmContextInit (VM_CONTEXT *context);
extern STATUS 		vmStateSet (VM_CONTEXT *context, void *pVirtual,
				    int len, UINT stateMask, UINT state);
extern STATUS 		vmStateGet (VM_CONTEXT *context, void *pageAddr,
				    UINT *state);
extern STATUS 		vmMap (VM_CONTEXT *context, void *virtualAddr,
			       void *physicalAddr, UINT len);
extern STATUS 		vmGlobalMap (void *virtualAddr, void *physicalAddr,
				     UINT len);
extern UINT8 *		vmGlobalInfoGet ();
extern int 		vmPageBlockSizeGet ();
extern STATUS 		vmTranslate (VM_CONTEXT *context, void *virtualAddr, 
		    		     void **physicalAddr);
extern int 		vmPageSizeGet ();
extern VM_CONTEXT *	vmCurrentGet ();
extern STATUS 		vmCurrentSet (VM_CONTEXT *context);
extern STATUS 		vmEnable (BOOL enable);
extern STATUS 		vmTextProtect ();

extern STATUS 		vmBaseLibInit (int pageSize);
extern VM_CONTEXT_ID 	vmBaseGlobalMapInit (PHYS_MEM_DESC *pMemDescArray, 
				      	     int numDescArrayElements,
					     BOOL enable);
extern STATUS    	vmBaseStateSet (VM_CONTEXT *context, void *pVirtual, 
				        int len, UINT stateMask, UINT state);
extern int       	vmBasePageSizeGet (void);

extern STATUS 		vmMpuLibInit (int pageSize);
extern VM_CONTEXT_ID 	vmMpuGlobalMapInit (PHYS_MEM_DESC *pMemDescArray, 
				      	     int numDescArrayElements,
					     BOOL enable);
extern STATUS    	vmMpuStateSet (VM_CONTEXT *context, void *pVirtual, 
				       int len, UINT stateMask, UINT state);
extern int       	vmMpuPageSizeGet (void);

extern void 		vmShowInit (void);
extern STATUS 		vmContextShow (VM_CONTEXT_ID context);


# 258 "d:/Tornado2.2/target/h/vmLib.h"







# 31 "d:/Tornado2.2/target/h/private/vmLibP.h" 2
# 1 "d:/Tornado2.2/target/h/mmuLib.h" 1
 

 

 
# 26 "d:/Tornado2.2/target/h/mmuLib.h"


# 87 "d:/Tornado2.2/target/h/mmuLib.h"

# 32 "d:/Tornado2.2/target/h/private/vmLibP.h" 2

 





typedef struct
    {
    BOOL vmLibInstalled;        
    BOOL vmBaseLibInstalled;    
    BOOL protectTextSegs;       
    FUNCPTR pVmStateSetRtn;     
    FUNCPTR pVmStateGetRtn;     
    FUNCPTR pVmEnableRtn;       
    FUNCPTR pVmPageSizeGetRtn;  
    FUNCPTR pVmTranslateRtn;    
    FUNCPTR pVmTextProtectRtn;  
    } VM_LIB_INFO;































extern VM_LIB_INFO vmLibInfo;

 

typedef struct vm_mem_mgr_class
    {
    OBJ_CLASS coreClass;
    } VM_CONTEXT_CLASS;

typedef VM_CONTEXT_CLASS *VM_CONTEXT_CLASS_ID;

extern VM_CONTEXT_CLASS_ID vmContextClassId;

 



typedef struct
    {
    UINT archIndepMask;
    UINT archDepMask;
    UINT archIndepState;
    UINT archDepState;
    } STATE_TRANS_TUPLE;

 

typedef struct
    {
    FUNCPTR mmuLibInit;
    MMU_TRANS_TBL_ID (*mmuTransTblCreate) ();
    FUNCPTR mmuTransTblDelete;
    FUNCPTR mmuEnable;
    FUNCPTR mmuStateSet;
    FUNCPTR mmuStateGet;
    FUNCPTR mmuPageMap;
    FUNCPTR mmuGlobalPageMap;
    FUNCPTR mmuTranslate;
    VOIDFUNCPTR mmuCurrentSet;
    } MMU_LIB_FUNCS;







# 238 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/h/arch/i86/pentiumLib.h" 1
 

 

 
# 14 "d:/Tornado2.2/target/h/arch/i86/pentiumLib.h"










# 1 "d:/Tornado2.2/target/h/regs.h" 1
 

 

 
# 41 "d:/Tornado2.2/target/h/regs.h"


# 125 "d:/Tornado2.2/target/h/regs.h"

# 25 "d:/Tornado2.2/target/h/arch/i86/pentiumLib.h" 2


 

typedef long long int   LL_INT;
typedef union llUnion
    {
    long long int i64;	 
    int        i32[2];	 
    } LL_UNION;

typedef struct pentiumMsr
    {
    INT32       addr;    
    INT8 *      name;    
    } PENTIUM_MSR;


 



extern int	pentiumCr4Get		(void);
extern void	pentiumCr4Set		(int cr4);
extern STATUS   pentiumPmcStart         (int pmcEvtSel0, int pmcEvtSel1);
extern STATUS   pentiumPmcStart0        (int pmcEvtSel0);
extern STATUS   pentiumPmcStart1        (int pmcEvtSel1);
extern void     pentiumPmcStop          (void);
extern void     pentiumPmcStop0         (void);
extern void     pentiumPmcStop1         (void);
extern void     pentiumPmcGet           (long long int * pPmc0,
                                         long long int * pPmc1);
extern void     pentiumPmcGet0          (long long int * pPmc0);
extern void     pentiumPmcGet1          (long long int * pPmc1);
extern void     pentiumPmcReset         (void);
extern void     pentiumPmcReset0        (void);
extern void     pentiumPmcReset1        (void);
extern STATUS   pentiumP6PmcStart       (int pmcEvtSel0, int pmcEvtSel1);
extern void     pentiumP6PmcStop        (void);
extern void     pentiumP6PmcStop1       (void);
extern void     pentiumP6PmcGet         (long long int * pPmc0,
					 long long int * pPmc1);
extern void     pentiumP6PmcGet0        (long long int * pPmc0);
extern void     pentiumP6PmcGet1        (long long int * pPmc1);
extern void     pentiumP6PmcReset       (void);
extern void     pentiumP6PmcReset0      (void);
extern void     pentiumP6PmcReset1      (void);
extern STATUS   pentiumP5PmcStart0      (int cesr);
extern STATUS   pentiumP5PmcStart1      (int cesr);
extern void     pentiumP5PmcStop0       (void);
extern void     pentiumP5PmcStop1       (void);
extern void     pentiumP5PmcGet         (long long int * pPmc0,
					 long long int * pPmc1);
extern void     pentiumP5PmcGet0        (long long int * pPmc0);
extern void     pentiumP5PmcGet1        (long long int * pPmc1);
extern void     pentiumP5PmcReset       (void);
extern void     pentiumP5PmcReset0      (void);
extern void     pentiumP5PmcReset1      (void);
extern void	pentiumTscGet64		(long long int * pTsc);
extern UINT32	pentiumTscGet32		(void);
extern void	pentiumTscReset		(void);
extern void	pentiumMsrGet		(int addr, long long int * pData);
extern void	pentiumMsrSet		(int addr, long long int * pData);
extern void	pentiumTlbFlush		(void);
extern void	pentiumSerialize	(void);
extern STATUS	pentiumBts		(char * pFlag);
extern STATUS	pentiumBtc		(char * pFlag);
extern void	pentiumMtrrEnable	(void);
extern void	pentiumMtrrDisable	(void);
extern STATUS	pentiumMtrrGet		(MTRR_ID pMtrr);
extern STATUS	pentiumMtrrSet		(MTRR_ID pMtrr);
extern void	pentiumPmcShow		(BOOL zap);
extern STATUS	pentiumMsrInit		(void);
extern void	pentiumMsrShow		(void);
extern void	pentiumMcaEnable	(BOOL enable);
extern void	pentiumMcaShow		(void);


# 157 "d:/Tornado2.2/target/h/arch/i86/pentiumLib.h"









# 239 "sysLib.c" 2



















 

















 







 





 







 

extern char        end;                        
extern GDT         sysGdt[];                   
extern void        elcdetach (int unit);
extern VOIDFUNCPTR intEoiGet;                  
extern void        intEnt (void);
extern int         sysCpuProbe (void);         
extern VOID        sysUsbOhciPciInit (void);   


 

PHYS_MEM_DESC sysPhysMemDesc [] =
    {
     



     
# 329 "sysLib.c"

     
    {
    (void *) 0x0,
    (void *) 0x0,
    (4096),








    0x03 | 0x0c | 0x30,
    0x01 | 0x04 | 0x10


    },

     
    {
    (void *) (4096),
    (void *) (4096),
    0xa0000 - (4096),
    0x03 | 0x0c | 0x30,
    0x01 | 0x04 | 0x10
    },

     
    {
    (void *) 0x000a0000,
    (void *) 0x000a0000,
    0x00060000,
    0x03 | 0x0c | 0x30,
    0x01 | 0x04 | 0x00
    },



     
    {
    (void *) (0x00100000),
    (void *) (0x00100000),
    0x00180000,
    0x03 | 0x0c | 0x30,
    0x01 | 0x04 | 0x10
    },

     
    {
    (void *) (0x00100000) + 0x00180000,
    (void *) (0x00100000) + 0x00180000,
    ((0x00800000) - (0x00100000)) - 0x00180000,	 
    0x03 | 0x0c | 0x30,
    0x01 | 0x04 | 0x10
    },


# 408 "sysLib.c"


# 421 "sysLib.c"


# 433 "sysLib.c"
    

# 488 "sysLib.c"

     

    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },
    { (void *)  -1,                                   (void *)  -1,                                    -1,                                    -1,                                    -1                                 },

    };

int sysPhysMemDescNumEnt; 	 



PC_CON_DEV	pcConDv [(2)] = 
    {
    {{{{((void *)0)}}}, 0, ((void *)0), ((void *)0)}, 
    {{{{((void *)0)}}}, 0, ((void *)0), ((void *)0)}
    };





extern STATUS usrFdConfig (int type, int drive, char *fileName);
FD_TYPE fdTypes[] =
    {
    {2880,18,2,80,2,0x1b,0x54,0x00,0x0c,0x0f,0x02,1,1,"1.44M"},
    {2400,15,2,80,2,0x24,0x50,0x00,0x0d,0x0f,0x02,1,1,"1.2M"},
    };
UINT    sysFdBuf     = 0x2000;	 
UINT    sysFdBufSize = 0x3000;	 





extern STATUS usrAtaConfig (int ctrl, int drive, char *fileName);
ATA_TYPE ataTypes[2][2] =
    {
     
    {  
         
        {   
        (761),     
        (8),     
        (39),     
        (512),     
        (0xff)      
        },

         
        {   
        (761),     
        (8),     
        (39),     
        (512),     
        (0xff)      
        },
   },

    
   {
         
        {
        (761),     
        (8),     
        (39),     
        (512),     
        (0xff)      
        },

         
        {
        (761),     
        (8),     
        (39),     
        (512),     
        (0xff)      
        }
    }
    };

ATA_RESOURCE ataResources[2] =
    {
     
    {
         
        { 
        (5),              
        (0),              
            {
            (0x1f0),    
            (0x3f6)     
            },  

            {
            (0x1f7),     
            (0x3f7)      
            }, 
        (0),      
        (0),        
        (0),         
        (0),        
        (0),       
        (0)        
        },
    (0),            
    (1),            
    (0x20 + (0x0e)),              
    (0x0e),              
    (0x0300 | 0x000d |                            0x0040     | 0x0020),               
    (5),          
    (5),          
    (0),          
    (0)            
    },   

     
    {
         
        { 
        (5),              
        (0),              
            {
            (0x170),    
            (0x376)     
            },  

            {
            (0x177),     
            (0x377)      
            }, 
        (0),      
        (0),        
        (0),         
        (0),        
        (0),       
        (0)        
        },
    (1),            
    (1),            
    (0x20 + (0x09)),              
    (0x09),              
    (0x0300 | 0x000d |                            0x0040     | 0x0020),               
    (5),          
    (5),          
    (0),          
    (0)            
    }    
    };




# 664 "sysLib.c"

int	sysBus		= 3;		 
int	sysCpu		= 83;		 
char	*sysBootLine	= ((char *) ((0x00100000)+0x1200));  
char	*sysExcMsg	= ((char *) ((0x00100000)+0x1300));	 
int	sysProcNum;			 
int	sysFlags;			 
char	sysBootHost [160];	 
char	sysBootFile [160];	 
UINT	sysIntIdtType	= 0x0000ef00;  
UINT	sysProcessor	= (-1);		 
UINT	sysCoprocessor	= 0;		 
int 	sysWarmType	= 1;       
int	sysWarmFdDrive	= 0;   
int	sysWarmFdType	= 0;    
int	sysWarmAtaCtrl	= 0;   
int	sysWarmAtaDrive	= 0;  
int	sysWarmTffsDrive= 0;  
UINT	sysStrayIntCount = 0;		 
char	*memTopPhys	= ((void *)0);		 
char	*memRom		= ((void *)0);		 
GDT	*pSysGdt	= (GDT *)((0x00100000) + 0x800);
CPUID	sysCpuId	= {0,{0},0,0,0,0,0,0,0,0,{0},{0}};  
BOOL	sysBp		= 1;		 






# 784 "sysLib.c"

UINT8	sysInumTbl[]	=  		 
    {
    0x20,			 
    0x20 + 1,			 
    0x20 + 2,			 
    0x20 + 3,			 
    0x20 + 4,			 
    0x20 + 5,			 
    0x20 + 6,			 
    0x20 + 7,			 
    0x20 + 8,			 
    0x20 + 9,			 
    0x20 + 10,			 
    0x20 + 11,			 
    0x20 + 12,			 
    0x20 + 13,			 
    0x20 + 14,			 
    0x20 + 15,			 
    };



UINT32 sysInumTblNumEnt	= (sizeof (sysInumTbl) / sizeof ((sysInumTbl) [0]));


 


# 826 "sysLib.c"


# 869 "sysLib.c"


 

static void sysStrayInt   (void);
char * sysPhysMemTop	 (void);
STATUS sysMmuMapAdd	 (void * address, UINT len, UINT initialStateMask,
                    	  UINT initialState);
static void sysIntInitPIC (void);
static void sysIntEoiGet  (VOIDFUNCPTR * vector, 
			  VOIDFUNCPTR * routineBoi, int * parameterBoi,
			  VOIDFUNCPTR * routineEoi, int * parameterEoi);


 


# 1 "sysNvRam.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "sysNvRam.c" 2

 






 
# 22 "sysNvRam.c"

 




# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 29 "sysNvRam.c" 2




 
# 44 "sysNvRam.c"

static void sysNvRam_mount()
    {
    int ctrl = 0;
    u_char * pVolDesc;
    





    ctrl = 0;

     

    if(((void *)0) == dosFsVolDescGet("/vxboot/", &pVolDesc))
        {
        dosFsInit (20);

        if (fdDrv (((0x20 + 0x06)), 0x06) != 0)
            {
            return;
            }

        if(usrFdConfig(ctrl, 0, "/vxboot/") != 0)
            {
            logMsg("%s: usrFdConfig failed\n", (int)__FUNCTION__,2,3,4,5,6);
            return;
            }


# 89 "sysNvRam.c"

# 101 "sysNvRam.c"
        }
    }

 
# 115 "sysNvRam.c"

STATUS sysNvRamGet
    (
    char *string,     
    int strLen,       
    int offset        
    )
    {
    int fd, bytes;
    
    if ((offset < 0)
     || (strLen < 0)
     || ((offset + strLen) > (0x1000)))
        return ((-1));

    sysNvRam_mount();
    
    fd = open("/vxboot/""""nvram.txt", 2, 0);
    if(fd == (-1))
        {
        logMsg("%s: open failed\n", (int)__FUNCTION__, 2, 3, 4, 5, 6);
        return ((-1));
        }

    bytes = read(fd, string, strLen);
    if(bytes == (-1))
        {
        logMsg("%s: read failed\n", (int)__FUNCTION__, 2, 3, 4, 5, 6);
        close(fd);
        return ((-1));
        }
    else
        {
        string[bytes] = '\0';
        close(fd);
        return (0);
        }
    }


 
# 165 "sysNvRam.c"

STATUS sysNvRamSet
    (
    char *string,      
    int strLen,        
    int offset         
    )
    {
    int fd;

    if ((offset < 0)
     || (strLen < 0)
     || ((offset + strLen) > (0x1000)))
        return (-1);

    sysNvRam_mount();

    fd = open("/vxboot/""""nvram.txt", 2 | 0x0200, 2);
    if(fd == (-1))
        {
        logMsg("%s: open failed\n", (int)__FUNCTION__, 2, 3, 4, 5, 6);
        return ((-1));
        }
  
    if(write(fd, string, strLen) != strLen)
        {
        logMsg("%s: write failed\n", (int)__FUNCTION__, 2, 3, 4, 5, 6);
        close(fd);
        return ((-1));
        }
    else
        {
        close(fd);
        return (0);
        }
    }



# 887 "sysLib.c" 2




# 1 "sysSerial.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "sysSerial.c" 2

 
# 22 "sysSerial.c"

 








# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 33 "sysSerial.c" 2

# 1 "d:/Tornado2.2/target/h/drv/sio/i8250Sio.h" 1
 

 

 



















# 1 "d:/Tornado2.2/target/h/sioLib.h" 1
 

 

 
# 22 "d:/Tornado2.2/target/h/sioLib.h"


# 249 "d:/Tornado2.2/target/h/sioLib.h"

# 26 "d:/Tornado2.2/target/h/drv/sio/i8250Sio.h" 2

 

typedef struct 		 
    {
    SIO_DRV_FUNCS * pDrvFuncs;        

    STATUS      (*getTxChar) ();      
    STATUS      (*putRcvChar) ();     
    void *      getTxArg;
    void *      putRcvArg;

    UINT16  int_vec;                  
    UINT16  channelMode;              
    UCHAR   (*inByte) (int);          
    void    (*outByte)(int,char);     

    ULONG   lcr;                      
    ULONG   lst;                      
    ULONG   mdc;                      
    ULONG   msr;                      
    ULONG   ier;                      
    ULONG   iid;                      
    ULONG   brdl;                     
    ULONG   brdh;                     
    ULONG   data;                     
    ULONG   options;		      
    } I8250_CHAN;



typedef struct			 
    {
    int rate;		 
    int preset;		 
    } BAUD;

 












 






 








 














 






 
 









 













extern void i8250HrdInit(I8250_CHAN *pDev);
extern void i8250Int (I8250_CHAN  *pDev);
















# 35 "sysSerial.c" 2

 

typedef struct
    {
    USHORT vector;
    ULONG  baseAdrs;
    USHORT regSpace;
    USHORT intLevel;
    } I8250_CHAN_PARAS;


 


# 1 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c" 2

 








 
# 41 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c"

 



# 1 "d:/Tornado2.2/target/h/ioLib.h" 1
 

 

 
# 89 "d:/Tornado2.2/target/h/ioLib.h"


# 343 "d:/Tornado2.2/target/h/ioLib.h"


# 47 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c" 2
# 1 "d:/Tornado2.2/target/h/iosLib.h" 1
 

 

 
# 36 "d:/Tornado2.2/target/h/iosLib.h"


# 131 "d:/Tornado2.2/target/h/iosLib.h"

# 48 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c" 2




# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 53 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c" 2



 

PC_CON_DEV pcConDv [(2)] ;	 


 

static int	pcConDrvNum;	 


 

static int	pcConDrvOpen ();
static STATUS	pcConDrvIoctl (PC_CON_DEV * pPcCoDv, int request, int arg);
static void	pcConDrvHrdInit ();


 
# 82 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c"

STATUS pcConDrv (void)
    {

     

    if (pcConDrvNum > 0)
	return (0);

    pcConDrvHrdInit ();

    pcConDrvNum = iosDrvInstall (pcConDrvOpen, (FUNCPTR) ((void *)0), pcConDrvOpen,
				(FUNCPTR) ((void *)0), tyRead, tyWrite, pcConDrvIoctl
				 );

    return (pcConDrvNum == (-1) ? (-1) : 0);
    }

 
# 111 "d:/Tornado2.2/target/src/drv/serial/pcConsole.c"

STATUS pcConDevCreate 
    (
    char *	name,		 
    register int	channel,         
    int		rdBufSize,	 
    int		wrtBufSize	 
    )
    {
    register PC_CON_DEV *pPcCoDv;

    if (pcConDrvNum <= 0)
	{
	errnoSet (((12 << 16) | 1));
	return ((-1));
	}

     

    if (channel < 0 || channel >= (2))
        return ((-1));

    pPcCoDv = &pcConDv [channel];

    if (pPcCoDv->created)
	return ((-1));

    if (tyDevInit (&pPcCoDv->tyDev, rdBufSize, wrtBufSize, vgaWriteString)
	!= 0)
	{
	return ((-1));
	}

     
    
    sysIntEnablePIC (0x01);

     

    pPcCoDv->created = 1;
    return (iosDevAdd (&pPcCoDv->tyDev.devHdr, name, pcConDrvNum));
    }

 




static void pcConDrvHrdInit (void)
    {
    register int 	oldlevel;	 

    oldlevel= intLock ();

     

    kbdHrdInit ();

     

    vgaHrdInit ();

     



    intUnlock (oldlevel);

    } 

 





static int pcConDrvOpen 
    (
    PC_CON_DEV *	pPcCoDv,
    char *		name,
    int 		mode
    )
    {
    return ((int) pPcCoDv);
    }

 








static STATUS pcConDrvIoctl 
    (
    PC_CON_DEV *	pPcCoDv,	 
    int 		request,	 
    int 		arg		 
    )
    {
    int 	status = 0;

    switch (request)
	{
        case 1001:
            pPcCoDv->vs->curAttrib = arg ;
	    break;

        case 1002:
            status = pPcCoDv->vs->curAttrib;
	    break;

        case 1003:
            if (arg == 0 || arg == 1)
                pPcCoDv->ks->kbdMode = arg;
            else
                status = (-1);
	    break;

        case 1004:
	    pPcCoDv->vs->rev = (pPcCoDv->vs->rev) ? 0 : 1;
	    pPcCoDv->vs->vgaHook (pPcCoDv->vs, arg, 0);	 
            break;

        case 1005:
	    pPcCoDv->vs->vgaHook (pPcCoDv->vs, arg, 1);	 
	    break;

        case 1006:
	    pPcCoDv->vs->vgaHook (pPcCoDv->vs, arg, 2);  
	    break;

        case 1007:
	    pPcCoDv->vs->vgaHook (pPcCoDv->vs, arg, 3);	 
	    break;

        case 1008:
	    pPcCoDv->vs->vgaHook (pPcCoDv->vs, arg, 4);  
	    break;
	    
	case 1009:		 
	    if ((arg >= 0) && (arg < (2)))
	       pPcCoDv->ks->currCon = arg;
	    break;

	case 1010:		  
	    pPcCoDv->ks->convertChar = arg;
	    break;

	case 1011:			 
	    pPcCoDv->ks->kbdFlags &= ~7;
	    pPcCoDv->ks->kbdFlags |= (arg & 7);
	    pPcCoDv->ks->kbdHook (1);
	    break;

	default:
	    status = tyIoctl (&pPcCoDv->tyDev, request, arg);
	    break;
	}

    return (status);
    }


# 51 "sysSerial.c" 2
# 1 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c" 2

 
# 15 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

 
# 57 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

 



# 1 "d:/Tornado2.2/target/h/ioLib.h" 1
 

 

 
# 89 "d:/Tornado2.2/target/h/ioLib.h"


# 343 "d:/Tornado2.2/target/h/ioLib.h"


# 63 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c" 2
# 1 "d:/Tornado2.2/target/h/iosLib.h" 1
 

 

 
# 36 "d:/Tornado2.2/target/h/iosLib.h"


# 131 "d:/Tornado2.2/target/h/iosLib.h"

# 64 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c" 2

# 1 "d:/Tornado2.2/target/h/rngLib.h" 1
 

 

 
# 29 "d:/Tornado2.2/target/h/rngLib.h"


# 165 "d:/Tornado2.2/target/h/rngLib.h"

# 66 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c" 2







# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 74 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c" 2



 

extern PC_CON_DEV	pcConDv [(2)] ;


 

static VGA_CON_DEV	vgaConDv [(2)];
static UCHAR		curSt,curEd;		 
static int 		tyWrtThreshold  = 20;	 


static int 		jobaddThreshold = 20;	 
static UCHAR * vgaCharTable [] = 
    {
     
    (unsigned char *)
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    " !\"#$%&'()*+,-./0123456789:;<=>?"
    "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
    "`abcdefghijklmnopqrstuvwxyz{|}~\0"
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "\040\255\233\234\376\235\174\025\376\376\246\256\252\055\376\376"
    "\370\361\375\376\376\346\024\371\376\376\247\257\254\253\376\250"
    "\376\376\376\376\216\217\222\200\376\220\376\376\376\376\376\376"
    "\376\245\376\376\376\376\231\376\235\376\376\376\232\376\376\341"
    "\205\240\203\376\204\206\221\207\212\202\210\211\215\241\214\213"
    "\376\244\225\242\223\376\224\366\233\227\243\226\201\376\376\230",
     
    (unsigned char *)
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    " !\"#$%&'()*+,-./0123456789:;<=>?"
    "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ "
    "\004\261\007\007\007\007\370\361\040\007\331\277\332\300\305\007"
    "\007\304\007\007\303\264\301\302\263\007\007\007\007\007\234\0"
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "\040\255\233\234\376\235\174\025\376\376\246\256\252\055\376\376"
    "\370\361\375\376\376\346\024\371\376\376\247\257\254\253\376\250"
    "\376\376\376\376\216\217\222\200\376\220\376\376\376\376\376\376"
    "\376\245\376\376\376\376\231\376\376\376\376\376\232\376\376\341"
    "\205\240\203\376\204\206\221\207\212\202\210\211\215\241\214\213"
    "\376\244\225\242\223\376\224\366\376\227\243\226\201\376\376\230",
     
    (unsigned char *)
    "\000\001\002\003\004\005\006\007\010\011\000\013\000\000\000\000"
    "\020\021\022\023\024\025\026\027\030\031\032\000\034\035\036\037"
    "\040\041\042\043\044\045\046\047\050\051\052\053\054\055\056\057"
    "\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077"
    "\100\101\102\103\104\105\106\107\110\111\112\113\114\115\116\117"
    "\120\121\122\123\124\125\126\127\130\131\132\133\134\135\136\137"
    "\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"
    "\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\177"
    "\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217"
    "\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237"
    "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257"
    "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277"
    "\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317"
    "\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337"
    "\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357"
    "\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377"
    };


 

static void	vgaStatInit (void);
static void	vgaHook (register VGA_CON_DEV *  pVgaConDv, int arg, int opCode);
static void	vgaClear (register VGA_CON_DEV *  pVgaConDv, int position, 
			  UCHAR eraseChar);
static void	vgaScroll (register VGA_CON_DEV *  pVgaConDv, int pos, int line, 
			   BOOL upDn, register UCHAR atr);
static void	vgaInsertChar (register VGA_CON_DEV *  pVgaConDv, 
			       register int nInsChar);
static void 	vgaCursorOn (void);
static void	vgaCursorOff (void);
static void	vgaCursorPos (register UINT16 pos);
static void	vgaScreenRev (register VGA_CON_DEV * pVgaConDv);
static void	vgaDelLeftChar (register VGA_CON_DEV *  pVgaConDv);
static void	vgaCarriageReturn (register VGA_CON_DEV *  pVgaConDv);
static void	vgaBackSpace (register VGA_CON_DEV *  pVgaConDv);
static void	vgaLineFeed (register VGA_CON_DEV *  pVgaConDv);
static void	vgaTab (register VGA_CON_DEV *  pVgaConDv);
static void	vgaConBeep (BOOL mode);



static UCHAR vgaColorTable [] = 
    {
     
           0,   4,     2,     6,    1,       5,    3,          7
    };
static void	vgaEscResponse (register PC_CON_DEV * pPcCoDv, int  responseId );
static void	vgaPutCursor (register VGA_CON_DEV *  pVgaConDv);
static void	vgaSaveCurAttrib (register VGA_CON_DEV *  pVgaConDv);
static void	vgaRestAttrib (register VGA_CON_DEV *  pVgaConDv);
static void	vgaSetMode (register  PC_CON_DEV *  pPcCoDv, BOOL onOff);
static void	vgaClearLine (register VGA_CON_DEV *  pVgaConDv);
static void	vgaInsertLine (register VGA_CON_DEV *  pVgaConDv);
static void	vgaSetAttrib (register VGA_CON_DEV *  pVgaConDv);
static void	vgaDelLines (register VGA_CON_DEV *  pVgaConDv);
static void	vgaDelRightChars (register VGA_CON_DEV *  pVgaConDv, int nDelChar);



 
# 195 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

static void vgaConBeep 
    (
    BOOL	mode	 
    )
    {
    int		beepTime;
    int		beepPitch;
    register int 	oldlevel;

    if (mode)
        { 
        beepPitch = 1280;
        beepTime  = (sysClkRateGet () / 3);	 
        }
    else
        { 
        beepPitch = 1208;
        beepTime  = (sysClkRateGet () / 8);	 
        }

    oldlevel = intLock ();

     

    sysOutByte (0x40 + 3, 0xb6);	
    sysOutByte (0x40 + 2, (beepPitch & 0xff));
    sysOutByte (0x40 + 2, (beepPitch >> 8));

     
    sysOutByte (0x61, sysInByte (0x61) | 0x03);	

    taskDelay (beepTime);

     
    sysOutByte (0x61, sysInByte (0x61) & ~0x03);

    intUnlock (oldlevel);
    return;
    }

 
# 246 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

void vgaHrdInit (void)
    {

     

    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0a);
    curSt = sysInByte ((int) (UCHAR *) 0x3d5);
    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0b);
    curEd = sysInByte ((int) (UCHAR *) 0x3d5);

    vgaStatInit ();

     

    vgaClear (pcConDv [(0)].vs, 2,' ');
    vgaCursorOn ();
    return;
    } 

 






static void vgaStatInit (void)
    {
    int		ix;			 
    register VGA_CON_DEV * pVgaConDv;	 

    for (ix = 0; ix < (2); ix++)
	{
	pcConDv [ix].vs	= pVgaConDv = &vgaConDv [ix];

	 
	pVgaConDv->memBase	 = (UCHAR *) 0xb8000;
	pVgaConDv->colorMode     = 1;          
	pVgaConDv->sv_col        = pVgaConDv->col   = 0;
	pVgaConDv->sv_row        = pVgaConDv->row   = 0;
	pVgaConDv->sv_curAttrib  = pVgaConDv->curAttrib = (0x07   | 0x08) | 0x10;
	pVgaConDv->defAttrib     = (0x07   | 0x08) | 0x10;
	pVgaConDv->curChrPos     = pVgaConDv->memBase;   
	pVgaConDv->sv_rev        = pVgaConDv->rev   = 0;
	pVgaConDv->ncol          = 80;                 
	pVgaConDv->nrow          = 25;                 
	pVgaConDv->scst          = 0;                  
	pVgaConDv->sced          = 24;                 
	pVgaConDv->autoWrap      = 1;               
	pVgaConDv->scrollCheck   = 0;              
	pVgaConDv->charSet       = vgaCharTable [0];  
	pVgaConDv->vgaMode       = 0;          
	pVgaConDv->insMode       = 0;    
	pVgaConDv->escFlags      = 0x0001;         
	pVgaConDv->escParaCount  = 0;                  
	pVgaConDv->escQuestion   = 0;              
	bzero ((char *)pVgaConDv->escPara, sizeof(pVgaConDv->escPara));
	bzero (pVgaConDv->tab_stop, sizeof(pVgaConDv->tab_stop));
	pVgaConDv->tab_stop [ 0] = 1;
	pVgaConDv->tab_stop [ 8] = 1;
	pVgaConDv->tab_stop [16] = 1;
	pVgaConDv->tab_stop [24] = 1;
	pVgaConDv->tab_stop [32] = 1;
	pVgaConDv->tab_stop [40] = 1;
	pVgaConDv->tab_stop [48] = 1;
	pVgaConDv->tab_stop [56] = 1;
	pVgaConDv->tab_stop [64] = 1;
	pVgaConDv->tab_stop [72] = 1;
	pVgaConDv->vgaHook	 = (FUNCPTR) vgaHook;	 
	}
    return;
    } 

 
# 331 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

static void vgaHook 
    (
    register VGA_CON_DEV *  pVgaConDv,       
    int			arg,		 
    int			opCode		 
    )
    {
    switch (opCode)
	{
	case 0:
	      vgaScreenRev (pVgaConDv);  
	      break;
	case 1:
	      vgaConBeep (arg);		 
	      break;
	case 2:
	      vgaCursorOn ();		 
	      break;
	case 3:
	      vgaCursorOff ();		 
	      break;
	case 4:				 
	      pVgaConDv->row = (arg >> 8) & 0xff;
	      pVgaConDv->col = arg & 0xff;
	      if (pVgaConDv->row >= pVgaConDv->nrow)
	      pVgaConDv->row = pVgaConDv->nrow - 1;
	      if (pVgaConDv->col >= pVgaConDv->ncol)
	      pVgaConDv->col = pVgaConDv->ncol - 1;
	      vgaCursorPos ((UINT16) (pVgaConDv->row * pVgaConDv->ncol 
				      + pVgaConDv->col));
	      break;
	default:
	      break;
	}
    }

 
# 380 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

static void vgaClear 
    (
    register VGA_CON_DEV *	pVgaConDv,	 
    int			position,	 
    UCHAR		eraseChar	 
    )
    {
    register UINT16 *	cp;	 
    register UINT16 *	end;	 
    register UINT16 	erase;	 

    erase = (pVgaConDv->defAttrib << 8) + eraseChar;
    if ( position == 2 )
	{ 
	cp  = (UINT16 *) pVgaConDv->memBase;
	end = (UINT16 *) (pVgaConDv->memBase + 2048 * 2);
	pVgaConDv->col = pVgaConDv->row = 0;
	pVgaConDv->curChrPos = (UCHAR *) pVgaConDv->memBase;
	}
    else if ( position == 0 )
	{ 
	cp  = (UINT16 *)pVgaConDv->curChrPos;
	end = (UINT16 *)(pVgaConDv->memBase + 2048 * 2);
	}
    else  
	{
	cp  = (UINT16 *) pVgaConDv->memBase;
	end = (UINT16 *) (pVgaConDv->curChrPos + 2);
	}
    for (; cp < end; cp++ )
        {
        *cp     = erase;  
        }
    }

 






static void vgaScreenRev 
    (
    register VGA_CON_DEV * pVgaConDv	 
    )
    {
    UCHAR *	cp;	 
    UCHAR	atr;	 

    for (cp = pVgaConDv->memBase; cp < pVgaConDv->memBase + 2000 * 2; 
	 cp += 2)
        {
        atr = *(cp+1);
        *(cp+1)  = atr & 0x88;
        *(cp+1) |= (atr << 4) & 0x70;
        *(cp+1) |= (atr >> 4) & 0x07;
        }
    }

 
# 450 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

static void vgaScroll 
    (
    register VGA_CON_DEV *	pVgaConDv,	 
    int			pos,		 
    int			lines,		 
    BOOL		upDn,		 
    register UCHAR		atr		 
    )
    {
    register UCHAR *	dest;	 
    register UCHAR *	src;	 

    if (pos < pVgaConDv->scst || pos > pVgaConDv->sced)
        return;

    if (upDn)
        {
	 

        if (pVgaConDv->scst + lines > pVgaConDv->sced + 1)
            lines = pVgaConDv->sced - pVgaConDv->scst + 1;

        for (dest = pVgaConDv->memBase + pVgaConDv->ncol * 2 * 
	     pVgaConDv->scst, src = pVgaConDv->memBase + pVgaConDv->ncol * 
	     2 * (pVgaConDv->scst + lines); src < pVgaConDv->memBase + 
	     pVgaConDv->ncol * 2 * (pos + 1); *dest++ = *src++ );

        for (dest = pVgaConDv->memBase + pVgaConDv->ncol * 2 * 
	     (pos - (lines - 1)); dest < pVgaConDv->memBase + pVgaConDv->ncol *
	     2 * (pos + 1); dest += 2 )
            {
            *dest     = ' ';
            *(dest+1) = atr;
            }
        }
    else
        {
	 

        if (pVgaConDv->scst + lines > pVgaConDv->sced + 1)
            lines = pVgaConDv->sced - pVgaConDv->scst + 1;

        for (dest = pVgaConDv->memBase + pVgaConDv->ncol * 2 * 
	     (pVgaConDv->sced + 1) - 1, src = pVgaConDv->memBase + 
	     pVgaConDv->ncol * 2 * (pVgaConDv->sced - (lines - 1)) - 1;
             src > pVgaConDv->memBase + pVgaConDv->ncol * 2 * pos - 1;
             *dest-- = *src-- );

        for (dest = pVgaConDv->memBase + pVgaConDv->ncol * 2 * 
	     (pos + lines) - 1; dest > pVgaConDv->memBase + pVgaConDv->ncol * 
	     2 * pos - 1;
             dest -= 2 )
            {
            *dest     = atr;
            *(dest-1) = ' ';
            }
        }
    return;
    }

 






static void vgaInsertChar
    (
    register VGA_CON_DEV *	pVgaConDv,	 
    register int		nInsChar	 
    )
    {
    register int		xPos ;   
    register UINT16   	erase;	 
    register UINT16   	swap;	 
    register UINT16 *	chrPos;	 

    if (nInsChar > pVgaConDv->ncol)
	nInsChar = pVgaConDv->ncol;

    else if (nInsChar == 0) 
	nInsChar = 1;
    
    while (nInsChar-- != 0)
	{
	xPos   = pVgaConDv->col;
	chrPos = (UINT16 *) pVgaConDv->curChrPos;
	erase  = (pVgaConDv->defAttrib << 8) + ' ' ; 

	while (xPos++ < pVgaConDv->ncol)
	    {
	     

	    swap    = *chrPos;
	    *chrPos = erase ; 
	    erase   = swap;   
	    chrPos++;
	    }
	}
    }

 






static void vgaDelLeftChar 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    register UINT16		erase;	 

    erase = (pVgaConDv->defAttrib << 8) + ' ' ;
    if (pVgaConDv->autoWrap || pVgaConDv->ncol > 0)
	{
	pVgaConDv->col--;
	pVgaConDv->curChrPos -= 2;
	}
    *(UINT16 *)pVgaConDv->curChrPos = erase;

    }

 






static void vgaCarriageReturn 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {

    pVgaConDv->curChrPos -= pVgaConDv->col * 2;
    pVgaConDv->col = 0;

    }

 






static void vgaBackSpace 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {

    if (pVgaConDv->autoWrap || pVgaConDv->ncol > 0)
	{
	pVgaConDv->col--;
	pVgaConDv->curChrPos -= 2;
	}
    if (pVgaConDv->col < 0)
	{
	pVgaConDv->col = pVgaConDv->ncol - 1;
	pVgaConDv->row--;
	pVgaConDv->scrollCheck = 1;
	}
    }

 






static void vgaTab 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    int			ix;

    for (ix = pVgaConDv->col + 1; ix < 80; ix++)
	{
	if (pVgaConDv->tab_stop [ix])
	    {
	    pVgaConDv->col = ix;
	    break;
	    }
	}
    if (pVgaConDv->autoWrap && ix >= 80)
	{
	pVgaConDv->col = 0;
	pVgaConDv->row++;
	pVgaConDv->scrollCheck = 1;
	}
    pVgaConDv->curChrPos = ( pVgaConDv->memBase + 
			    pVgaConDv->row * pVgaConDv->ncol * 2 + 
			    pVgaConDv->col * 2) ;
    }

 






static void vgaLineFeed 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    pVgaConDv->curChrPos += pVgaConDv->ncol * 2;
    pVgaConDv->row++;
    pVgaConDv->scrollCheck = 1;

    }

 






static void vgaCursorPos 
    (
    register UINT16 pos			 
    )
    {

    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0e);
    sysOutByte ((int) (UCHAR *) 0x3d5, (pos >> 8) & 0xff);
    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0f);
    sysOutByte ((int) (UCHAR *) 0x3d5, pos & 0xff);
    return;
    }

 






static void vgaCursorOn (void)
    {
    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0a);
    sysOutByte ((int) (UCHAR *) 0x3d5, curSt & ~0x20);
    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0b);
    sysOutByte ((int) (UCHAR *) 0x3d5, curEd);
    return;
    }

 






static void vgaCursorOff (void)
    {
    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0a);
    sysOutByte ((int) (UCHAR *) 0x3d5, 0x20);
    sysOutByte ((int) (UCHAR *) 0x3d4, 0x0b);
    sysOutByte ((int) (UCHAR *) 0x3d5, 0x00);
    return;
    }

 
# 735 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

int vgaWriteString
    (
    register PC_CON_DEV *	pPcCoDv	 
    )
    {
    int			dummy;
    UCHAR		ch;
    register int		nBytes;
    register UCHAR		atr;
    register RING_ID        ringId = pPcCoDv->tyDev.wrtBuf;
    register VGA_CON_DEV *	pVgaConDv = pPcCoDv->vs;
    
    pPcCoDv->tyDev.wrtState.busy = 1;
    atr = pVgaConDv->curAttrib;
    nBytes = 0;
    
     

    if (pPcCoDv->tyDev.wrtState.xoff || pPcCoDv->tyDev.wrtState.flushingWrtBuf)
	{
    	pPcCoDv->tyDev.wrtState.busy = 0;
	return nBytes;
	}

    while ((						    dummy = (ringId)->pFromBuf,			    ((ringId)->pToBuf == dummy) ?			0 					    :							(						*&ch = (ringId)->buf[dummy],			(ringId)->pFromBuf = ((++ dummy == (ringId)->bufSize) ? 0 : dummy), 	1						)					    ) != 0)
        {
	nBytes++;		 

	 
	
	if ( (pVgaConDv->escFlags == 0x0001) && (pVgaConDv->charSet [ch]
						     != 0))
	    {
	    *(UINT16 *)pVgaConDv->curChrPos = (atr << 8) + 
		                                  pVgaConDv->charSet [ch];
	    if (pVgaConDv->col == pVgaConDv->ncol - 1)
		{ 
		if (pVgaConDv->autoWrap)
		    { 
		    vgaCarriageReturn (pVgaConDv);	 
		    vgaLineFeed (pVgaConDv);
		    goto VGA_CHECK;		 
		    }
		}
	    else
		{
		pVgaConDv->col++;
		pVgaConDv->curChrPos += 2;
		continue;
		}
	    }

	switch (ch)
	    {
	    case 0x07:		 
	         vgaConBeep (0);
		 continue;
	    
	    case 0x08:		 
		 vgaBackSpace (pVgaConDv);
		 continue;

            case '\t':		 
		 vgaTab (pVgaConDv);
		 continue;

            case '\n':		 
		 if ((pPcCoDv->tyDev.options & 0x02) == 0x02)
		    vgaCarriageReturn (pVgaConDv);
		 vgaLineFeed (pVgaConDv);
		 goto VGA_CHECK;

            case 0x0b:		 
		 vgaLineFeed (pVgaConDv);
		 goto VGA_CHECK;

            case 0x0c:		 
		 vgaClear (pVgaConDv, 2, ' ');
		 continue;

	    case 0x0d:		 
		 vgaCarriageReturn (pVgaConDv);
		 continue;



	    case 0x1b:		 
		 pVgaConDv->escFlags = 0x0002;
		 continue; 

            case 0x9b:		 
		 pVgaConDv->escFlags = 0x0004;
		 continue;


	    case 0x0e:		 
		 pVgaConDv->charSet = vgaCharTable [1];
		 continue;

            case 0x0f:		 
		 pVgaConDv->charSet = vgaCharTable [0];
		 continue;

	    case 0x7f:		 
		 vgaDelLeftChar (pVgaConDv);
		 continue;
	  }


	switch (pVgaConDv->escFlags)
	    {
	    int 	ix;	 

	    case 0x0002:
	            pVgaConDv->escFlags = 0x0001;
		    switch (ch)
			{
			case '[':	 
				pVgaConDv->escFlags = 0x0004;
				continue;

			case 'E':	 
				vgaCarriageReturn (pVgaConDv);
				vgaLineFeed (pVgaConDv);
				goto VGA_CHECK;

			case 'M':	 
				pVgaConDv->row --;
				vgaPutCursor (pVgaConDv);
				continue;
				
			case 'D':	 
				vgaLineFeed (pVgaConDv);
				goto VGA_CHECK;

			case 'H':	 
				vgaTab (pVgaConDv);
				continue;
				
			case 'Z':	 
				vgaEscResponse (pPcCoDv,2);
				continue;
				
			case '7':	 
				vgaSaveCurAttrib (pVgaConDv);
				continue;
				
			case '8':	 
				vgaRestAttrib (pVgaConDv);
				continue;
				
			case '(':	 
				pVgaConDv->escFlags = 0x0080;
				continue;
				
			case ')':	 
				pVgaConDv->escFlags = 0x0100;
				continue;
				
			case '#':	 
				pVgaConDv->escFlags = 0x0040;
				continue;
				
			case 'c':	 
				pPcCoDv->ks->kbdHook (0);
				vgaStatInit ();
				vgaClear (pVgaConDv, 2, ' ');
				vgaCursorOn ();
				continue;

			case '>':	 
				pPcCoDv->ks->kbdFlags |= 0x0002;
				pPcCoDv->ks->kbdHook (1);
				continue;

			case '=':	 
				pPcCoDv->ks->kbdFlags &= ~0x0002;
				pPcCoDv->ks->kbdHook (1);
				continue;
           		}
		    continue;

	    case 0x0004:	 
	            for (ix = 0; ix < 16; ix++)
		        pVgaConDv->escPara [ix] = 0;
		    pVgaConDv->escParaCount = 0;
	            pVgaConDv->escFlags = 0x0008;
		    if ( ch == '[')
			{
			pVgaConDv->escFlags = 0x0020;
			continue;
			}

	             

		    if ( (pVgaConDv->escQuestion = (ch == '?')) )
		       continue;

	    case 0x0008:	 
		    if ( (ch == ';') && (pVgaConDv->escParaCount < 16 -1))
			{
			pVgaConDv->escParaCount++;
			continue;
			}
		    else if (ch >= '0' && ch <= '9')
			{
			pVgaConDv->escPara[pVgaConDv->escParaCount] *= 10;
			pVgaConDv->escPara[pVgaConDv->escParaCount] += ch -'0';
			continue;
			}
		    else
		        pVgaConDv->escFlags = 0x0010;

	    case 0x0010:
		    pVgaConDv->escFlags = 0x0001;
		    switch (ch)
			{
			case 'h':	 
			        vgaSetMode (pPcCoDv, 1);
				continue;
				
			case 'l':	 
				vgaSetMode (pPcCoDv, 0);
				continue;

			case 'n':
				if (!pVgaConDv->escQuestion)
				    {
				    if (pVgaConDv->escPara [0] == 5)
					{  
					vgaEscResponse (pPcCoDv,1);
					}
				    else if ( pVgaConDv->escPara [0] == 6)
					{  
					vgaEscResponse (pPcCoDv,0);
					}
				    continue;
				    }
			}
		    if (pVgaConDv->escQuestion) 
			{
			pVgaConDv->escQuestion = 0;
			continue;
			}
		    switch (ch)
			{
			case 'G':	 
			        if (pVgaConDv->escPara [0] > 0)
				    pVgaConDv->escPara [0]--;

				pVgaConDv->col = pVgaConDv->escPara [0];
				vgaPutCursor (pVgaConDv);
				continue;

			case 'A':	 
			        if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				pVgaConDv->row -= pVgaConDv->escPara [0];
				vgaPutCursor (pVgaConDv);
                                continue;

			case 'B':	 
			        if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				pVgaConDv->row += pVgaConDv->escPara [0];
				vgaPutCursor (pVgaConDv);
				continue;
				
			case 'C':	 
			        if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				pVgaConDv->col += pVgaConDv->escPara [0];
				vgaPutCursor (pVgaConDv);
				continue;

			case 'D':	 
			        if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				pVgaConDv->col -= pVgaConDv->escPara [0];
				vgaPutCursor (pVgaConDv);
				continue;

			case 'E':	 
			        if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				pVgaConDv->row += pVgaConDv->escPara [0];
				pVgaConDv->col = 0;
				vgaPutCursor (pVgaConDv);
				continue;

			case 'F':	 
			        if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				pVgaConDv->row -= pVgaConDv->escPara [0];
				pVgaConDv->col = 0;
				vgaPutCursor (pVgaConDv);
				continue;

			case 'd':	 
			        if (pVgaConDv->escPara [0] > 0)
				    pVgaConDv->escPara [0]--;

				pVgaConDv->row = pVgaConDv->escPara [0];
				vgaPutCursor (pVgaConDv);
				continue;
				
			case 'H':	 
                        case 'f':	 
			        if (pVgaConDv->escPara [0] > 0)
				    pVgaConDv->escPara [0]--;

			        if (pVgaConDv->escPara [1] > 0)
				    pVgaConDv->escPara [1]--;

				pVgaConDv->row = pVgaConDv->escPara [0];
				pVgaConDv->col = pVgaConDv->escPara [1];
				vgaPutCursor (pVgaConDv);
				continue;

			case 'J':	 
				vgaClear (pVgaConDv, pVgaConDv->escPara [0],
					  ' ');
				continue;
				
			case 'K':	 
				vgaClearLine (pVgaConDv);
				continue;
			   
			case 'L':	 
				vgaInsertLine (pVgaConDv);
				continue;
				
			case 'M':	 
				vgaDelLines (pVgaConDv);
				continue;

			case 'P':	 
				vgaDelRightChars (pVgaConDv, 
						  pVgaConDv->escPara [0]);
				continue;
				
			case 'c':	 
				if ( pVgaConDv->escPara [0] == 0 )
				    vgaEscResponse (pPcCoDv,2);

				continue;

			case 'g':	 
				if ( pVgaConDv->escPara [0] == 0 )
				    {
				    vgaTab (pVgaConDv);
				    }
				else if ( pVgaConDv->escPara [0] == 3)
				    {
				    pVgaConDv->tab_stop [0] = 0; 
				    pVgaConDv->tab_stop [1] = 0;
				    pVgaConDv->tab_stop [2] = 0;
				    pVgaConDv->tab_stop [3] = 0;
				    pVgaConDv->tab_stop [4] = 0;
				    }
				continue;
				
			case 'm':	 
				vgaSetAttrib (pVgaConDv);
				continue;

			case 'r':	 
				if (pVgaConDv->escPara [0] == 0)
				    pVgaConDv->escPara [0]++;

				if (pVgaConDv->escPara [1] == 0)
				    pVgaConDv->escPara[1] = pVgaConDv->ncol-1;

				if ((pVgaConDv->escPara [0] < 
				    pVgaConDv->escPara [1]) && 
				    (pVgaConDv->escPara [1] < pVgaConDv->ncol))
				    {
				    pVgaConDv->scst = pVgaConDv->escPara [0] -
				    		      1;
				    pVgaConDv->sced = pVgaConDv->escPara [1];
				    pVgaConDv->row = 0;
				    vgaPutCursor (pVgaConDv);
				    }
				continue;
				
			case 's':	 
				vgaSaveCurAttrib (pVgaConDv);
				continue;

			case 'u':	 
				vgaRestAttrib (pVgaConDv);
				continue;

			case '@':	 
				vgaInsertChar (pVgaConDv, 
					       pVgaConDv->escPara [0]);
				continue;
			}
		    
		    continue;

	    case 0x0020:
		    pVgaConDv->escFlags = 0x0001;
		    continue;

	    case 0x0040:
		    pVgaConDv->escFlags = 0x0001;
		    if ( ch == '8' )
		       vgaClear (pVgaConDv, 2, 'E');	 
		    continue;
		    
	    case 0x0080:
	    case 0x0100:
		    if ( ch == 'O' )
		       pVgaConDv->charSet = vgaCharTable [1];
		    else if ( ch == 'B')
			{
			pVgaConDv->charSet = vgaCharTable [0];
			pVgaConDv->escFlags = 0x0001;
			}
		    else if ( ch == 'U')
			{
			pVgaConDv->charSet = vgaCharTable [2];
			pVgaConDv->escFlags = 0x0001;
			}
		    continue;

	    default:
		    pVgaConDv->escFlags = 0x0001;
	    }


	VGA_CHECK:	 
	    {
	    if (pVgaConDv->scrollCheck && pVgaConDv->curChrPos >= 
		pVgaConDv->memBase + pVgaConDv->ncol * 2 * (pVgaConDv->sced 
							      + 1))
		{ 
		 
		
		pVgaConDv->row = pVgaConDv->sced;
		vgaScroll (pVgaConDv, pVgaConDv->row, pVgaConDv->scrollCheck,
			   1, pVgaConDv->defAttrib);
		while (pVgaConDv->curChrPos >= pVgaConDv->memBase + 
		       pVgaConDv->ncol * 2 * (pVgaConDv->sced + 1))
		pVgaConDv->curChrPos -= pVgaConDv->ncol * 2;
		}
	    else if (pVgaConDv->scrollCheck && pVgaConDv->curChrPos < 
		     pVgaConDv->memBase + pVgaConDv->col * 2 * 
		     pVgaConDv->scst)
		{
		 

		pVgaConDv->row = pVgaConDv->scst;
		vgaScroll (pVgaConDv, pVgaConDv->row, pVgaConDv->scrollCheck,
			   0, pVgaConDv->defAttrib);
		while (pVgaConDv->curChrPos < pVgaConDv->memBase + 
		       pVgaConDv->col * 2 * pVgaConDv->scst)
		pVgaConDv->curChrPos += pVgaConDv->ncol * 2;
		}
	    else if (pVgaConDv->curChrPos > pVgaConDv->memBase + 
		     pVgaConDv->ncol * 2 * pVgaConDv->nrow)
		{ 
		 

		while (pVgaConDv->curChrPos > pVgaConDv->memBase + 
		       pVgaConDv->ncol * 2 * pVgaConDv->nrow)
		    {
		    pVgaConDv->curChrPos -= pVgaConDv->ncol * 2;
		    pVgaConDv->row--;
		    }
		}
	    else if (pVgaConDv->curChrPos < pVgaConDv->memBase)
		{ 
		 

		while (pVgaConDv->curChrPos < pVgaConDv->memBase)
		    {
		    pVgaConDv->curChrPos += pVgaConDv->ncol * 2;
		    pVgaConDv->row++;
		    }
		}
	    }	 

	 

	if ((intContext()) && (nBytes >= jobaddThreshold))
	    {
	    excJobAdd ((VOIDFUNCPTR)vgaWriteString, (int)pPcCoDv, 0,0,0,0,0);
	    return (nBytes);
	    }
	}	 

    vgaCursorPos ((pVgaConDv->curChrPos - pVgaConDv->memBase) / 2 );
    pPcCoDv->tyDev.wrtState.busy = 0;

     

    
    if (rngFreeBytes (ringId) >= tyWrtThreshold)
            {
            semGive (&pPcCoDv->tyDev.wrtSyncSem);
            if (_func_selWakeupAll != ((void *)0))
                (* _func_selWakeupAll) (&pPcCoDv->tyDev.selWakeupList, 
					SELWRITE);
	    }
    return nBytes;	 
    }


    
 
# 1262 "d:/Tornado2.2/target/src/drv/serial/m6845Vga.c"

static void vgaEscResponse
    (
    register PC_CON_DEV *	pPcCoDv,	 
    int			responseId	 
    )
    {
    register VGA_CON_DEV *	pVgaConDv;	 
    pVgaConDv = pPcCoDv->vs;
    tyIoctl (&pPcCoDv->tyDev, 26, 0);
    if ( responseId == 0)
	{
	sprintf (pVgaConDv->escResp, "\033[%d;%dR",pVgaConDv->row, 
		 pVgaConDv->col );
	}
    else if ( responseId == 1) 
	{
	sprintf (pVgaConDv->escResp, "\033[0n");
	}
    else if ( responseId == 2)
	{
	sprintf (pVgaConDv->escResp, "\033[?1;0c");
	}
    else
	{
	pVgaConDv->escResp[0] = '\0';
	}
    
    rngBufPut (pPcCoDv->tyDev.rdBuf, pVgaConDv->escResp, 
	       strlen (pVgaConDv->escResp) );
    semGive (&pPcCoDv->tyDev.rdSyncSem);
    selWakeupAll (&pPcCoDv->tyDev.selWakeupList, SELREAD);

    }

 







static void vgaSaveCurAttrib 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    pVgaConDv->sv_rev       = pVgaConDv->rev;
    pVgaConDv->sv_col       = pVgaConDv->col;
    pVgaConDv->sv_row       = pVgaConDv->row;
    pVgaConDv->sv_curAttrib = pVgaConDv->curAttrib;

    }
    
 







static void vgaRestAttrib 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    pVgaConDv->rev       = pVgaConDv->sv_rev;
    pVgaConDv->col       = pVgaConDv->sv_col;
    pVgaConDv->row       = pVgaConDv->sv_row;
    pVgaConDv->curAttrib = pVgaConDv->sv_curAttrib;
    
    }

 






static void vgaSetAttrib 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )  
    {
    register int		ix;	 
    register UCHAR		attr;	 
    
    attr = pVgaConDv->curAttrib;
    for (ix = 0 ; ix <= pVgaConDv->escParaCount; ix++)
	{
	switch (pVgaConDv->escPara [ix])
	    {
	    case 0:
	          attr =  (0x07   | 0x08) | 0x10;
		  break;
		  
            case 1:
		  attr |= 0x08;		 
		  break;
	       
	    case 4:
		  if (!pVgaConDv->colorMode)
		      {
		      attr |= 0x01;
		      }
		  break;
		  
	    case 5:
		  attr |= 0x80;		 
		  break;

	    case 7:
		  pVgaConDv->rev = 1;  
		  attr = (attr & 0x88) | (((attr >> 4) | ((attr << 4) & 0x7)));
		  break;
		  
	    case 21:
	    case 22:
		  attr &= ~0x08;		 
		  break;
		  
	    case 24:
		  if (!pVgaConDv->colorMode)
		      {
		      attr &= ~0x01;	 
		      }
		  break;
		  
	    case 25:
		  attr &= ~0x80;
		  break;

	    case 27:
		  pVgaConDv->rev = 0; 	 
		  break;

	    default:		
		   

		  if ((pVgaConDv->escPara [ix] >= 30) && 
		      (pVgaConDv->escPara [ix] <= 37) )
		      {
		      attr = (attr & 0xf8) | 
		             (vgaColorTable [pVgaConDv->escPara [ix] - 30]) ;
		      }
		  else if ((pVgaConDv->escPara [ix] >= 40) &&
			   (pVgaConDv->escPara [ix] <= 47))
		      {
		      attr = (attr & 0x8f) |
		             vgaColorTable [pVgaConDv->escPara [ix] - 40] << 4;
		      }
		  break;
            }
	}
    pVgaConDv->curAttrib = attr;    
    }

 






static void vgaSetMode
    (
    register  PC_CON_DEV *	pPcCoDv,	 
    BOOL         	onOff		 
    )
    {
    register int		ix;
    register VGA_CON_DEV *	pVgaConDv;	 
    
    pVgaConDv = pPcCoDv->vs;
    for ( ix =0; ix <= pVgaConDv->escParaCount; ix++ )
	{
	if ( pVgaConDv->escQuestion )
	    {
	    switch (pVgaConDv->escPara [ix])
		{  
		case 1:
		      pPcCoDv->ks->curMode = (onOff) ?  0 : 1;
		      break;
		      
                case 3:  
		      vgaClear (pVgaConDv, 2, ' ');
		      break;
		      
                case 5:
		      pVgaConDv->rev = (pVgaConDv->rev) ? 0 : 1;
		      vgaScreenRev (pVgaConDv);
		      break;
		      
                case 7:
		      pVgaConDv->autoWrap = onOff;
		      break;
		      
                case 25:
		      (onOff) ?  vgaCursorOn() : vgaCursorOff() ;
		      break;
		}
	    }
	else if ( pVgaConDv->escPara [ix] == 4)
	    {
	    pVgaConDv->insMode = onOff;
	    }
	}
    }

 






static void vgaPutCursor 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    if ( pVgaConDv->col  < 0)
	pVgaConDv->col = 0;

    else if (pVgaConDv->col >= pVgaConDv->ncol)
	pVgaConDv->col = pVgaConDv->ncol - 1;

    if ( pVgaConDv->row < pVgaConDv->scst)
	pVgaConDv->row = pVgaConDv->scst;

    else if ( pVgaConDv->row >= pVgaConDv->sced )
	pVgaConDv->row = pVgaConDv->sced;
	    
    pVgaConDv->curChrPos = (pVgaConDv->memBase + pVgaConDv->row *
			    pVgaConDv->ncol * 2 + pVgaConDv->col * 2 );
    
    }

 






static void vgaClearLine 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    register UINT16 *	cp;	 
    register UINT16 *	end;	 
    register UINT16		erase;	 

    erase = (pVgaConDv->defAttrib << 8 ) + ' ';
    
    if (pVgaConDv->escPara [0] == 0 )
	{
	cp  = (UINT16 *) (pVgaConDv->curChrPos + 2 );
	end = (UINT16 *) (pVgaConDv->memBase + pVgaConDv->row  * 
			  pVgaConDv->ncol * 2 + (pVgaConDv->ncol - 1) * 2);
	}
    else if (pVgaConDv->escPara [0] == 1)
	{
	cp  = (UINT16 *) (pVgaConDv->memBase + pVgaConDv->row * 
			 pVgaConDv->ncol * 2);
	end = (UINT16 *) (pVgaConDv->curChrPos);
	}
    else 
	{
	cp  = (UINT16 *) (pVgaConDv->memBase + pVgaConDv->row * 
			  pVgaConDv->ncol * 2);
	end = (UINT16 *) (cp + (pVgaConDv->ncol - 1) * 2);
	pVgaConDv->curChrPos = (UCHAR *) cp ;
	pVgaConDv->col = 0;
	}
    for (; cp <= end; cp ++)
	{
	*cp = erase;
	}
    }

 







static void vgaInsertLine 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    int			ix;
    int			start;
    int			end;

    start = pVgaConDv->scst;
    end   = pVgaConDv->sced;
    pVgaConDv->scst = pVgaConDv->row;
    pVgaConDv->sced = pVgaConDv->nrow - 1 ;
    ix = pVgaConDv->escPara [0];
    if (pVgaConDv->escPara [0] == 0)
	{
	ix = 1;
	}
    if (pVgaConDv->row + ix >= pVgaConDv->nrow)
	{
	ix = pVgaConDv->nrow - pVgaConDv->row - 1;
	}
    vgaScroll (pVgaConDv, pVgaConDv->row, ix, 0, pVgaConDv->defAttrib);
    pVgaConDv->curChrPos -= pVgaConDv->col * 2;
    pVgaConDv->col = 0;
    pVgaConDv->scst = start;
    pVgaConDv->sced = end ;
    
    }
     
 







static void vgaDelLines 
    (
    register VGA_CON_DEV *	pVgaConDv	 
    )
    {
    int			ix;
    int			start;
    int			end;

    start = pVgaConDv->scst;
    end = pVgaConDv->sced;
    pVgaConDv->scst = pVgaConDv->row;
    pVgaConDv->sced = pVgaConDv->nrow - 1;
    ix = pVgaConDv->escPara [0];
    if (ix == 0)
	{
	ix = 1;
	}
    if (pVgaConDv->row + ix > pVgaConDv->nrow) 
	{
	ix = pVgaConDv->row;
	}
    vgaScroll (pVgaConDv, pVgaConDv->sced, ix, 1, pVgaConDv->defAttrib);
    pVgaConDv->curChrPos -= pVgaConDv->col * 2;
    pVgaConDv->col = 0;
    pVgaConDv->scst = start;
    pVgaConDv->sced = end;

    }

 






static void vgaDelRightChars
    (
    register VGA_CON_DEV *	pVgaConDv,	 
    int			nDelChar	 
    )
    {
    register int		xPos;	 
    register UINT16 *	cp;	 
    register UINT16		erase;	 
    
    erase = (pVgaConDv->defAttrib << 8 ) + ' ';

    if (nDelChar + pVgaConDv->col  >=  pVgaConDv->ncol )
	{
	nDelChar = pVgaConDv->ncol - pVgaConDv->col - 1;
	}
    else if (nDelChar == 0)
	{
	nDelChar = 1;
	}
    while ( nDelChar-- )
	{
	xPos = pVgaConDv->col;
	cp   = (unsigned short *) pVgaConDv->curChrPos;
	while (++xPos < pVgaConDv->ncol)
	    {
	    *cp = *(cp +1);
	    cp++;
	    }
	*cp =  erase;            
	}
    }



# 52 "sysSerial.c" 2

# 1 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c" 2

 
# 17 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

 
# 61 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

 



# 1 "d:/Tornado2.2/target/h/ioLib.h" 1
 

 

 
# 89 "d:/Tornado2.2/target/h/ioLib.h"


# 343 "d:/Tornado2.2/target/h/ioLib.h"


# 67 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c" 2
# 1 "d:/Tornado2.2/target/h/iosLib.h" 1
 

 

 
# 36 "d:/Tornado2.2/target/h/iosLib.h"


# 131 "d:/Tornado2.2/target/h/iosLib.h"

# 68 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c" 2




# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 73 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c" 2



 

extern PC_CON_DEV	pcConDv [(2)] ;


 

int			kbdIntCnt = 0;
int			kbdTimeoutCnt = 0;
BOOL			kbdTimeout = 0;


 

static WDOG_ID		kbdWdid;
static int		kbdWdsec = 2;
static KBD_CON_DEV	kbdConDv;	 
static UCHAR		oldLedStat = 0;
static BOOL		kbdAcknowledge = 0;
static unsigned	char enhancedKeys[] =   
    {
    0x1c,    
    0x1d,    
    0x35,    
    0x37,    
    0x38,    
    0x46,    
    0x47,    
    0x48,    
    0x49,    
    0x4b,    
    0x4d,    
    0x4f,    
    0x50,    
    0x51,    
    0x52,    
    0x53     
    };


 

static UCHAR action [144] =
    {  
    0,   0,   0,   0,   0,   0,   0,   0,  
   0,   0,   0,   0,   0,   0,   0,   0,  
   0,   0,   0,   0,   0,   0,   0,   0,  
   0,   0,   0,   0,   0,   2,   0,   0,  
   0,   0,   0,   0,   0,   0,   0,   0,  
   0,   0,   1,   0,   0,   0,   0,   0,  
   0,   0,   0,   0,   0,   0,   1,   0,  
   0,   0,   4,   0,    0,    0,    0,     0,  
    0,   0,    0,    0,    0,    3,   5,   7,  
   7,   7,   7,   7,   7,   7,   7,   7,  
   7,   7,   7,   7,   0,    0,    0,     0,  
    0,   0,    0,    0,    0,    0,    0,     0,  
    0,   0,    0,    0,    0,    0,    0,     0,  
    0,   0,    0,    0,    0,    0,    0,     0,  
   0,   0,    0,    0,   0,    0,    0,    0,  
    0,   0,   0,    0,    0,    0,   0,     0,  
   0,   2,   0,   0,   0,   5,   6,   6,  
   0,   6,   6,   0,   6,   0,   6,   6   
    };

 
static UCHAR keyMap [2][4][144] =
    { 
    {  
    {  
    0,  0x1b,   '1',   '2',   '3',   '4',   '5',   '6',	 
  '7',   '8',   '9',   '0',   '-',   '^',  0x08,  '\t',	 
  'q',   'w',   'e',   'r',   't',   'y',   'u',   'i',	 
  'o',   'p',   '@',   '[',  '\r',   2,    'a',   's',	 
  'd',   'f',   'g',   'h',   'j',   'k',   'l',   ';',	 
  ':',     0,   1,    ']',   'z',   'x',   'c',   'v',	 
  'b',   'n',   'm',   ',',   '.',   '/',   1,    '*',	 
  ' ',   ' ',   4,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,   3,    5,    '7',	 
  '8',   '9',   '-',   '4',   '5',   '6',   '+',   '1',	 
  '2',   '3',   '0',   '.',     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
  ' ',     0,     0,  '\\',     0,     0,   ' ',     0,	 
    0,   ' ',     0,     0,     0,  '\\',     0,     0,	 
  '\r',   2,   '/',   '*',   ' ',    5,    'F',   'A',  
    0,   'D',   'C',     0,   'B',     0,    '@',   'P'   
    },
    {  
    0,  0x1b,   '!',   '"',   '#',   '$',   '%',   '&',	 
 '\'',   '(',   ')',     0,   '=',   '~',  0x08,  '\t',	 
  'Q',   'W',   'E',   'R',   'T',   'Y',   'U',   'I',	 
  'O',   'P',   '`',   '{',  '\r',   2,    'A',   'S',	 
  'D',   'F',   'G',   'H',   'J',   'K',   'L',   '+',	 
  '*',     0,   1,    '}',   'Z',   'X',   'C',   'V',	 
  'B',   'N',   'M',   '<',   '>',   '?',   1,    '*',	 
  ' ',   ' ',   4,      0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,   3,    5,    '7',	 
  '8',   '9',   '-',   '4',   '5',   '6',   '+',   '1',	 
  '2',   '3',   '0',   '.',     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
  ' ',     0,     0,   '_',     0,     0,   ' ',     0,	 
    0,   ' ',     0,     0,     0,   '|',     0,     0,	 
  '\r',   2,   '/',   '*',   ' ',    5,    'F',   'A',  
    0,   'D',   'C',     0,   'B',     0,    '@',   'P'   
    },
    {  
 0xff,  0x1b,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0x1e,  0xff,  '\t',	 
 0x11,  0x17,  0x05,  0x12,  0x14,  0x19,  0x15,  0x09,	 
 0x0f,  0x10,  0x00,  0x1b,  '\r',   2,  0x01,   0x13,	 
 0x04,  0x06,  0x07,  0x08,  0x0a,  0x0b,  0x0c,  0xff,	 
 0xff,  0xff,   1,   0x1d,  0x1a,  0x18,  0x03,  0x16,	 
 0x02,  0x0e,  0x0d,  0xff,  0xff,  0xff,  1,    0xff,	 
 0xff,  0xff,   4,   0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,   3,   5,    0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0x1f,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0x1c,  0xff,  0xff,	 
  '\r',   2,   '/',   '*',   ' ',    5,  0x0c,  0xff,  
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff   
    },
    {  
    0,  0x1b,   '1',   '2',   '3',   '4',   '5',   '6',	 
  '7',   '8',   '9',   '0',   '-',   '^',  0x08,  '\t',	 
  'q',   'w',   'e',   'r',   't',   'y',   'u',   'i',	 
  'o',   'p',   '@',   '[',  '\r',   2,    'a',   's',	 
  'd',   'f',   'g',   'h',   'j',   'k',   'l',   ';',	 
  ':',     0,   1,    ']',   'z',   'x',   'c',   'v',	 
  'b',   'n',   'm',   ',',   '.',   '/',   1,    '*',	 
  ' ',   ' ',   4,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,   3,    5,    'w',	 
  'x',   'y',   'l',   't',   'u',   'v',   'm',   'q',	 
  'r',   's',   'p',   'n',     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
  ' ',     0,     0,  '\\',     0,     0,   ' ',     0,	 
    0,   ' ',     0,     0,     0,  '\\',     0,     0,	 
  '\r',   2,   '/',   '*',   ' ',    5,    'F',   'A',  
    0,   'D',   'C',     0,   'B',     0,    '@',   'P'   
    }
    },
    {  
    {  
    0,  0x1b,   '1',   '2',   '3',   '4',   '5',   '6',	 
  '7',   '8',   '9',   '0',   '-',   '=',  0x08,  '\t',	 
  'q',   'w',   'e',   'r',   't',   'y',   'u',   'i',	 
  'o',   'p',   '[',   ']',  '\r',   2,    'a',   's',	 
  'd',   'f',   'g',   'h',   'j',   'k',   'l',   ';',	 
 '\'',   '`',   1,   '\\',   'z',   'x',   'c',   'v',	 
  'b',   'n',   'm',   ',',   '.',   '/',   1,    '*',	 
  ' ',   ' ',   4,      0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,   3,    5,    '7',	 
  '8',   '9',   '-',   '4',   '5',   '6',   '+',   '1',	 
  '2',   '3',   '0',   '.',     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
  '\r',   2,   '/',   '*',   ' ',    5,   'F',   'A',  
    0,   'D',   'C',     0,   'B',     0,    '@',  'P'   
    },
    {  
    0,  0x1b,   '!',   '@',   '#',   '$',   '%',   '^',	 
  '&',   '*',   '(',   ')',   '_',   '+',  0x08,  '\t',	 
  'Q',   'W',   'E',   'R',   'T',   'Y',   'U',   'I',	 
  'O',   'P',   '{',   '}',  '\r',   2,    'A',   'S',	 
  'D',   'F',   'G',   'H',   'J',   'K',   'L',   ':',	 
  '"',   '~',   1,    '|',   'Z',   'X',   'C',   'V',	 
  'B',   'N',   'M',   '<',   '>',   '?',   1,    '*',	 
  ' ',   ' ',   4,      0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,   3,    5,    '7',	 
  '8',   '9',   '-',   '4',   '5',   '6',   '+',   '1',	 
  '2',   '3',   '0',   '.',     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
  '\r',   2,   '/',   '*',   ' ',    5,   'F',   'A',  
    0,   'D',   'C',     0,   'B',     0,   '@',   'P'   
    },
    {  
 0xff,  0x1b,  0xff,  0x00,  0xff,  0xff,  0xff,  0xff,	 
 0x1e,  0xff,  0xff,  0xff,  0x1f,  0xff,  0xff,  '\t',	 
 0x11,  0x17,  0x05,  0x12,  0x14,  0x19,  0x15,  0x09,	 
 0x0f,  0x10,  0x1b,  0x1d,  '\r',   2,   0x01,  0x13,	 
 0x04,  0x06,  0x07,  0x08,  0x0a,  0x0b,  0x0c,  0xff,	 
 0xff,  0x1c,   1,   0xff,  0x1a,  0x18,  0x03,  0x16,	 
 0x02,  0x0e,  0x0d,  0xff,  0xff,  0xff,   1,   0xff,	 
 0xff,  0xff,   4,   0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,   3,    5,   0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,	 
  '\r',   2,   '/',   '*',   ' ',    5,  0xff,  0xff,  
 0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff,  0xff   
    },
    {  
    0,  0x1b,   '1',   '2',   '3',   '4',   '5',   '6',	 
  '7',   '8',   '9',   '0',   '-',   '=',  0x08,  '\t',	 
  'q',   'w',   'e',   'r',   't',   'y',   'u',   'i',	 
  'o',   'p',   '[',   ']',  '\r',   2,    'a',   's',	 
  'd',   'f',   'g',   'h',   'j',   'k',   'l',   ';',	 
 '\'',   '`',   1,   '\\',   'z',   'x',   'c',   'v',	 
  'b',   'n',   'm',   ',',   '.',   '/',   1,    '*',	 
  ' ',   ' ',   4,      0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,   3,    5,    'w',	 
  'x',   'y',   'l',   't',   'u',   'v',   'm',   'q',	 
  'r',   's',   'p',   'n',     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
    0,     0,     0,     0,     0,     0,     0,     0,	 
  '\r',   2,   '/',   '*',   ' ',    5,   'F',   'A',  
    0,   'D',   'C',     0,   'B',     0,    '@',  'P'   
    }
    }
    };

 

static void	kbdStatInit (void);
static void	kbdConvChar(unsigned char scanCode);
static void	kbdLedSet (void);
static void	kbdNormal (unsigned char scanCode);
static void	kbdShift (unsigned char scanCode);
static void	kbdCtrl (unsigned char scanCode);
static void	kbdNum (unsigned char scanCode);
static void	kbdCaps (unsigned char scanCode);
static void	kbdStp (unsigned char scanCode);
static void	kbdExt (unsigned char scanCode);
static void	kbdEs (unsigned char scanCode);
static void 	(*keyHandler[]) (unsigned char scanCode)  =
    {
    kbdNormal,   kbdShift,   kbdCtrl,   kbdNum,   kbdCaps,
    kbdStp,      kbdExt,     kbdEs
    };
static void	kbdHook (int opCode);
static void	kbdWdog (void);
static STATUS	kbdWrite (char data);
static STATUS	kbdRead (char *data);
static STATUS	kbdCommand (char data);
      void	kbdReset (void);		 

 
# 345 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

void kbdHrdInit (void)
    {
    char	temp;

    kbdWdid = wdCreate ();

    do {
	if (kbdTimeoutCnt > 3)		 	
	    break;

	if (kbdTimeout)			 
	    kbdReset ();

        if (kbdCommand (0x60) == (-1))
	    continue;
        if (kbdWrite (0x44) == (-1))
	    continue;

        while (sysInByte (0x64) & 0x01)
	    if (kbdRead (&temp) == (-1))
		break;
    
        if (kbdCommand (0x60) == (-1))
	    continue;
        if (kbdWrite (0x45) == (-1))
	    continue;

        if (kbdCommand (0xae) == (-1))
	    continue;
	} while (kbdTimeout);

    kbdStatInit ();
    } 

 
# 389 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

static void kbdStatInit (void)
    {
    int		ix;		 
    UCHAR	stat;

     

    for ( ix = 0; ix < (2); ix++)
	{
	pcConDv [ix].ks = &kbdConDv;		 
	}

    kbdConDv.curMode = 1;	 
    kbdConDv.convertChar = 1;	 
    
     
    
    kbdConDv.kbdMode  = 1; 
    kbdConDv.kbdFlags = 0x0000|0x0002;		 
    kbdConDv.kbdState = 0; 			 
    kbdConDv.kbdHook  = (FUNCPTR) kbdHook;	 
    kbdConDv.currCon  = (0);     	 
    

    stat = (UCHAR) (kbdConDv.kbdFlags & 0x07);

    if (oldLedStat == stat)
	return;
    oldLedStat = stat;

    do {
	if (kbdTimeoutCnt > 3)		 	
	    break;

	if (kbdTimeout)			 
	    kbdReset ();

        if (kbdWrite (0xed) == (-1))
	    continue;

        if (kbdWrite (stat) == (-1))
	    continue;
	} while (kbdTimeout);
    }

 
# 445 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

void kbdIntr (void)
    {
    register UCHAR	scanCode;	 

    kbdIntCnt++;

    if (sysInByte (0x64) & 0x01)
        {
	scanCode = sysInByte (0x60);

	 

	if (scanCode == 0xfa) 
	    {
	    kbdAcknowledge = 1;
	    return;
	    }
	if (kbdConDv.convertChar) 
	    kbdConvChar (scanCode);
	else
	    tyIRd (&(pcConDv[kbdConDv.currCon].tyDev), scanCode);
        }
    }

 








static void kbdConvChar 
    (
    UCHAR	scanCode	 
    )
    {
    if (scanCode == 0xe0)
	{
	kbdConDv.kbdFlags |= 0x0020;
	return;
	}

     

    if (((scanCode & 0x80) << 2) == 0x0200)  
       kbdConDv.kbdFlags |=  0x0200;
    else
       kbdConDv.kbdFlags &= ~0x0200;

    if ((scanCode == 0xe1) || (kbdConDv.kbdFlags & 0x0080))
	{
	if (scanCode == 0xe1)
	    {
	    kbdConDv.kbdFlags ^= 0x0200; 	 
	    kbdConDv.kbdFlags ^= 0x0080;  	 
	    }
	return;
	}
    scanCode &= 0x7f;
    if ((kbdConDv.kbdFlags & 0x0020) == 0x0020)
	{
	int 	ix;		

	for (ix = 0; ix < 16; ix++)
	    {
	    if (scanCode == enhancedKeys [ix])
		{
		scanCode = 0x80 + ix;
		ix = -1;
		break;
		}
	    }
	kbdConDv.kbdFlags ^= 0x0020; 	 
	if (ix != -1)
	    {
	    return ; 			 
	    }
	}

     

    (*keyHandler [action [scanCode]]) (scanCode);
    }

 








static void kbdNormal
    (
    UCHAR	scanCode	 
    )
    {
    register UCHAR	chr;
    register int	ix = kbdConDv.currCon;	 

    if ((kbdConDv.kbdFlags & 0x0200) == 0x0000) 
	{
	chr = keyMap [kbdConDv.kbdMode][kbdConDv.kbdState][scanCode];
	if ((chr == 0xff) || (chr == 0x00))
	    {
	    return;
	    }

	 

	if (((kbdConDv.kbdFlags & 0x0004) == 0x0004) && 
	    (chr >= 'a' && chr <= 'z'))
	    { 
	    chr -= 'a' - 'A';
	    } 
	tyIRd (&(pcConDv [ix].tyDev), chr);	 
	}
    }

 








static void kbdShift
    (
    UCHAR	scanCode	 
    )
    {
    if ((kbdConDv.kbdFlags & 0x0200) == 0x0200) 
	{
	kbdConDv.kbdState = 0;
	kbdConDv.kbdFlags &= (~0x0008);
	}
    else
	{
	kbdConDv.kbdState = 1;
	kbdConDv.kbdFlags |= 0x0008;
	}
    }

 








static void kbdCtrl
    (
    UCHAR	scanCode	 
    )
    {
    if ((kbdConDv.kbdFlags & 0x0200) == 0x0200) 
	{
	kbdConDv.kbdState = 0;
	kbdConDv.kbdFlags &= (~0x0010);
	}
    else
	{
	kbdConDv.kbdState = 2;
	kbdConDv.kbdFlags |= 0x0010;
	}
    }

 








static void kbdCaps
    (
    UCHAR	scanCode	 
    )
    {
    if ((kbdConDv.kbdFlags & 0x0200) == 0x0000) 
	{
	kbdConDv.kbdFlags ^= 0x0004;
	kbdLedSet (); 		 
	}
    }

 
# 651 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

static void kbdNum
    (
    UCHAR	scanCode	 
    )
    {
    if ((kbdConDv.kbdFlags & 0x0200) == 0x0000) 
	{
	kbdConDv.kbdFlags ^= 0x0002;
	kbdConDv.kbdState = (kbdConDv.kbdFlags & 0x0002) ? 0 : 3;
	kbdLedSet (); 		 
	}
    }

 
# 674 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

static void kbdStp
    (
    UCHAR	scanCode	 
    )
    {
    register int	ix = kbdConDv.currCon;	 

    if ((kbdConDv.kbdFlags & 0x0200) == 0x0000) 
	{
	kbdConDv.kbdFlags ^= 0x0001;
	(kbdConDv.kbdFlags & 0x0001) ? tyIRd (&(pcConDv [ix].tyDev),0x13) : 
	                              tyIRd (&(pcConDv [ix].tyDev),0x11);
	kbdLedSet (); 		 
	}
    }

 
# 701 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

static void kbdExt
    (
    UCHAR 	scanCode	 
    )
    {
    register UCHAR	chr;
    register int	ix = kbdConDv.currCon;	 

    if ((kbdConDv.kbdFlags & 0x0200) == 0x0000) 
	{
	chr = keyMap [kbdConDv.kbdMode][kbdConDv.kbdState][scanCode];
	tyIRd (&pcConDv [ix].tyDev, 0x1b); 	 
	kbdConDv.curMode ? tyIRd (&pcConDv [ix].tyDev, '[') : 
	                     tyIRd (&pcConDv [ix].tyDev, 'O');
	tyIRd (&pcConDv [ix].tyDev, chr);	
	}
    }

 








static void kbdEs
    (
    UCHAR	scanCode	 
    )
    {
    register UCHAR	chr;
    register int	ix = kbdConDv.currCon;	 

    if ((kbdConDv.kbdFlags & 0x0200) == 0x0000) 
	{
	chr = keyMap [kbdConDv.kbdMode][kbdConDv.kbdState][scanCode];
	if ((kbdConDv.kbdFlags & 0x0002) == 0x0000)
	    {
	    tyIRd (&pcConDv [ix].tyDev, 0x1b);   
	    tyIRd (&pcConDv [ix].tyDev, 'O');
	    }
	tyIRd (&pcConDv [ix].tyDev, chr);
	}
    }

 
# 758 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

static void kbdLedSet (void)
    {
    int		ix;
    UCHAR 	stat = 0;

     
    stat = (UCHAR) (kbdConDv.kbdFlags & 0x07);

    if (oldLedStat == stat)
	return;
    oldLedStat = stat;

    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;

    sysOutByte (0x60, 0xed);		 


    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;

    sysOutByte (0x60, stat);		 
    }

 
# 796 "d:/Tornado2.2/target/src/drv/serial/i8042Kbd.c"

static void kbdHook
    (
    int opCode		 
    )
    {
    switch (opCode)
	{
	case 0:
	      kbdStatInit ();
	      break;
        case 1:
	      kbdLedSet ();
	      break;
	default:
	      break;
	}
    }
 








static STATUS kbdRead
    (
    char *pData
    )
    {

    kbdTimeout = 0;
    wdStart (kbdWdid, (sysClkRateGet() * kbdWdsec), (FUNCPTR)kbdWdog, 0);

    while (((sysInByte (0x64) & 0x01) == 0) && !kbdTimeout)
	;

    wdCancel (kbdWdid);

    taskDelay (sysClkRateGet () >> 4);

    *pData = sysInByte (0x60);

    return (kbdTimeout ? (-1) : 0);
    }
 








static STATUS kbdWrite
    (
    char data
    )
    {

    kbdTimeout = 0;
    wdStart (kbdWdid, (sysClkRateGet() * kbdWdsec), (FUNCPTR)kbdWdog, 0);

    while ((sysInByte (0x64) & 0x02) && !kbdTimeout)
	;

    wdCancel (kbdWdid);

    sysOutByte (0x60, data);

    return (kbdTimeout ? (-1) : 0);
    }
 








static STATUS kbdCommand
    (
    char command
    )
    {

    kbdTimeout = 0;
    wdStart (kbdWdid, (sysClkRateGet() * kbdWdsec), (FUNCPTR)kbdWdog, 0);

    while ((sysInByte (0x64) & 0x02) && !kbdTimeout)
	;

    sysOutByte (0x64, command);

    while ((sysInByte (0x64) & 0x02) && !kbdTimeout)
	;

    wdCancel (kbdWdid);

    return (kbdTimeout ? (-1) : 0);
    }
 








void kbdReset (void)
    {
    int		ix;

    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;

    sysOutByte (0x60, 0xff);

    taskDelay (sysClkRateGet () >> 4);

    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;

    sysOutByte (0x60, 0x60);

    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;

    sysOutByte (0x60, 0x45);

    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;

    sysOutByte (0x64, 0xae);

    for (ix=0; ix<100; ix++)		 
	if ((sysInByte (0x64) & 0x02) == 0)
	    break;
    }
 








static void kbdWdog
    (
    void
    )
    {
    kbdTimeout = 1;
    kbdTimeoutCnt++;
    }

# 54 "sysSerial.c" 2






 





 

static I8250_CHAN  i8250Chan[2];

static I8250_CHAN_PARAS devParas[] = 
    {
      {(0x20 + 0x04),0x3f8,1,0x04},
      {(0x20 + 0x03),0x2f8,1,0x03}

# 87 "sysSerial.c"
    };


 
# 102 "sysSerial.c"


void sysSerialHwInit (void)
    {
    int i;

    for (i = 0; i < 2; i++)
        {
	i8250Chan[i].int_vec = devParas[i].vector;
	i8250Chan[i].channelMode = 0;
	i8250Chan[i].lcr =  (devParas[i].baseAdrs + 0x03*devParas[i].regSpace);
	i8250Chan[i].data =  (devParas[i].baseAdrs + 0x00*devParas[i].regSpace);
	i8250Chan[i].brdl = (devParas[i].baseAdrs + 0x00*devParas[i].regSpace);
	i8250Chan[i].brdh = (devParas[i].baseAdrs + 0x01*devParas[i].regSpace);
	i8250Chan[i].ier =  (devParas[i].baseAdrs + 0x01*devParas[i].regSpace);
	i8250Chan[i].iid =  (devParas[i].baseAdrs + 0x02*devParas[i].regSpace);
	i8250Chan[i].mdc =  (devParas[i].baseAdrs + 0x04*devParas[i].regSpace);
	i8250Chan[i].lst =  (devParas[i].baseAdrs + 0x05*devParas[i].regSpace);
	i8250Chan[i].msr =  (devParas[i].baseAdrs + 0x06*devParas[i].regSpace);

	i8250Chan[i].outByte = sysOutByte;
	i8250Chan[i].inByte  = sysInByte;

	if (sysBp)
	    i8250HrdInit(&i8250Chan[i]);
        }

    }
 
# 145 "sysSerial.c"

void sysSerialHwInit2 (void)
    {
    int i;

     

    for (i = 0; i < 2; i++)
        if (i8250Chan[i].int_vec)
	    {
            (void) intConnect (((VOIDFUNCPTR *) ((i8250Chan[i].int_vec) << 3)),
                                i8250Int, (int)&i8250Chan[i] );
	    if (sysBp)
                sysIntEnablePIC (devParas[i].intLevel); 
            }

    }


 
# 174 "sysSerial.c"

SIO_CHAN * sysSerialChanGet
    (
    int channel		 
    )
    {
    if ((channel >= 0) && (channel < 2))
        {
        return ((SIO_CHAN * ) &i8250Chan[channel]);
        }

    return ((SIO_CHAN *) (-1));
    }



# 892 "sysLib.c" 2




# 1 "d:/Tornado2.2/target/src/drv/vme/nullVme.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/vme/nullVme.c" 2

 
# 19 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

 
# 35 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

 
# 49 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

STATUS sysLocalToBusAdrs
    (
    int  adrsSpace,      
                         
                         
    char *localAdrs,     
    char **pBusAdrs      
    )
    {
    return ((-1));
    }

 
# 75 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"
 
STATUS sysBusToLocalAdrs
    (
    int  adrsSpace,      
                         
                         
    char *busAdrs,       
    char **pLocalAdrs    
    )
    {
    return ((-1));
    }

 
# 98 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

int sysBusIntAck
    (
    int intLevel         
    )
    {
    return (0);
    }

 
# 118 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

STATUS sysBusIntGen
    (
    int level,           
    int vector           
    )
    {
    return ((-1));
    }

 
# 142 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

STATUS sysMailboxConnect
    (
    FUNCPTR routine,     
    int     arg          
    )
    {
    return ((-1));
    }

 
# 165 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"

STATUS sysMailboxEnable
    (
    INT8 *mailboxAdrs            
    )
    {
    return ((-1));
    }

 
# 186 "d:/Tornado2.2/target/src/drv/vme/nullVme.c"
 
BOOL sysBusTas
    (
    INT8 *addr           
    )
    {
    return(vxTas(addr));        
    }


# 897 "sysLib.c" 2



# 924 "sysLib.c"
# 1 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c" 2

 
# 32 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"

 
# 120 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"




 

extern void	intBoiExit ();
extern UINT32	sysStrayIntCount;
extern BOOL	sysBp;		 


 




 


 


static INT8	i8259IntMask1;		 
static INT8	i8259IntMask2;		 
static INT8	i8259Mask = 0;		 



 


 







VOID i8259Init (void)

    {
    UINT8 icw4 = 0x01;

     

    if (sysBp == 0)
	return;

     

    sysOutByte ((  (0x20+(0x00*1))),0x11);         
    sysOutByte ((  (0x20+(0x01*1))),0x20);  
    sysOutByte ((  (0x20+(0x01*1))),0x04);         









    sysOutByte ((  (0x20+(0x01*1))),icw4);         

    sysOutByte ((  (0xa0+(0x00*1))),0x11);         
    sysOutByte ((  (0xa0+(0x01*1))),0x20+8);  
    sysOutByte ((  (0xa0+(0x01*1))),0x02);         
    sysOutByte ((  (0xa0+(0x01*1))),0x01);         

     

    sysOutByte ((  (0x20+(0x01*1))),0xfb);
    sysOutByte ((  (0xa0+(0x01*1))),0xff);
    }



 








VOID i8259IntBoiEem
    (
    int irqNo		 
    )
    {
    INT32 oldLevel = intLock ();			 

    sysOutByte ((  (0x20+(0x00*1))), 0x20);	 

    intUnlock (oldLevel);				 
    }

 








VOID i8259IntBoiSmm
    (
    int irqNo		 
    )
    {
    INT32 oldLevel = intLock ();			 

    sysOutByte ((  (0x20+(0x00*1))), 0x68);	 
    i8259Mask = sysInByte ((  (0x20+(0x01*1))));	 
    sysOutByte ((  (0x20+(0x01*1))), 0x01);	 

    intUnlock (oldLevel);				 
    }

 








VOID i8259IntBoi
    (
    INT32 irqNo		 
    )
    {
    INT32 oldLevel;
    INT8 inserviceReg;

     

    if ((irqNo != 7) && (irqNo != 15))
	return;

     

    oldLevel = intLock ();		 

    if (irqNo == 7)
	{
        sysOutByte ((  (0x20+(0x00*1))), 0x0b);
        inserviceReg = sysInByte ((  (0x20+(0x00*1))));
	}
    else
	{
        sysOutByte ((  (0xa0+(0x00*1))), 0x0b);
        inserviceReg = sysInByte ((  (0xa0+(0x00*1))));
	}
    
    intUnlock (oldLevel);		 

     
# 324 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"
     
    if ((inserviceReg & 0x80) == 0)	 
	{
	sysStrayIntCount++;		 
        *((UINT32 *)&irqNo - 1) = (UINT32)intBoiExit;	 
	}
    }

 








VOID i8259IntEoiSmm 
    (
    int irqNo		 
    )
    {
    INT32 oldLevel = intLock ();			 

    sysOutByte ((  (0x20+(0x01*1))), i8259Mask);	 
    sysOutByte ((  (0x20+(0x00*1))), 0x08);	 
    sysOutByte ((  (0x20+(0x00*1))), 0x20);	 

    intUnlock (oldLevel);				 
    }

 







VOID i8259IntEoiMaster 
    (
    INT32 irqNo		 
    )
    {


    __asm__ volatile ("				pushfl;				cli;				movl	$0x20, %edx;		movl	$0x20, %eax;		outb	%al, %dx;		popfl;				");









# 388 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"
    }

 








VOID i8259IntEoiSlave
    (
    INT32 irqNo		 
    )
    {


    __asm__ volatile ("				pushfl;				cli;				movl	$0xa0, %edx;		movl	$0x20, %eax;		outb	%al, %dx;		movl	$0x20, %edx;		outb	%al, %dx;		popfl;				");
# 416 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"


# 427 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"
    }

 








VOID i8259IntEoiSlaveNfnm
    (
    INT32 irqNo		 
    )
    {


    __asm__ volatile ("				pushfl;				cli;				movl	$0xa0, %edx;		movl	$0x20, %eax;		outb	%al, %dx;		movl	$0x20, %edx;		outb	%al, %dx;		popfl;				");
# 455 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"


# 466 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"
    }

 








VOID i8259IntEoiSlaveSfnm
    (
    int irqNo		 
    )
    {
    INT8  inserviceReg;
    INT32 oldLevel = intLock ();			 

    sysOutByte ((  (0xa0+(0x00*1))), 0x20);	 

    sysOutByte ((  (0xa0+(0x00*1))), 0x0b);	 
    inserviceReg = sysInByte ((  (0xa0+(0x00*1))));  
    if (inserviceReg == 0) 
        sysOutByte ((  (0x20+(0x00*1))), 0x20);	 

    intUnlock (oldLevel);				 
    }

 
# 507 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"

static STATUS i8259IntDisable
    (
    INT32 irqNo         
    )
    {

    if (irqNo < 8)
	{
	sysOutByte ((  (0x20+(0x01*1))),
	    sysInByte ((  (0x20+(0x01*1)))) | (1 << irqNo));
	}
    else
	{
	sysOutByte ((  (0xa0+(0x01*1))),
	    sysInByte ((  (0xa0+(0x01*1)))) | (1 << (irqNo - 8)));
	}

    return (0);
    }

 
# 540 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"

static STATUS i8259IntEnable
    (
    INT32 irqNo         
    )
    {

    if (irqNo < 8)
	{
	sysOutByte ((  (0x20+(0x01*1))),
	    sysInByte ((  (0x20+(0x01*1)))) & ~(1 << irqNo));
	}
    else
	{
	sysOutByte ((  (0xa0+(0x01*1))),
	    sysInByte ((  (0xa0+(0x01*1)))) & ~(1 << (irqNo - 8)));
	}

    return (0);
    }

 
# 572 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"

static VOID i8259IntLock (void)

    {

    i8259IntMask1 = sysInByte ((  (0x20+(0x01*1))));
    i8259IntMask2 = sysInByte ((  (0xa0+(0x01*1))));
    sysOutByte ((  (0x20+(0x01*1))), 0xff);
    sysOutByte ((  (0xa0+(0x01*1))), 0xff);
    }

 
# 594 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"

static VOID i8259IntUnlock (void)

    {

    sysOutByte ((  (0x20+(0x01*1))), i8259IntMask1);
    sysOutByte ((  (0xa0+(0x01*1))), i8259IntMask2);
    }


# 654 "d:/Tornado2.2/target/src/drv/intrCtl/i8259Intr.c"



# 925 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c" 2

 
# 49 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

 
# 92 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"











# 116 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"








 

static FUNCPTR sysClkRoutine	= ((void *)0);  
static int sysClkArg		= 0;  
static int sysClkRunning		= 0;
static int sysClkConnected	= 0;
static int sysClkTicksPerSecond	= 60;

static FUNCPTR sysAuxClkRoutine	= ((void *)0);
static int sysAuxClkArg		= 0;
static int sysAuxClkRunning	= 0;




static int sysAuxClkTicksPerSecond = 64;

static CLK_RATE auxTable[] =
    {
    {   2, 0x0f}, 
    {   4, 0x0e}, 
    {   8, 0x0d}, 
    {  16, 0x0c}, 
    {  32, 0x0b}, 
    {  64, 0x0a}, 
    { 128, 0x09}, 
    { 256, 0x08}, 
    { 512, 0x07}, 
    {1024, 0x06}, 
    {2048, 0x05}, 
    {4096, 0x04}, 
    {8192, 0x03} 
    };



 






 







void sysClkInt (void)
    {

     






     

    if (sysClkRoutine != ((void *)0))
	(* sysClkRoutine) (sysClkArg);
    
    }


 
# 205 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

STATUS sysClkConnect
    (
    FUNCPTR routine,	 
    int arg		 
    )
    {

    if (sysClkConnected == 0)
	sysHwInit2 ();	 

    sysClkRoutine   = routine;
    sysClkArg	    = arg;
    sysClkConnected = 1;

    return (0);
    }


 
# 234 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

void sysClkDisable (void)
    {
    int oldLevel;

    if (sysClkRunning)
	{
        oldLevel = intLock ();				 
	sysOutByte ((  (0x40+(0x03*1))), 0x38);
	sysOutByte ((  (0x40+(0x00*1))), ((0) & 0xff));
	sysOutByte ((  (0x40+(0x00*1))), (((0) >> 8) & 0xff));
        intUnlock (oldLevel);				 

	sysIntDisablePIC (0x00);
	




	sysClkRunning = 0;
	}
    }


 
# 268 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

void sysClkEnable (void)
    {
    UINT tc0;
    UINT tc2;
    int oldLevel;

    if (!sysClkRunning)
	{
	
	tc0 = 1193180 / sysClkTicksPerSecond;
        tc2 = 1193180 / sysClkTicksPerSecond * 2;

        oldLevel = intLock ();				 

	sysOutByte ((  (0x40+(0x03*1))), 0x36);
	sysOutByte ((  (0x40+(0x00*1))), ((tc0) & 0xff));
	sysOutByte ((  (0x40+(0x00*1))), (((tc0) >> 8) & 0xff));











        
        intUnlock (oldLevel);				 

	 
	sysIntEnablePIC (0x00);
	
	sysClkRunning = 1;


# 314 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"
	}
    }


 
# 328 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

int sysClkRateGet (void)
    {
    return (sysClkTicksPerSecond);
    }


 
# 346 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

STATUS sysClkRateSet
    (
    int ticksPerSecond	     
    )
    {
    if (ticksPerSecond < (19) || ticksPerSecond > (1193180/32))
	return ((-1));

    sysClkTicksPerSecond = ticksPerSecond;

    if (sysClkRunning)
	{
	sysClkDisable ();
	sysClkEnable ();
	}

    return (0);
    }


# 515 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

 
# 525 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

void sysAuxClkInt (void)
    {
    int oldLevel;

     

    oldLevel = intLock ();				 
    sysOutByte (0x70, 0x0c);
    sysInByte (0x71);
    intUnlock (oldLevel);				 

     

    if (sysAuxClkRoutine != ((void *)0))
	(*sysAuxClkRoutine) (sysAuxClkArg);
    }

 
# 554 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

STATUS sysAuxClkConnect
    (
    FUNCPTR routine,     
    int arg              
    )
    {
    sysAuxClkRoutine	= routine;
    sysAuxClkArg	= arg;

    return (0);
    }

 
# 577 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

void sysAuxClkDisable (void)
    {
    if (sysAuxClkRunning)
        {
	 

	sysOutByte (0x70, 0x0b);
	sysOutByte (0x71, 0x02);

	sysIntDisablePIC (0x08);

	sysAuxClkRunning = 0;
        }
    }

 
# 603 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

void sysAuxClkEnable (void)
    {
    int ix;
    char statusA;
    int oldLevel;

    if (!sysAuxClkRunning)
        {

	 

	for (ix = 0; ix < (sizeof (auxTable) / sizeof ((auxTable) [0])); ix++)
	    {
	    if (auxTable [ix].rate == sysAuxClkTicksPerSecond)
		{
	        sysOutByte (0x70, 0x0a);
	        statusA = sysInByte (0x71) & ~0x0f;
	        sysOutByte (0x70, 0x0a);
	        sysOutByte (0x71, statusA | auxTable [ix].bits);
		break;
		}
	    }

	 

        oldLevel = intLock ();				 

        sysOutByte (0x70, 0x0c);	 
        sysInByte (0x71);

	sysOutByte (0x70, 0x0b);	 
	sysOutByte (0x71, 0x40 | 0x02);

	sysIntEnablePIC (0x08);

	sysAuxClkRunning = 1;

        intUnlock (oldLevel);				 
	}
    }

 
# 655 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

int sysAuxClkRateGet (void)
    {
    return (sysAuxClkTicksPerSecond);
    }

 
# 672 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

STATUS sysAuxClkRateSet
    (
    int ticksPerSecond   
    )
    {
    int		ix;	 
    BOOL	match;	 

    match = 0; 	 

    if (ticksPerSecond < (2) || ticksPerSecond > (8192))
        return ((-1));

    for (ix = 0; ix < (sizeof (auxTable) / sizeof ((auxTable) [0])); ix++)
	{
	if (auxTable [ix].rate == ticksPerSecond)
	    {
	    sysAuxClkTicksPerSecond = ticksPerSecond;
	    match = 1;
	    break;
	    }
	}

    if (!match)		 
       return ((-1));

    if (sysAuxClkRunning)
	{
	sysAuxClkDisable ();
	sysAuxClkEnable ();
	}

    return (0);
    }




# 899 "d:/Tornado2.2/target/src/drv/timer/i8253Timer.c"

# 926 "sysLib.c" 2



# 1 "pciCfgStub.c" 1
 

 

 
# 14 "pciCfgStub.c"

 
# 25 "pciCfgStub.c"


 

 


























 
 




 




 



 



 








 

typedef struct pciBoardResource       
    {
    UINT32        pciBus;             
    UINT32        pciDevice;          
    UINT32        pciFunc;            

    UINT32        vendorID;           
    UINT32        deviceID;           
    UINT8         revisionID;         
    UINT32        boardType;          

    UINT8         irq;                
    UINT32        irqvec;             

    UINT32        bar [6];            

    void * const  pExtended;          

    } PCI_BOARD_RESOURCE;


 

extern STATUS pciConfigLibInit (int, ULONG, ULONG, ULONG);
extern int    ffsLsb (UINT32 i);



 
# 123 "pciCfgStub.c"
VOID sysPciCfgInit
    (
    int	   mechanism,	 
    UINT32 addr1,	 
    UINT32 addr2,	 
    UINT32 addr3	 
    )
    {

     





     

    if (pciConfigLibInit (mechanism, addr1, addr2, addr3) != 0)
        {
	sprintf (sysExcMsg, "pciCfgStub.c: PCI configuration failure\n");
        sysToMonitor (0x01);
        }

    }

# 930 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 2

 
# 66 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"


 
# 647 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"


# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 650 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 2



# 1 "d:/Tornado2.2/target/h/dllLib.h" 1
 

 

 
# 20 "d:/Tornado2.2/target/h/dllLib.h"


# 172 "d:/Tornado2.2/target/h/dllLib.h"

# 654 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 2



# 1 "d:/Tornado2.2/target/h/stdlib.h" 1
 

 

 
# 37 "d:/Tornado2.2/target/h/stdlib.h"


# 186 "d:/Tornado2.2/target/h/stdlib.h"

# 658 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 2

# 1 "config.h" 1
 

 

 
# 145 "config.h"

 





# 762 "config.h"






# 660 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 2
# 1 "d:/Tornado2.2/target/h/drv/pci/pciConfigLib.h" 1
 

 

 
# 46 "d:/Tornado2.2/target/h/drv/pci/pciConfigLib.h"








 

# 1 "d:/Tornado2.2/target/h/pciClass.h" 1
 

 

 













 






 

























 















 








 







 








 





 





 






















 













 




















 










 




 








 










 






 







 






 





 











# 57 "d:/Tornado2.2/target/h/drv/pci/pciConfigLib.h" 2


 
# 70 "d:/Tornado2.2/target/h/drv/pci/pciConfigLib.h"













 





 




 





 












 












 








 



















 






 
 



 
 


































 
 





















 



 





     
 










 

 









 






 



























STATUS pciConfigLibInit	(int mechanism, ULONG addr0, ULONG addr1, ULONG addr2);
STATUS pciFindDevice	(int vendorId, int deviceId, int index,	
			 int * pBusNo, int * pDeviceNo, int * pFuncNo);
STATUS pciFindClass	(int classCode, int index,	
			 int * pBusNo, int * pDeviceNo, int * pFuncNo);
STATUS pciConfigInByte	(int busNo, int	deviceNo, int funcNo, int address,
			 UINT8 * pData);
STATUS pciConfigInWord	(int busNo, int	deviceNo, int funcNo, int address,
			 UINT16 * pData);
STATUS pciConfigInLong	(int busNo, int	deviceNo, int funcNo, int address,
			 UINT32 * pData);
STATUS pciConfigOutByte	(int busNo, int	deviceNo, int funcNo, int address,
			 UINT8 data);
STATUS pciConfigOutWord	(int busNo, int	deviceNo, int funcNo, int address,
			 UINT16 data);
STATUS pciConfigOutLong	(int busNo, int	deviceNo, int funcNo, int address,
			 UINT32 data);
STATUS pciSpecialCycle	(int busNo, UINT32 message);
int pciConfigBdfPack(int busNo, int deviceNo, int funcNo);
STATUS pciDevConfig ( int pciBusNo, int pciDevNo, int pciFuncNo,
		      UINT32 devIoBaseAdrs, UINT32 devMemBaseAdrs,
		      UINT32 command );
STATUS pciConfigExtCapFind (UINT8 extCapFindId, int bus, int device,
    int function, UINT8 * pOffset);

STATUS pciConfigModifyLong ( int busNo, int deviceNo, int funcNo, int offset,   
			     UINT32 bitMask, UINT32 data );
STATUS pciConfigModifyWord ( int busNo, int deviceNo, int funcNo, int offset,   
			     UINT16 bitMask, UINT16 data );
STATUS pciConfigModifyByte ( int busNo, int deviceNo, int funcNo, int offset,   
			     UINT8 bitMask, UINT8 data );

 
typedef STATUS (*PCI_FOREACH_FUNC)(int bus, int dev, int func, void *pArg);

STATUS pciConfigForeachFunc ( UINT8 bus, BOOL recurse,
			     PCI_FOREACH_FUNC funcCheckFunc,
			     void *pArg
			     );


 











# 661 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c" 2

 






 
# 683 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

 

 

STATUS  pciLibInitStatus = (-1);	 

int     pciConfigMech = (-1);		 

int     pciMaxBus = 255;	 

 

static int pciConfigAddr0;		 
static int pciConfigAddr1;		 
static int pciConfigAddr2;		 

static FUNCPTR pciConfigRead = ((void *)0);      
static FUNCPTR pciConfigWrite = ((void *)0);     
static FUNCPTR pciConfigSpcl = ((void *)0);      

 
# 757 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigLibInit
    (
    int mechanism,  
    ULONG addr0,    
    ULONG addr1,    
    ULONG addr2	    
    )
    {

    if (pciLibInitStatus != (-1))
	return (pciLibInitStatus);

    switch (mechanism)
	{
        case 0:    
            if (addr0 == 0 || addr1 == 0)
	        {
                pciLibInitStatus = (-1);
		}
            else
                {
                pciConfigRead = (FUNCPTR) addr0;
                pciConfigWrite = (FUNCPTR) addr1;
                pciConfigSpcl = (FUNCPTR) addr2;
                }
	    pciConfigMech	= mechanism;
	    pciLibInitStatus	= 0;
            break;
 
	case 1:
	case 2:
	    pciConfigMech	= mechanism;
	    pciConfigAddr0	= addr0;
	    pciConfigAddr1	= addr1;
	    pciConfigAddr2	= addr2;
	    pciLibInitStatus	= 0;
	    break;

	default:
    	    pciLibInitStatus	= (-1);
	    break;
	}

    return (pciLibInitStatus);
    }


 
# 814 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciFindDevice
    (
    int    vendorId,	 
    int    deviceId,	 
    int    index,	 
    int *  pBusNo,	 
    int *  pDeviceNo,	 
    int *  pFuncNo	 
    )
    {
    STATUS status = (-1);
    BOOL   cont   = 1;
    int    busNo;
    int    deviceNo;
    int    funcNo;
    UINT32 device;
    UINT32 vendor;
    UINT8  header;

    if (pciLibInitStatus != 0)			 
        cont = 0;

    for (busNo = 0; cont == 1 && busNo <= pciMaxBus; busNo++)
        for (deviceNo = 0;
	     ((cont == 1) && (deviceNo < 32));
	     ++deviceNo)
            for (funcNo = 0; cont == 1 && funcNo < 8; funcNo++)
		{
		 

		if ((deviceNo == 0x1f) && (funcNo == 0x07))
		    continue;

		pciConfigInLong (busNo, deviceNo, funcNo, 0x00,
				 &vendor);

		 




		if (((vendor & 0x0000ffff) == 0x0000FFFF) && (funcNo == 0))
		    break;

		device  = vendor >> 16;
		device &= 0x0000FFFF;
		vendor &= 0x0000FFFF;
		if ((vendor == (UINT32)vendorId) &&
		    (device == (UINT32)deviceId) &&
		    (index-- == 0))
		    {
		    *pBusNo	= busNo;
		    *pDeviceNo	= deviceNo;
		    *pFuncNo	= funcNo;
		    status	= 0;
		    cont	= 0;	 
		    continue;
		    }

		 

		pciConfigInByte (busNo, deviceNo, funcNo, 0x0e, 
				 &header);
		if ((header & 0x80) != 0x80 &&
		    funcNo == 0)
		    break;
		}

    return (status);
    }

 
# 906 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciFindClass
    (
    int    classCode,	 
    int	   index,	 
    int *  pBusNo,	 
    int *  pDeviceNo,	 
    int *  pFuncNo	 
    )
    {
    STATUS status = (-1);
    BOOL   cont   = 1;
    int    busNo;
    int    deviceNo;
    int    funcNo;
    UINT32 classCodeReg;
    UINT32 vendor;
    UINT8  header;

    if (pciLibInitStatus != 0)			 
        cont = 0;

    for (busNo = 0; cont == 1 && busNo <= pciMaxBus; busNo++)
        for (deviceNo = 0;
	     ((cont == 1) && (deviceNo < 32));
	     ++deviceNo)
            for (funcNo = 0; cont == 1 && funcNo < 8; funcNo++)
		{

		 

		if ((deviceNo == 0x1f) && (funcNo == 0x07))
		    continue;

		pciConfigInLong (busNo, deviceNo, funcNo, 0x00,
				 &vendor);

		 




		if (((vendor & 0x0000ffff) == 0x0000FFFF) && (funcNo == 0))
		    break;
	
		pciConfigInLong (busNo, deviceNo, funcNo, 0x08,
				 &classCodeReg);

		if ((((classCodeReg >> 8) & 0x00ffffff) == classCode) &&
		    (index-- == 0))
		    {
		    *pBusNo	= busNo;
		    *pDeviceNo	= deviceNo;
		    *pFuncNo	= funcNo;
		    status	= 0;
		    cont 	= 0;	 
		    continue;
		    }

		 

		pciConfigInByte (busNo, deviceNo, funcNo, 0x0e, 
				 &header);
		if ((header & 0x80) != 0x80 &&
		    funcNo == 0)
		    break;
		}

    return (status);
    }


 
# 997 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciDevConfig
    (
    int pciBusNo,           
    int pciDevNo,           
    int pciFuncNo,          
    UINT32 devIoBaseAdrs,   
    UINT32 devMemBaseAdrs,  
    UINT32 command          
    )
    {
    INT32       ix;
    UINT32      tmp32;

     




    pciConfigOutLong (pciBusNo, pciDevNo, pciFuncNo, 0x04,
			0x0);

     








    for (ix = 0x10; ix <= 0x24; ix+=4)
        {
         

        pciConfigOutLong (pciBusNo, pciDevNo, pciFuncNo, ix, 0xffffffff);
        pciConfigInLong  (pciBusNo, pciDevNo, pciFuncNo, ix, &tmp32);

         

        if (tmp32 == 0)
           {
            



           break;
           }

         

         

        if (tmp32 & 0x1)
           {
           pciConfigOutLong (pciBusNo, pciDevNo, pciFuncNo, ix,
			     devIoBaseAdrs | 0x1);
           }

         

        else
           {
           pciConfigOutLong (pciBusNo, pciDevNo, pciFuncNo, ix,
			     devMemBaseAdrs & ~0x1);
           }
        }

     

    pciConfigOutByte (pciBusNo, pciDevNo, pciFuncNo, 0x0c,
		      (32/4));

     

    pciConfigOutByte (pciBusNo, pciDevNo, pciFuncNo, 0x0d,
		      0xff);

     




    pciConfigModifyLong (pciBusNo, pciDevNo, pciFuncNo, 0x04,
  		      (0xffff0000 | command), command);

    return (0);
    }


 
# 1096 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

int pciConfigBdfPack
    (
    int	busNo,     
    int	deviceNo,  
    int	funcNo     
    )
    {
    return (((busNo    << 16) & 0x00ff0000) |
	    ((deviceNo << 11) & 0x0000f800) |
	    ((funcNo   << 8)  & 0x00000700));
    }

 
# 1119 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigExtCapFind
    (
    UINT8 extCapFindId,     
    int bus,                
    int device,             
    int function,           
    UINT8 * pOffset         
    )
    {
    STATUS retStat = (-1);
    UINT16 tmpStat;
    UINT8  tmpOffset;
    UINT8  capOffset = 0x00;
    UINT8  capId = 0x00;

     

    pciConfigInWord(bus, device, function, 0x06, &tmpStat);

    if ((tmpStat & 0x0010) == 0)
        {
        return retStat;
        }

     

    pciConfigInByte(bus, device, function, 0x34, &capOffset);
    capOffset &= ~0x02;

     

    if (capOffset < 0x40)
        {
        return retStat;
        }

     

    while (capOffset != 0x00)
        {

         

        pciConfigInByte(bus, device, function, (int)capOffset, &capId);
        if (capId == extCapFindId)
            {
            *pOffset = (capOffset + (UINT8)0x02);
            retStat = 0;
            break;
            }

         

        tmpOffset = capOffset + (UINT8)0x01;
        pciConfigInByte(bus, device, function, (int)tmpOffset, &capOffset);

        }

    return retStat;    
    }


 








STATUS pciConfigInByte
    (
    int	busNo,     
    int	deviceNo,  
    int	funcNo,	   
    int	offset,	   
    UINT8 * pData  
    )
    {
    UINT8 retval = 0;
    UINT32 retvallong = 0;
    STATUS retStat = (-1);
    int	key;

    if (pciLibInitStatus != 0)			 
        return ((-1));

    key = intLock ();				 

    switch (pciConfigMech)
	{
        case 0:
            if (pciConfigRead (busNo, deviceNo, funcNo,
                               offset, 1, (void *)&retval)
		== (-1))
		{
                retval = 0xff;
		}
	    else 
		{
		retStat = 0;
		}
            break;

	case 1:
	    sysOutLong (pciConfigAddr0,  

		          pciConfigBdfPack (busNo, deviceNo, funcNo) |
# 1228 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"
		          (offset & 0xfc) | 0x80000000);
	    retval = sysInByte (pciConfigAddr1 + (offset & 0x3));
	    retStat = 0;
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xf0 | (funcNo << 1));
	    sysOutByte (pciConfigAddr1,  busNo);
	    retvallong =
		sysInLong (pciConfigAddr2 | ((deviceNo & 0x000f) << 8) 			| (offset & 0xfc));

	    sysOutByte (pciConfigAddr0,  0);
	    retvallong >>= (offset & 0x03) * 8;
	    retval = (UINT8)(retvallong & 0xff);
	    retStat = 0;
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    *pData = retval;

    return (retStat);
    }

 








STATUS pciConfigInWord
    (
    int	busNo,       
    int	deviceNo,    
    int	funcNo,      
    int	offset,      
    UINT16 * pData   
    )
    {
    STATUS retStat = (-1);
    UINT16 retval = 0;
    UINT32 retvallong = 0;
    int	key;

     







    if ((pciLibInitStatus != 0) || ((offset & (int)0x1) > 0) )
	{
        return (retStat);
	}


    key = intLock ();				 

    switch (pciConfigMech)
	{
        case 0:
            if (pciConfigRead (busNo, deviceNo, funcNo, offset, 2,
                                (void *)&retval) == (-1))
		{
		retval = 0xffff;
		}
	    else
		{
		retStat = 0;
		}
            break;

	case 1:
	    sysOutLong (pciConfigAddr0,  

		          pciConfigBdfPack (busNo, deviceNo, funcNo) |
# 1312 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"
		          (offset & 0xfc) | 0x80000000);
	    retval = sysInWord (pciConfigAddr1 + (offset & 0x2));
	    retStat = 0;
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xf0 | (funcNo << 1));
	    sysOutByte (pciConfigAddr1,  busNo);
	    retvallong = sysInLong (pciConfigAddr2 | 		    ((deviceNo & 0x000f) << 8) | (offset & 0xfc));

	    sysOutByte (pciConfigAddr0,  0);
	    retvallong >>= (offset & 0x02) * 8;
	    retval = (UINT16)(retvallong & 0xffff);
	    retStat = 0;
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    *pData = retval;

    return (retStat);
    }

 








STATUS pciConfigInLong
    (
    int	busNo,      
    int	deviceNo,   
    int	funcNo,     
    int	offset,     
    UINT32 * pData  
    )
    {
    int		 key;
    STATUS retStat = (-1);
    UINT32 retval = 0;

     







    if ((pciLibInitStatus != 0) || ((offset & (int)0x3) > 0) )
	{
        return (retStat);
	}


    key = intLock ();				 

    switch (pciConfigMech)
	{

        case 0:
            if (pciConfigRead (busNo, deviceNo, funcNo, offset, 4,
                                (void *)&retval) == (-1))
		{
                retval = 0xffffffff;
		}
	    else
		{
		retStat = 0;
		}
            break;


	case 1:
	    sysOutLong (pciConfigAddr0,  

		          pciConfigBdfPack (busNo, deviceNo, funcNo) |
# 1396 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"
		          (offset & 0xfc) | 0x80000000);
	    retval = sysInLong (pciConfigAddr1);
	    retStat = 0;
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xf0 | (funcNo << 1));
	    sysOutByte (pciConfigAddr1,  busNo);
	    retval = sysInLong (pciConfigAddr2 | ((deviceNo & 0x000f) << 8) |
				  (offset & 0xfc));
	    sysOutByte (pciConfigAddr0,  0);
	    retStat = 0;
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    *pData = retval;

    return (retStat);
    }

 








STATUS pciConfigOutByte
    (
    int	busNo,     
    int	deviceNo,  
    int	funcNo,    
    int	offset,    
    UINT8 data     
    )
    {
    UINT32	retval;
    int		mask	= 0x000000ff;
    int		key;

    if (pciLibInitStatus != 0)			 
        return ((-1));

    key = intLock ();				 

    switch (pciConfigMech)
	{
        case 0:
            pciConfigWrite (busNo, deviceNo, funcNo, offset, 1, data);
            break;

	case 1:
	    sysOutLong (pciConfigAddr0,  

		          pciConfigBdfPack (busNo, deviceNo, funcNo) |
# 1457 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"
		          (offset & 0xfc) | 0x80000000);
	    sysOutByte ((pciConfigAddr1 + (offset & 0x3)),  data);
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xf0 | (funcNo << 1));
	    sysOutByte (pciConfigAddr1,  busNo);
	    retval = sysInLong (pciConfigAddr2 | ((deviceNo & 0x000f) << 8) |
				  (offset & 0xfc));
	    data = (data & mask) << ((offset & 0x03) * 8);
	    mask <<= (offset & 0x03) * 8;
	    retval = (retval & ~mask) | data;
	    sysOutLong ((pciConfigAddr2 | ((deviceNo & 0x000f) << 8) |
			  (offset & 0xfc)),  retval);
	    sysOutByte (pciConfigAddr0,  0);
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    return (0);
    }

 








STATUS pciConfigOutWord
    (
    int	busNo,     
    int	deviceNo,  
    int	funcNo,    
    int	offset,    
    UINT16 data    
    )
    {
    UINT32	retval;
    int		mask	= 0x0000ffff;
    int		key;

     







    if ((pciLibInitStatus != 0) || ((offset & (int)0x1) > 0) )
	{
        return ((-1));
	}

    key = intLock ();				 

    switch (pciConfigMech)
	{

        case 0:
            pciConfigWrite (busNo, deviceNo, funcNo, offset, 2, data);
            break;

	case 1:
	    sysOutLong (pciConfigAddr0,  pciConfigBdfPack (busNo, deviceNo, funcNo) |
		          (offset & 0xfc) | 0x80000000);
	    sysOutWord ((pciConfigAddr1 + (offset & 0x2)),  data);
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xf0 | (funcNo << 1));
	    sysOutByte (pciConfigAddr1,  busNo);
	    retval = sysInLong (pciConfigAddr2 | ((deviceNo & 0x000f) << 8) |
				  (offset & 0xfc));
	    data = (data & mask) << ((offset & 0x02) * 8);
	    mask <<= (offset & 0x02) * 8;
	    retval = (retval & ~mask) | data;
	    sysOutLong ((pciConfigAddr2 | ((deviceNo & 0x000f) << 8) |
			  (offset & 0xfc)),  retval);
	    sysOutByte (pciConfigAddr0,  0);
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    return (0);
    }


 








STATUS pciConfigOutLong
    (
    int	busNo,     
    int	deviceNo,  
    int	funcNo,    
    int	offset,    
    UINT32 data    
    )
    {
    int key;

     







    if ((pciLibInitStatus != 0) || ((offset & (int)0x3) > 0) )
	{
        return ((-1));
	}

    key = intLock ();				 

    switch (pciConfigMech)
	{
        case 0:
            pciConfigWrite (busNo, deviceNo, funcNo, offset, 4, data);
            break;

	case 1:
	    sysOutLong (pciConfigAddr0,  pciConfigBdfPack (busNo, deviceNo, funcNo) |
		          (offset & 0xfc) | 0x80000000);
	    sysOutLong (pciConfigAddr1,  data);
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xf0 | (funcNo << 1));
	    sysOutByte (pciConfigAddr1,  busNo);
	    sysOutLong ((pciConfigAddr2 | ((deviceNo & 0x000f) << 8) |
			  (offset & 0xfc)),  data);
	    sysOutByte (pciConfigAddr0,  0);
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    return (0);
    }


 
# 1654 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigModifyLong
    (
    int busNo,           
    int deviceNo,        
    int funcNo,          
    int offset,          
    UINT32 bitMask,      
    UINT32 data          
    )
    {
    UINT32 temp;
    STATUS stat;
    int key;

     







    if ((pciLibInitStatus != 0) || ((offset & (int)0x3) > 0) )
	{
        return ((-1));
	}

 
    key = intLock ();

    stat = pciConfigInLong (busNo, deviceNo, funcNo, offset, &temp);

    if (stat == 0)
	{
	temp = (temp & ~bitMask) | (data & bitMask);
	stat = pciConfigOutLong (busNo, deviceNo, funcNo, offset, temp);
	}

    intUnlock (key);

    return (stat);
    }


 
# 1722 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigModifyWord
    (
    int busNo,           
    int deviceNo,        
    int funcNo,          
    int offset,          
    UINT16 bitMask,      
    UINT16 data          
    )
    {
    UINT16 temp;
    STATUS stat;
    int key;

     







    if ((pciLibInitStatus != 0) || ((offset & (int)0x1) > 0) )
	{
        return ((-1));
	}

 
    key = intLock ();

    stat = pciConfigInWord (busNo, deviceNo, funcNo, offset, &temp);

    if (stat == 0)
	{
	temp = (temp & ~bitMask) | (data & bitMask);
	stat = pciConfigOutWord (busNo, deviceNo, funcNo, offset, temp);
	}

    intUnlock (key);

    return (stat);
    }



 
# 1791 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigModifyByte
    (
    int busNo,           
    int deviceNo,        
    int funcNo,          
    int offset,          
    UINT8 bitMask,       
    UINT8 data           
    )
    {
    UINT8 temp;
    STATUS stat;
    int key;

     

    if (pciLibInitStatus != 0)
	{
        return ((-1));
	}

 
    key = intLock ();

    stat = pciConfigInByte (busNo, deviceNo, funcNo, offset, &temp);

    if (stat == 0)
	{
	temp = (temp & ~bitMask) | (data & bitMask);
	stat = pciConfigOutByte (busNo, deviceNo, funcNo, offset, temp);
	}

    intUnlock (key);

    return (stat);

    }

 








STATUS pciSpecialCycle
    (
    int	busNo,      
    UINT32 message  
    )
    {
    int deviceNo	= 0x0000001f;
    int funcNo		= 0x00000007;
    int key;

    if (pciLibInitStatus != 0)			 
        return ((-1));

    key = intLock ();				 

    switch (pciConfigMech)
	{

        case 0:
            if (pciConfigSpcl != ((void *)0))
                pciConfigSpcl (busNo, message);
            break;
  
	case 1:
	    sysOutLong (pciConfigAddr0,  

		          pciConfigBdfPack (busNo, deviceNo, funcNo) |
# 1865 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"
		          0x80000000);
	    sysOutLong (pciConfigAddr1,  message);
	    break;

	case 2:
	    sysOutByte (pciConfigAddr0,  0xff);
	    sysOutByte (pciConfigAddr1,  0x00);
	    sysOutLong ((pciConfigAddr2 | ((deviceNo & 0x000f) << 8)), 
			  message);
	    sysOutByte (pciConfigAddr0,  0);
	    break;

	default:
	    break;
	}

    intUnlock (key);				 

    return (0);
    }


 
# 1902 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigForeachFunc
    (
    UINT8 bus,			     
    BOOL recurse,		     
    PCI_FOREACH_FUNC funcCheckRtn,   
    void *pArg			     
    )
    {
    int		pciLocBus;	 
    int		pciLocDevice;	 
    int		pciLocFunction;	 
    int		device;		 
    int		function;	 
    UINT	devVend;
    UINT16	pciClass;	 
    int		status;
    UINT8	btemp;
    UINT8	secBus;		 
    UINT16	hostBridge = (0x06<<8) |
			     (0x00);

     

    pciLocBus = (UINT8)bus;
    pciLocDevice = (UINT8)0;
    pciLocFunction = (UINT8)0;

     

     

    for (device = 0; device < 32; device++)
	{
	pciLocDevice = device;

	 

	for (function = 0; function < 8; function++)
	    {
	    pciLocFunction = function;

	     
	    pciConfigInLong (pciLocBus, pciLocDevice, pciLocFunction,
			     0x00, &devVend);

	     
	    if ( ((devVend & 0x0ffff) == 0xffff) || 
		 ((devVend & 0x0ffff) == 0x0000) )
		{
		if (function == 0)
		    {
		    break;	 
		    }
		else
		    {
		    continue;   
		    }
		}

	     
	    pciConfigInWord (pciLocBus, pciLocDevice, pciLocFunction,
			     0x0a, &pciClass);

	    if ( pciClass != hostBridge )
		{
	         
	        status = (*funcCheckRtn)(pciLocBus, pciLocDevice,
					pciLocFunction, pArg);
		if ( status != 0 )
		    return((-1));
		}

	    if ( recurse )
		{
		 
		if ( pciClass == ((0x06 << 8) + (0x04)) )
		    {
		    pciConfigInByte (pciLocBus, pciLocDevice, pciLocFunction,
				0x19, &secBus);
		    if ( secBus > 0 )
		        status = pciConfigForeachFunc(secBus, recurse,
						funcCheckRtn, pArg);
		    else
			status = 0;

		    if ( status != 0 )
			return((-1));
		    }
		}

	     
	    if (function == 0)
		{
		pciConfigInByte (pciLocBus, pciLocDevice, pciLocFunction,
				 0x0e, &btemp);
		if ((btemp & 0x80) == 0)
		    {
		    break;  
		    }
		}
	    }
	}

    return(0);
    }

 
# 2022 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

static STATUS pciFuncDisable
    (
    UINT	bus,		 
    UINT	device,		 
    UINT	function,	 
    void *	pArg		 
    )
    {
    int		mask;

    mask = 	0x0001 | 0x0002 |
		0x0004;

    pciConfigModifyLong (bus, device, function,
			0x04, mask, 0);

    return(0);
    }

 
# 2054 "d:/Tornado2.2/target/src/drv/pci/pciConfigLib.c"

STATUS pciConfigReset
    (
    int			startType	 
    )
    {
     
    pciConfigForeachFunc(0, 0, (PCI_FOREACH_FUNC)pciFuncDisable, ((void *)0));

    return(0);
    }




# 931 "sysLib.c" 2
# 1 "pciCfgIntStub.c" 1
 

 

 
# 15 "pciCfgIntStub.c"

 
# 61 "pciCfgIntStub.c"


 

 











 







 







 










 









 

extern STATUS 	pciIntLibInit (void);		 
extern UINT8	sysInumTbl[];			 
extern UINT32	sysInumTblNumEnt;		 


 


 







VOID sysPciIntInit (void)
    {

     

    if (pciIntLibInit () == (-1))
	{
	sprintf (sysExcMsg, "pciCfgIntStub.c: pciIntLibInit() failed\n");
	sysToMonitor (0x01);
	}
    }

 
# 157 "pciCfgIntStub.c"

int sysPciIvecToIrq 
    (
    int vector		 
    )
    {
    UINT32 irq;
    UINT32 intNum = ((int) (vector) >> 3);

     

    for (irq = (0); irq < ((0) + (16)); irq++)
	{
	if (sysInumTbl[irq] == intNum)
    	    return (irq);
	}

    return ((-1));
    }



# 749 "pciCfgIntStub.c"

# 932 "sysLib.c" 2
# 1 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c" 2

 
# 16 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"


 
# 46 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"


# 1 "d:/Tornado2.2/target/h/drv/pci/pciIntLib.h" 1
 

 

 





















STATUS pciIntLibInit	(void);
STATUS pciIntConnect	(VOIDFUNCPTR *vector, VOIDFUNCPTR routine,
			 int parameter);
STATUS pciIntDisconnect	(VOIDFUNCPTR *vector, VOIDFUNCPTR routine);

















# 49 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c" 2
# 1 "d:/Tornado2.2/target/h/dllLib.h" 1
 

 

 
# 20 "d:/Tornado2.2/target/h/dllLib.h"


# 172 "d:/Tornado2.2/target/h/dllLib.h"

# 50 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c" 2


# 1 "d:/Tornado2.2/target/h/stdlib.h" 1
 

 

 
# 37 "d:/Tornado2.2/target/h/stdlib.h"


# 186 "d:/Tornado2.2/target/h/stdlib.h"

# 53 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c" 2

 






 

















 









 













 










 

typedef struct pciIntRtn
    {
    DL_NODE	node;		 
    VOIDFUNCPTR	routine;	 
    int		parameter;	 
    } PCI_INT_RTN;

 

DL_LIST	pciIntList[(16)];	 

 

static STATUS pciIntLibInitStatus = (-1);

 
# 140 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"

STATUS pciIntLibInit (void)
    {
    int ix;

    if (pciIntLibInitStatus != (-1))
	return (pciIntLibInitStatus);

     

    for (ix = 0; ix < (sizeof (pciIntList) / sizeof ((pciIntList) [0])); ix++)
        dllInit (&pciIntList[ix]);

    return (pciIntLibInitStatus = 0);
    }

 
# 169 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"

VOID pciInt
    (
    int irq		 
    )
    {
    PCI_INT_RTN *pRtn;

    for (pRtn = (PCI_INT_RTN *)(					    (((DL_LIST *)(&pciIntList[irq]))->head)	    ); pRtn != ((void *)0);
	 pRtn = (PCI_INT_RTN *)(					    (((DL_NODE *)(&pRtn->node))->next)	    ))
	(* pRtn->routine) (pRtn->parameter);
    }

 
# 196 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"

STATUS pciIntConnect
    (
    VOIDFUNCPTR *vector,         
    VOIDFUNCPTR routine,         
    int parameter                
    )
    {
    int irq = (sysPciIvecToIrq((int)vector));
    PCI_INT_RTN *pRtn;
    int oldLevel;
    STATUS retStatus;

    if (pciIntLibInitStatus != 0)
	return (-1);

    if (irq < 0 || irq >= (16))
	return (-1);

    if ((pRtn = (PCI_INT_RTN *)malloc (sizeof (PCI_INT_RTN))) == ((void *)0))
        {
        return (-1);
        }

     

    if ( (						    (((DL_LIST *)&pciIntList[irq])->head == ((void *)0))		    ) )
        {
        do {								    extern STATUS intConnect();						    * &retStatus  = intConnect ( (vector),( pciInt), (int)( irq ) );		    } while (0);
	if (retStatus == (-1))
	    {
            return (-1);
	    }
        }

    pRtn->routine   = routine;
    pRtn->parameter = parameter;

    oldLevel = intLock ();			 
    dllAdd (&pciIntList[irq], &pRtn->node);
    intUnlock (oldLevel);			 

    retStatus = ( ((						    (((DL_LIST *)&pciIntList[irq])->head == ((void *)0))		    )) ? (-1) : 0 );
    return retStatus;
    }


 
# 260 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"

STATUS pciIntDisconnect
    (
    VOIDFUNCPTR *vector,         
    VOIDFUNCPTR routine          
    )
    {
    int irq = (sysPciIvecToIrq((int)vector));
    PCI_INT_RTN *pRtn;
    PCI_INT_RTN *pNext;
    int oldLevel;
    STATUS retStatus = (-1);

    if (pciIntLibInitStatus != 0)
	return ((-1));

    if (irq < 0 || irq >= (16))
	return (-1);

    for (pRtn = (PCI_INT_RTN *)(					    (((DL_LIST *)(&pciIntList[irq]))->head)	    ); pRtn != ((void *)0);
	 pRtn = pNext)
	{
	pNext = (PCI_INT_RTN *)(					    (((DL_NODE *)(&pRtn->node))->next)	    );

	if (pRtn->routine == routine)
	    {
	    oldLevel = intLock ();			 
	    dllRemove (&pciIntList[irq], &pRtn->node);
	    intUnlock (oldLevel);			 
	    free ((char *)pRtn);

	     

            if ( (						    (((DL_LIST *)&pciIntList[irq])->head == ((void *)0))		    ) )
	        {
		do { * &retStatus = 0; } while (0);
	        }

	    retStatus = 0;
	    }
	}

    return (retStatus);
    }

 
# 320 "d:/Tornado2.2/target/src/drv/pci/pciIntLib.c"

STATUS pciIntDisconnect2
    (
    VOIDFUNCPTR *vector,         
    VOIDFUNCPTR routine,         
    int parameter		 
    )
    {
    int irq = (sysPciIvecToIrq((int)vector));
    PCI_INT_RTN *pRtn;
    PCI_INT_RTN *pNext;
    int oldLevel;
    STATUS retStatus = (-1);

    if (pciIntLibInitStatus != 0)
	return ((-1));

    if (irq < 0 || irq >= (16))
	return (-1);

    for (pRtn = (PCI_INT_RTN *)(					    (((DL_LIST *)(&pciIntList[irq]))->head)	    ); pRtn != ((void *)0);
	 pRtn = pNext)
	{
	pNext = (PCI_INT_RTN *)(					    (((DL_NODE *)(&pRtn->node))->next)	    );

	if (pRtn->routine == routine && pRtn->parameter == parameter)
	    {
	    oldLevel = intLock ();			 
	    dllRemove (&pciIntList[irq], &pRtn->node);
	    intUnlock (oldLevel);			 
	    free ((char *)pRtn);

	     

            if ( (						    (((DL_LIST *)&pciIntList[irq])->head == ((void *)0))		    ) )
	        {
		do { * &retStatus = 0; } while (0);
	        }

	    retStatus = 0;
	    }
	}

    return retStatus;
    }

# 933 "sysLib.c" 2















# 1 "sysNet.c" 1
 

 

 







 
# 28 "sysNet.c"


 


# 1 "sysDec21x40End.c" 1
 

 

 
# 22 "sysDec21x40End.c"


 
# 52 "sysDec21x40End.c"



# 584 "sysDec21x40End.c"

# 34 "sysNet.c" 2
# 1 "sysEl3c90xEnd.c" 1
 

 

 
# 22 "sysEl3c90xEnd.c"

 
# 36 "sysEl3c90xEnd.c"



# 631 "sysEl3c90xEnd.c"

# 35 "sysNet.c" 2
# 1 "sysElt3c509End.c" 1
 

 

 
# 15 "sysElt3c509End.c"


 
# 37 "sysElt3c509End.c"



# 222 "sysElt3c509End.c"

# 36 "sysNet.c" 2
# 1 "sysFei82557End.c" 1
 
 
 

 
# 16 "sysFei82557End.c"
 
 
# 126 "sysFei82557End.c"



# 1143 "sysFei82557End.c"

# 37 "sysNet.c" 2
# 1 "sysGei82543End.c" 1
 

 

 
# 25 "sysGei82543End.c"

 
# 40 "sysGei82543End.c"



# 1474 "sysGei82543End.c"

# 38 "sysNet.c" 2
# 1 "sysLn97xEnd.c" 1
 
 
 

 
# 19 "sysLn97xEnd.c"

 
# 33 "sysLn97xEnd.c"




 




 

# 1 "d:/Tornado2.2/target/h/end.h" 1
 

 

 
# 58 "d:/Tornado2.2/target/h/end.h"
 
 
















# 1 "d:/Tornado2.2/target/h/m2Lib.h" 1
 

 
# 1 "d:/Tornado2.2/target/h/copyright_wrs.h" 1
 

# 5 "d:/Tornado2.2/target/h/m2Lib.h" 2

 
# 25 "d:/Tornado2.2/target/h/m2Lib.h"








# 1 "d:/Tornado2.2/target/h/net/if.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/if.h"

 
# 60 "d:/Tornado2.2/target/h/net/if.h"









# 1 "d:/Tornado2.2/target/h/sys/socket.h" 1
 

 

 

 
# 41 "d:/Tornado2.2/target/h/sys/socket.h"

 
# 71 "d:/Tornado2.2/target/h/sys/socket.h"














 



 








 















 














 






struct opthdr {
	long 	level;			 
	long	name;			 
	long	len;			 
};




 


struct	linger {
	int	l_onoff;		 
	int	l_linger;		 
};

 




 





































 



struct sockaddr {
	u_char	sa_len;			 
	u_char	sa_family;		 
	char	sa_data[14];		 
};

typedef struct sockaddr SOCKADDR;

 



struct sockproto {
	u_short	sp_family;		 
	u_short	sp_protocol;		 
};

 

































 










# 289 "d:/Tornado2.2/target/h/sys/socket.h"

 



















 




 



struct msghdr {
	caddr_t	msg_name;		 
	u_int	msg_namelen;		 
	struct	iovec *msg_iov;		 
	u_int	msg_iovlen;		 
	caddr_t	msg_control;		 
	u_int	msg_controllen;		 
 


	int	msg_flags;		 
};
















 





struct cmsghdr {
	u_int	cmsg_len;		 
	int	cmsg_level;		 
	int	cmsg_type;		 
 
};

 



 








 












# 70 "d:/Tornado2.2/target/h/net/if.h" 2
# 1 "d:/Tornado2.2/target/h/net/if_arp.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/if_arp.h"

 
# 49 "d:/Tornado2.2/target/h/net/if_arp.h"











 
# 70 "d:/Tornado2.2/target/h/net/if_arp.h"
struct	arphdr {
	u_short	ar_hrd;		 


	u_short	ar_pro;		 
	u_char	ar_hln;		 
	u_char	ar_pln;		 
	u_short	ar_op;		 






 









};

 


struct arpreq {
	struct	sockaddr arp_pa;		 
	struct	sockaddr arp_ha;		 
	int	arp_flags;			 
};
 

















# 71 "d:/Tornado2.2/target/h/net/if.h" 2
# 1 "d:/Tornado2.2/target/h/net/route.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/route.h"

 
# 52 "d:/Tornado2.2/target/h/net/route.h"








# 1 "d:/Tornado2.2/target/h/net/socketvar.h" 1
 

 
 
# 17 "d:/Tornado2.2/target/h/net/socketvar.h"

 
# 46 "d:/Tornado2.2/target/h/net/socketvar.h"










# 1 "d:/Tornado2.2/target/h/selectLib.h" 1
 

 

 
# 32 "d:/Tornado2.2/target/h/selectLib.h"


# 95 "d:/Tornado2.2/target/h/selectLib.h"

# 57 "d:/Tornado2.2/target/h/net/socketvar.h" 2
# 1 "d:/Tornado2.2/target/h/net/uio.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/uio.h"

 







# 102 "d:/Tornado2.2/target/h/net/uio.h"

# 58 "d:/Tornado2.2/target/h/net/socketvar.h" 2
# 1 "d:/Tornado2.2/target/h/net/mbuf.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/mbuf.h"

 
# 62 "d:/Tornado2.2/target/h/net/mbuf.h"










# 1 "d:/Tornado2.2/target/h/net/unixLib.h" 1
 

 
 
# 15 "d:/Tornado2.2/target/h/net/unixLib.h"














 

















 































            
 



extern int 	splnet (void);
extern int 	splimp (void);
extern void 	splx (int x);
extern void 	panic (char *msg);
extern void 	wakeup (SEM_ID semId);
extern void 	ksleep (SEM_ID semId);
extern char *	_netMalloc (int bufSize, UCHAR type, int canWait); 
extern void	_netFree (char * pBuf); 
extern void * 	hashinit (int 	elements, int type, u_long * hashmask);


# 107 "d:/Tornado2.2/target/h/net/unixLib.h"








# 73 "d:/Tornado2.2/target/h/net/mbuf.h" 2



# 1 "d:/Tornado2.2/target/h/netBufLib.h" 1
 

 

 
# 26 "d:/Tornado2.2/target/h/netBufLib.h"












 


















 






























 













 
 
 
 

























 











 







































 























 






 






 










 




 



 








 



 



 



 





    











                    











                    



                    








 
# 314 "d:/Tornado2.2/target/h/netBufLib.h"

typedef struct
    {
    int		mBlkNum;		 
    int		clBlkNum;		 
    char * 	memArea;		 
    int		memSize;		 
    } M_CL_CONFIG;

 







typedef struct clDesc
    {
    int		clSize;			 
    int		clNum;			 
    char *	memArea;		 
    int		memSize;		 
    } CL_DESC; 

 

typedef struct clBuff
    {
    struct clBuff *	pClNext; 	 
    } CL_BUF;

typedef CL_BUF * CL_BUF_ID; 

 

typedef struct clPool
    {
    int			clSize;		 
    int			clLg2;		 
    int			clNum; 		 
    int			clNumFree; 	 
    int			clUsage;	 
    CL_BUF_ID		pClHead;	 
    struct netPool *	pNetPool;	 
    } CL_POOL; 

typedef CL_POOL * CL_POOL_ID; 

 

typedef struct mHdr
    {
    struct mBlk *	mNext;		 
    struct mBlk *	mNextPkt;	 
    char *		mData;		 
    int			mLen;		 
    UCHAR		mType;		 
    UCHAR		mFlags;		 
    USHORT		reserved; 
    } M_BLK_HDR;

 

typedef struct	pktHdr
    {
    struct ifnet *	rcvif;		 
    int			len;		 
    } M_PKT_HDR;

typedef union clBlkList
    {
    struct clBlk * 	pClBlkNext;	 
    char * 		pClBuf;		 
    } CL_BLK_LIST;
    
 

typedef struct clBlk
    {
    CL_BLK_LIST 	clNode;		 
    UINT		clSize;		 
    int			clRefCnt;	 
    FUNCPTR		pClFreeRtn;	 
    int			clFreeArg1;	 
    int			clFreeArg2;	 
    int			clFreeArg3;	 
    struct netPool *	pNetPool;	 
    } CL_BLK;

 

typedef struct mBlk
    {
    M_BLK_HDR 	mBlkHdr; 		 
    M_PKT_HDR	mBlkPktHdr;		 
    CL_BLK *	pClBlk;			 
    } M_BLK;

 

typedef struct mbstat
    {
    ULONG	mNum;			 
    ULONG	mDrops;			 
    ULONG	mWait;			 
    ULONG	mDrain;			 
    ULONG	mTypes[256];		 
    } M_STAT;

typedef M_BLK * 	M_BLK_ID;
typedef CL_BLK *	CL_BLK_ID;
typedef struct netPool 	NET_POOL;
typedef struct poolFunc POOL_FUNC;
typedef NET_POOL * 	NET_POOL_ID;

struct	poolFunc			 
    {
     
    STATUS	(*pInitRtn) (NET_POOL_ID pNetPool, M_CL_CONFIG * pMclBlkConfig,
                             CL_DESC * pClDescTbl, int clDescTblNumEnt,
			     BOOL fromKheap);

     
    void	(*pMblkFreeRtn) (NET_POOL_ID pNetPool, M_BLK_ID pMblk);

     
    void	(*pClBlkFreeRtn) (CL_BLK_ID pClBlk);

     
    void	(*pClFreeRtn) (NET_POOL_ID pNetPool, char * pClBuf);

     
    M_BLK_ID 	(*pMblkClFreeRtn) (NET_POOL_ID pNetPool, M_BLK_ID pMblk);

     
    M_BLK_ID	(*pMblkGetRtn) (NET_POOL_ID pNetPool, int canWait, UCHAR type);

     
    CL_BLK_ID	(*pClBlkGetRtn) (NET_POOL_ID pNetPool, int canWait);
    
     
    char *	(*pClGetRtn) (NET_POOL_ID pNetPool, CL_POOL_ID pClPool);

     
    STATUS	(*pMblkClGetRtn) (NET_POOL_ID pNetPool, M_BLK_ID pMblk,
                                  int bufSize, int canWait, BOOL bestFit);

     
    CL_POOL_ID	(*pClPoolIdGetRtn) (NET_POOL_ID pNetPool, int	bufSize,
                                    BOOL bestFit);
    };

struct netPool				 
    {
    M_BLK_ID	pmBlkHead;		 
    CL_BLK_ID	pClBlkHead;		 
    int		mBlkCnt;		 
    int		mBlkFree;		 
    int		clMask;			 
    int		clLg2Max;		 
    int		clSizeMax;		 
    int		clLg2Min;		 
    int		clSizeMin;		 
    CL_POOL * 	clTbl [((16 - 6) + 1)];	 
    M_STAT *	pPoolStat;		 
    POOL_FUNC *	pFuncTbl;		 
    };

                     
                    
extern STATUS 		netBufLibInit (void);
extern STATUS 		netPoolInit (NET_POOL_ID pNetPool,
                                     M_CL_CONFIG * pMclBlkConfig,
                                     CL_DESC * pClDescTbl, int clDescTblNumEnt,
                                     POOL_FUNC * pFuncTbl);
extern STATUS		netPoolDelete (NET_POOL_ID);
extern void		netMblkFree (NET_POOL_ID pNetPool, M_BLK_ID pMblk);
extern void		netClBlkFree (NET_POOL_ID pNetPool, CL_BLK_ID pClBlk);
extern void 		netClFree (NET_POOL_ID pNetPool, UCHAR * pClBuf);
extern M_BLK_ID 	netMblkClFree (M_BLK_ID pMblk);
extern void		netMblkClChainFree (M_BLK_ID pMblk);
extern M_BLK_ID 	netMblkGet (NET_POOL_ID pNetPool, int canWait,
                                    UCHAR type);
extern CL_BLK_ID	netClBlkGet (NET_POOL_ID pNetPool, int canWait);
extern char *	 	netClusterGet (NET_POOL_ID pNetPool,
                                       CL_POOL_ID pClPool);
extern STATUS 	 	netMblkClGet (NET_POOL_ID pNetPool, M_BLK_ID pMblk,
                                      int bufSize, int canWait, BOOL bestFit);
extern M_BLK_ID 	netTupleGet (NET_POOL_ID pNetPool, int bufSize,
                                     int canWait, UCHAR type, BOOL bestFit);

extern M_BLK_ID 	netTupleGet2 (NET_POOL_ID, int, int);

extern CL_BLK_ID  	netClBlkJoin (CL_BLK_ID pClBlk, char * pClBuf,
                                      int size, FUNCPTR pFreeRtn, int arg1,
                                      int arg2, int arg3);
extern M_BLK_ID  	netMblkClJoin (M_BLK_ID pMblk, CL_BLK_ID pClBlk);
extern CL_POOL_ID 	netClPoolIdGet (NET_POOL_ID pNetPool, int bufSize,
                                        BOOL bestFit);

extern int 		netMblkToBufCopy (M_BLK_ID pMblk, char * pBuf,
                                          FUNCPTR pCopyRtn);
extern int		netMblkOffsetToBufCopy (M_BLK_ID pMblk, int offset,
                                                char * pBuf, int len,
                                                FUNCPTR	pCopyRtn);
extern M_BLK_ID 	netMblkDup (M_BLK_ID pSrcMblk, M_BLK_ID	pDestMblk);
extern M_BLK_ID 	netMblkChainDup (NET_POOL_ID pNetPool, M_BLK_ID	pMblk,
                                         int offset, int len, int canWait);












# 77 "d:/Tornado2.2/target/h/net/mbuf.h" 2





 























 



 


 













 





 





 





 





 






 








# 176 "d:/Tornado2.2/target/h/net/mbuf.h"

# 194 "d:/Tornado2.2/target/h/net/mbuf.h"

 










 








 















 

 
# 242 "d:/Tornado2.2/target/h/net/mbuf.h"




 
# 269 "d:/Tornado2.2/target/h/net/mbuf.h"
        




    
 















 

extern struct mbstat 	mbstat;			 
extern M_CL_CONFIG	mClBlkConfig;		 
extern CL_DESC 		clDescTbl [];		 
extern int		clDescTblNumEnt; 	 
extern M_CL_CONFIG	sysMclBlkConfig;	 
extern CL_DESC 		sysClDescTbl [];	 
extern int		sysClDescTblNumEnt; 	 


extern NET_POOL_ID	_pNetDpool;		 
extern NET_POOL_ID	_pNetSysPool;		 


 

extern int max_linkhdr;		 
extern int max_protohdr;	 
extern int max_hdr;		 
extern int max_datalen;		 

extern struct	mBlk *netMblkClFree(struct mBlk *);
extern struct	mBlk *m_getclr (int, UCHAR, int, BOOL);
extern struct	mBlk *m_prepend (struct mBlk *, int, int);
extern struct	mBlk *m_pullup (struct mBlk *, int);
extern void	m_adj (struct mBlk *, int);
extern void	netMblkClChainFree(struct mBlk *);
extern void 	m_cat (struct mBlk *, struct mBlk *);
extern struct 	mBlk *m_devget (char *, int, int, struct ifnet *,
				void (*copy)());
struct mBlk *	mBufClGet (int, UCHAR, register int, BOOL); 
struct mBlk * 	mHdrClGet (int, UCHAR, register int, BOOL); 

extern struct mBlk * bcopy_to_mbufs (u_char * buf, int totlen, int off0,
                                     struct ifnet * ifp, int width);
extern struct mBlk * build_cluster (u_char * buf, int totlen,
                                    struct ifnet * ifp, u_char ctype,
                                    u_char * pRefcnt, FUNCPTR freeRtn,
                                    int arg1, int arg2, int arg3);
extern int	copyFromMbufs (char * pIobuf, struct mBlk * pMbuf, int width);







# 59 "d:/Tornado2.2/target/h/net/socketvar.h" 2





 






struct socket
    {
    short	so_type;		 
    short	so_options;		 
    short	so_linger;		 
    short	so_state;		 
    caddr_t	so_pcb;			 
    struct	protosw *so_proto;	 

     



    int		so_userArg;		 
    SEM_ID	so_timeoSem;		 
    int		so_fd;			 

     
# 99 "d:/Tornado2.2/target/h/net/socketvar.h"

    struct	socket *so_head;	 
    struct	socket *so_q0;		 
    struct	socket *so_q;		 
    short	so_q0len;		 
    short	so_qlen;		 
    short	so_qlimit;		 
    short	so_timeo;		 
    u_short	so_error;		 
    short	so_pgrp;		 
    u_long	so_oobmark;		 

     

    struct	sockbuf
	{
	u_long		sb_cc;		 
	u_long		sb_hiwat;	 
	u_long		sb_mbcnt;	 
	u_long		sb_mbmax;	 
	u_long		sb_lowat;	 
	struct		mBlk *sb_mb;	 
	struct		proc *sb_sel;	 
	short		sb_timeo;	 
	short		sb_flags;	 

	SEM_ID		sb_Sem;		 
	int		sb_want;	 
	} so_rcv, so_snd;










    void	(*so_upcall) (struct socket *so, caddr_t arg, int waitf);
    caddr_t	so_upcallarg;		 
    BOOL 	selectFlag; 		 
    SEL_WAKEUP_LIST so_selWakeupList;  
    int         vsid;                  
    };






 















 



 









 



 





 







 







 







 








 















extern VOIDFUNCPTR sowakeupHook;

extern u_long	sb_max;

 


 
extern	char netio[], netcon[], netcls[];

 


extern int soo_ioctl (struct socket * so, int cmd, caddr_t data);
extern int soo_select (struct socket *so, SEL_WAKEUP_NODE *wakeupNode);
extern int soo_unselect (struct socket *so, SEL_WAKEUP_NODE *wakeupNode); 

struct mBlk;
struct sockaddr;

extern void	sbappend (struct sockbuf *sb, struct mBlk *m);
extern int	sbappendaddr (struct sockbuf *sb, struct sockaddr *asa,
	    struct mBlk *m0, struct mBlk *control);
extern int	sbappendcontrol (struct sockbuf *sb, struct mBlk *m0,
	    struct mBlk *control);
extern void	sbappendrecord (struct sockbuf *sb, struct mBlk *m0);
extern void	sbcheck (struct sockbuf *sb);
extern void	sbcompress (struct sockbuf *sb, struct mBlk *m, struct mBlk *n);
extern void	sbdrop (struct sockbuf *sb, int len);
extern void	sbdroprecord (struct sockbuf *sb);
extern void	sbflush (struct sockbuf *sb);
extern void	sbinsertoob (struct sockbuf *sb, struct mBlk *m0);
extern void	sbrelease (struct sockbuf *sb);
extern int	sbreserve (struct sockbuf *sb, u_long cc);
extern void	sbwait (struct sockbuf *sb);
extern void	sbwakeup(struct socket *so, struct sockbuf *sb,
			 SELECT_TYPE wakeupType);
extern int	sb_lock (struct sockbuf *sb);
extern int	soabort (struct socket *so);
extern int	soaccept (struct socket *so, struct mBlk *nam);
extern int	sobind (struct socket *so, struct mBlk *nam);
extern void	socantrcvmore (struct socket *so);
extern void	socantsendmore (struct socket *so);
extern int	soclose (struct socket *so);
extern int	soconnect (struct socket *so, struct mBlk *nam);
extern int	soconnect2 (struct socket *so1, struct socket *so2);
extern int	socreate (int dom, struct socket **aso, int type, int proto);
extern int	sodisconnect (struct socket *so);
extern void	sofree (struct socket *so);
extern int	sogetopt (struct socket *so, int level, int optname,
	    struct mBlk **mp);
extern void	sohasoutofband (struct socket *so);
extern void	soisconnected (struct socket *so);
extern void	soisconnecting (struct socket *so);
extern void	soisdisconnected (struct socket *so);
extern void	soisdisconnecting (struct socket *so);
extern int	solisten (struct socket *so, int backlog);
extern struct socket *
	sonewconn1 (struct socket *head, int connstatus);
extern void	soqinsque (struct socket *head, struct socket *so, int q);
extern int	soqremque (struct socket *so, int q);
extern int	soreceive (struct socket *so, struct mBlk **paddr, 
			   struct uio *pUio, struct mBlk **mp0, struct mBlk **
			   controlp, int *flagsp);
extern int	soreserve (struct socket *so, u_long sndcc, u_long rcvcc);
extern void	sorflush (struct socket *so);
extern int	sosend (struct socket *so, struct mBlk *addr, struct uio *uio,
	    struct mBlk *top, struct mBlk *control, int flags);
extern int	sosetopt (struct socket *so, int level, int optname,
	    struct mBlk *m0);
extern int	soshutdown (struct socket *so, int how);
extern void	sowakeup (struct socket *so, struct sockbuf *sb, 
			  SELECT_TYPE wakeupType);







# 61 "d:/Tornado2.2/target/h/net/route.h" 2
# 1 "d:/Tornado2.2/target/h/net/radix.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/radix.h"

 





















 



struct radix_node {
	struct	radix_mask *rn_mklist;	 
	struct	radix_node *rn_p;	 
	short	rn_b;			 
	char	rn_bmask;		 
	u_char	rn_flags;		 



	union {
		struct {			 
			caddr_t	rn_Key;	 
			caddr_t	rn_Mask;	 
			struct	radix_node *rn_Dupedkey;
		} rn_leaf;
		struct {			 
			int	rn_Off;		 
			struct	radix_node *rn_L; 
			struct	radix_node *rn_R; 
		}rn_node;
	}		rn_u;





};








 



extern struct radix_mask {
	short	rm_b;			 
	char	rm_unused;		 
	u_char	rm_flags;		 
	struct	radix_mask *rm_mklist;	 
	union	{
		caddr_t	rmu_mask;		 
		struct	radix_node *rmu_leaf;	 
	}	rm_rmu;
	int	rm_refs;		 
} *rn_mkfreelist;













struct radix_node_head {
	struct	radix_node *rnh_treetop;
	int	rnh_addrsize;		 
	int	rnh_pktsize;		 
	struct	radix_node *(*rnh_addaddr)	 
		(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
	struct	radix_node *(*rnh_addpkt)	 
		(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
	struct	radix_node *(*rnh_deladdr)	 
		(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_delpkt)	 
		(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_matchaddr)	 
		(void *v, struct radix_node_head *head);
        struct  radix_node *(*rnh_lookup)        
                (void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_matchpkt)	 
		(void *v, struct radix_node_head *head);
	int	(*rnh_walktree)			 
		(struct radix_node_head *head, int (*f)(), void *w);
	struct	radix_node rnh_nodes[3];	 
};















void	 rn_init (void);

int	 rn_inithead (struct radix_node_head **, int);
int	 rn_destroyhead (struct radix_node_head *);
int	 rn_refines (void *, void *);
int	 rn_walksubtree (struct radix_node_head *, void *, void *,
                         int (*)(), void *);
int	 rn_walktree (struct radix_node_head *, int (*)(), void *);
struct radix_node
	 *rn_addmask (void *, int, int),
	 *rn_addroute (void *, void *, struct radix_node_head *,
			struct radix_node [2]),
	 *rn_delete (void *, void *, struct radix_node_head *),
	 *rn_insert (void *, struct radix_node_head *, int *,
			struct radix_node [2]),
	 *rn_match (void *, struct radix_node_head *),
	 *rn_newpair (void *, int, struct radix_node[2]),
	 *rn_search (void *, struct radix_node *),
	 *rn_search_m (void *, struct radix_node *, void *);








# 62 "d:/Tornado2.2/target/h/net/route.h" 2






 






 




struct route
    {
    struct	rtentry *ro_rt;
    struct	sockaddr ro_dst;
    };

 



struct rt_metrics {
	u_long	rmx_locks;	 
	u_long	rmx_mtu;	 
	u_long	rmx_expire;	 
	u_long	rmx_recvpipe;	 
	u_long	rmx_sendpipe;	 
	u_long	rmx_ssthresh;	 
	u_long	rmx_rtt;	 
	u_long	rmx_rttvar;	 
	u_short	rmx_hopcount;	 
        u_short rmx_mss; 	 

         

        long 	value1;
        long 	value2;
        long 	value3;
        long 	value4;
        long 	value5;
        long 	routeTag;
        u_char  weight;
};

 






struct sockaddr_gate
    {
    u_char         gate_len;
    u_char         gate_family;
    u_char         routeProto;
    u_char         weight;
    u_long         gate_addr;
    long           value1;
    long           value2;
    long           value3;
    long           value4;
    long           value5;
    long           routeTag;
    };

 







 










struct rtentry {
	struct	radix_node rt_nodes[2];	 


	struct	sockaddr *rt_gateway;	 
	short	rt_flags;		 
	short	rt_refcnt;		 
	u_long	rt_use;			 
	struct	ifnet *rt_ifp;		 
	struct	ifaddr *rt_ifa;		 
	struct	sockaddr *rt_genmask;	 
	caddr_t	rt_llinfo;		 
	struct	rtentry *rt_gwroute;	 
        int	rt_mod;			  
	struct	rt_metrics rt_rmx;	 
        struct  rtentry *rt_parent;      
};

 



struct ortentry {
	u_long	rt_hash;		 
	struct	sockaddr rt_dst;	 
	struct	sockaddr rt_gateway;	 
	short	rt_flags;		 
	short	rt_refcnt;		 
	u_long	rt_use;			 
	struct	ifnet *rt_ifp;		 
        int	rt_mod;			 
};
























 

struct	rtstat
    {
    short	rts_badredirect;	 
    short	rts_dynamic;		 
    short	rts_newgateway;		 
    short	rts_unreach;		 
    short	rts_wildcard;		 
    };

 


struct rt_msghdr {
	u_short	rtm_msglen;	 
	u_char	rtm_version;	 
	u_char	rtm_type;	 
	u_short	rtm_index;	 
	int	rtm_flags;	 
	int	rtm_addrs;	 
	pid_t	rtm_pid;	 
	int	rtm_seq;	 
	int	rtm_errno;	 
	int	rtm_use;	 
	u_long	rtm_inits;	 
	struct	rt_metrics rtm_rmx;  
};



















# 271 "d:/Tornado2.2/target/h/net/route.h"











# 294 "d:/Tornado2.2/target/h/net/route.h"

 











 












struct rt_addrinfo {
	int	rti_addrs;
	struct	sockaddr *rti_info[8];
};

struct route_cb {
	int	ip_count;
	int	ns_count;
	int	iso_count;
	int	any_count;
};











extern	struct	rtstat	rtstat;
extern	struct	radix_node_head *rt_tables[];
extern  int	rtmodified; 




int	 route_init (void);

void	 rt_maskedcopy (struct sockaddr *,
	    struct sockaddr *, struct sockaddr *);
int	 rt_setgate (struct rtentry *,
	    struct sockaddr *, struct sockaddr *);
void	 rtable_init (void **);
void	 rtalloc (struct route *);
struct rtentry *
	 rtalloc1 (struct sockaddr *, int);
void	 rtfree (struct rtentry *);
int	 rtinit (struct ifaddr *, int, int);
int	 rtioctl (int, caddr_t);
int	 rtredirect (struct sockaddr *, struct sockaddr *,
	    struct sockaddr *, int, struct sockaddr *, struct rtentry **);
int	 rtrequest (int, struct sockaddr *,
	    struct sockaddr *, struct sockaddr *, int, struct rtentry **);







# 72 "d:/Tornado2.2/target/h/net/if.h" 2
# 1 "d:/Tornado2.2/target/h/ifLib.h" 1
 

 

 
# 17 "d:/Tornado2.2/target/h/ifLib.h"









 


extern STATUS   ifAddrAdd (char *interfaceName, char *interfaceAddress,
                           char *broadcastAddress, int subnetMask);
extern STATUS 	ifAddrSet (char *interfaceName, char *interfaceAddress);
extern STATUS 	ifAddrDelete (char *interfaceName, char *interfaceAddress);
extern STATUS 	ifAddrGet (char *interfaceName, char *interfaceAddress);
extern STATUS 	ifBroadcastSet (char *interfaceName, char *broadcastAddress);
extern STATUS 	ifBroadcastGet (char *interfaceName, char *broadcastAddress);
extern STATUS 	ifDstAddrSet (char *interfaceName, char *dstAddress);
extern STATUS 	ifDstAddrGet (char *interfaceName, char *dstAddress);
extern STATUS 	ifMaskSet (char *interfaceName, int netMask);
extern STATUS 	ifMaskGet (char *interfaceName, int *netMask);
extern STATUS 	ifFlagChange (char *interfaceName, int flags, BOOL on);
extern STATUS 	ifFlagSet (char *interfaceName, int flags);
extern STATUS 	ifFlagGet (char *interfaceName, int *flags);
extern STATUS 	ifMetricSet (char *interfaceName, int metric);
extern STATUS 	ifMetricGet (char *interfaceName, int *pMetric);
extern int 	ifRouteDelete (char *ifName, int unit);
extern struct 	ifnet *ifunit (char *ifname);
extern struct	ifnet *ifIndexToIfpNoLock (int ifIndex);
extern struct	ifnet *ifIndexToIfp (int ifIndex);
extern unsigned short	ifNameToIfIndex (char *ifname);
extern STATUS	ifIndexToIfName (unsigned short ifIndex, char *ifname);
extern STATUS	ifUnnumberedSet(char *, char *, char *, char *);
extern int 	ifAllRoutesDelete (char *, int);

# 79 "d:/Tornado2.2/target/h/ifLib.h"






# 73 "d:/Tornado2.2/target/h/net/if.h" 2





 
# 102 "d:/Tornado2.2/target/h/net/if.h"

struct	ifqueue {
	struct	mBlk *ifq_head;
	struct	mBlk *ifq_tail;
	int	ifq_len;
	int	ifq_maxlen;
	int	ifq_drops;
};

struct mBlk;
struct proc;
struct rtentry;
struct socket;
struct ether_header;

 



struct	if_data {
	 
	u_char	ifi_type;		 
	u_char	ifi_addrlen;		 
	u_char	ifi_hdrlen;		 
	u_long	ifi_mtu;		 
	u_long	ifi_metric;		 
	u_long	ifi_baudrate;		 
	 
	u_long	ifi_ipackets;		 
	u_long	ifi_ierrors;		 
	u_long	ifi_opackets;		 
	u_long	ifi_oerrors;		 
	u_long	ifi_collisions;		 
	u_long	ifi_ibytes;		 
	u_long	ifi_obytes;		 
	u_long	ifi_imcasts;		 
	u_long	ifi_omcasts;		 
	u_long	ifi_iqdrops;		 
	u_long	ifi_noproto;		 
	u_long  ifi_lastchange;		 
};

 





struct ifnet {
	char	*if_name;		 
	struct	ifnet *if_next;		 
	struct	ifaddr *if_addrlist;	 
	int	if_pcount;		 
	caddr_t	if_bpf;			 
	u_short	if_index;		 
	short	if_unit;		 
	short	if_timer;		 
	short	if_flags;		 
	struct	if_data if_data;	 
	struct	mBlk *	pInmMblk; 	 
	int	(*if_init) 
		(int unit);		 
	int	(*if_output)		 
		(struct ifnet *, struct mBlk *, struct sockaddr *, 
		 struct rtentry *);	
	int	(*if_start) 		 
    		(struct ifnet *);
	int	(*if_ioctl)		 
		(struct ifnet *, int cmd, caddr_t data);
	int	(*if_reset)		 
		(int unit);	
	int	(*if_resolve)();	 
	void	(*if_watchdog)		 
		(int unit);
	struct	ifqueue if_snd;		 
        void * 	pCookie; 		 



};







































 






 








# 245 "d:/Tornado2.2/target/h/net/if.h"








 






# 268 "d:/Tornado2.2/target/h/net/if.h"

# 283 "d:/Tornado2.2/target/h/net/if.h"

# 294 "d:/Tornado2.2/target/h/net/if.h"


# 304 "d:/Tornado2.2/target/h/net/if.h"




 





struct ifaddr {
	struct	sockaddr *ifa_addr;	 
	struct	sockaddr *ifa_dstaddr;	 

	struct	sockaddr *ifa_netmask;	 
	struct	ifnet *ifa_ifp;		 
	struct	ifaddr *ifa_next;	 
	void	(*ifa_rtrequest)();	 
	u_short	ifa_flags;		 
	short	ifa_refcnt;		 
	int	ifa_metric;		 
};


 



struct if_msghdr {
	u_short	ifm_msglen;	 
	u_char	ifm_version;	 
	u_char	ifm_type;	 
	int	ifm_addrs;	 
	int	ifm_flags;	 
	u_short	ifm_index;	 
	struct	if_data ifm_data; 
};

 



struct ifa_msghdr {
	u_short	ifam_msglen;	 
	u_char	ifam_version;	 
	u_char	ifam_type;	 
	int	ifam_addrs;	 
	int	ifam_flags;	 
	u_short	ifam_index;	 
	int	ifam_metric;	 
};

 





struct	ifreq {

	char	ifr_name[16];		 
	union {
		struct	sockaddr ifru_addr;
		struct	sockaddr ifru_dstaddr;
		struct	sockaddr ifru_broadaddr;
		short	ifru_flags;
		int	ifru_metric;
		caddr_t	ifru_data;
	} ifr_ifru;






};

struct ifaliasreq {
	char	ifra_name[16];		 
	struct	sockaddr ifra_addr;
	struct	sockaddr ifra_broadaddr;
	struct	sockaddr ifra_mask;
};

 



struct	ifmreq {

	char	ifr_name[16];		 
	int	ifr_tableLen;
	char 	*ifr_table;
};

 





struct	ifconf {
	int	ifc_len;		 
	union {
		caddr_t	ifcu_buf;
		struct	ifreq *ifcu_req;
	} ifc_ifcu;


};

 




typedef struct mtuQuery_t 
	{
	UCHAR family;
	UINT32 dstIpAddr;
	UINT32 mtu;
	} MTU_QUERY;











extern struct ifnet * 	ifnet;		 
extern struct ifqueue 	rawintrq;	 

extern STATUS		if_attach (struct ifnet *);
extern void		if_down (struct ifnet *);
extern void		if_qflush (struct ifqueue *);


extern void		if_slowtimo (void);




extern void		if_up (struct ifnet *);
extern int		ifconf (int, caddr_t);
extern void		ifinit (void);
extern int		ifioctl (struct socket *, u_long, caddr_t);
extern int		ifpromisc (struct ifnet *, int);
extern struct ifaddr *	ifa_ifwithaddr (struct sockaddr *);
extern struct ifaddr *	ifa_ifwithaf (int);
extern struct ifaddr *	ifa_ifwithdstaddr (struct sockaddr *);
extern struct ifaddr *	ifa_ifwithnet (struct sockaddr *);
extern struct ifaddr *	ifaof_ifpforaddr (struct sockaddr *, struct ifnet *);
extern struct ifaddr *	ifa_ifwithroute(int, struct sockaddr *, 
					struct sockaddr*);
extern void		ifafree (struct ifaddr *);
extern void		link_rtrequest (int, struct rtentry *,
                                        struct sockaddr *);







# 34 "d:/Tornado2.2/target/h/m2Lib.h" 2
# 1 "d:/Tornado2.2/target/h/avlLib.h" 1
 

 

 
# 15 "d:/Tornado2.2/target/h/avlLib.h"








 

typedef struct
    {
    void *  left;    
    void *  right;   
    int     height;  
    } AVL_NODE;

typedef AVL_NODE * AVL_TREE;     

typedef union
    {
    int     i;
    UINT    u;
    void *  p;
    } GENERIC_ARGUMENT;

 

void avlRebalance (AVL_NODE *** ancestors, int count);

void * avlSearch (AVL_TREE root, GENERIC_ARGUMENT key,
          int compare (void *, GENERIC_ARGUMENT));

void * avlSuccessorGet (AVL_TREE root, GENERIC_ARGUMENT key,
         int compare (void *, GENERIC_ARGUMENT)); 

void * avlPredecessorGet (AVL_TREE root, GENERIC_ARGUMENT key,
         int compare (void *, GENERIC_ARGUMENT)); 

void * avlMinimumGet (AVL_TREE root);

void * avlMaximumGet (AVL_TREE root);

STATUS avlInsert (AVL_TREE * root, void * newNode, GENERIC_ARGUMENT key,
          int compare (void *, GENERIC_ARGUMENT));

STATUS avlInsertInform (AVL_TREE * pRoot, void * pNewNode, GENERIC_ARGUMENT key,
          void ** ppKeyHolder,
          int compare (void *, GENERIC_ARGUMENT));

void * avlRemoveInsert (AVL_TREE * pRoot, void * pNewNode, GENERIC_ARGUMENT key,
          int compare (void *, GENERIC_ARGUMENT));

void * avlDelete (AVL_TREE * root, GENERIC_ARGUMENT key,
          int compare (void *, GENERIC_ARGUMENT));

STATUS avlTreeWalk(AVL_TREE * pRoot, void walkExec(AVL_TREE * nodepp));

STATUS avlTreePrint(AVL_TREE * pRoot, void printNode(void * nodep));

STATUS avlTreeErase(AVL_TREE * pRoot);

STATUS avlTreePrintErase(AVL_TREE * pRoot, void printNode(void * nodep));

 

void * avlSearchUnsigned (AVL_TREE root, UINT key);

STATUS avlInsertUnsigned (AVL_TREE * root, void * newNode);

void * avlDeleteUnsigned (AVL_TREE * root, UINT key);







# 35 "d:/Tornado2.2/target/h/m2Lib.h" 2





 





















 

 




































































































































































 




 




 



 




 

























 


















 





 





 




 








 





 




 































 



 




 






 
















 






 






 















 








                                              









 














































 

typedef struct ui64
    {
    UINT high;
    UINT low;
    } UI64;

 






 
# 515 "d:/Tornado2.2/target/h/m2Lib.h"


 
# 527 "d:/Tornado2.2/target/h/m2Lib.h"




 







 
# 549 "d:/Tornado2.2/target/h/m2Lib.h"






typedef struct
    {
    long   idLength;			 
    long   idArray [40];	 
 
    } M2_OBJECTID;

typedef struct
    {
    long           addrLength;			 
    unsigned char  phyAddress [16];    

    } M2_PHYADDR;


 







 





typedef struct
    {
    unsigned char   sysDescr     [256];
    M2_OBJECTID     sysObjectID;
    unsigned long   sysUpTime;
    unsigned char   sysContact   [256];
    unsigned char   sysName      [256];
    unsigned char   sysLocation  [256];
    long            sysServices;

    }  M2_SYSTEM;


 

typedef struct
    {
    long  ifNumber;          
    ULONG ifTableLastChange;  
    ULONG ifStackLastChange;  
    }  M2_INTERFACE;


 













typedef struct
    {
    int  	    ifIndex;			  
    char 	    ifDescr  [256];  
    long            ifType;             
    long            ifMtu;              
    unsigned long   ifSpeed;            
    M2_PHYADDR      ifPhysAddress;      
    long            ifAdminStatus;      
    long            ifOperStatus;       
    unsigned long   ifLastChange;       

    unsigned long   ifInOctets;         
    unsigned long   ifInUcastPkts;      

    unsigned long   ifInNUcastPkts;     

    unsigned long   ifInDiscards;       
    unsigned long   ifInErrors;         
    unsigned long   ifInUnknownProtos;  

    unsigned long   ifOutOctets;        
    unsigned long   ifOutUcastPkts;     

    unsigned long   ifOutNUcastPkts;    

    unsigned long   ifOutDiscards;      
    unsigned long   ifOutErrors;        

    unsigned long   ifOutQLen;          
    M2_OBJECTID     ifSpecific;         

    }  M2_INTERFACETBL;

 

typedef struct 
    {
    char         ifName [256];
    ULONG        ifInMulticastPkts;
    ULONG        ifInBroadcastPkts;
    ULONG        ifOutMulticastPkts;
    ULONG        ifOutBroadcastPkts;
    UI64         ifHCInOctets;
    UI64         ifHCInUcastPkts;
    UI64         ifHCInMulticastPkts;
    UI64         ifHCInBroadcastPkts;
    UI64         ifHCOutOctets;
    UI64         ifHCOutUcastPkts;
    UI64         ifHCOutMulticastPkts;
    UI64         ifHCOutBroadcastPkts;
    UINT         ifLinkUpDownTrapEnable;
    ULONG        ifHighSpeed;
    UINT         ifPromiscuousMode;
    UINT         ifConnectorPresent;
    char         ifAlias [256];
    ULONG        ifCounterDiscontinuityTime;
    } M2_2233TBL;

 

typedef struct M2_ID_S M2_ID;
typedef struct M2_IFSTACKTBL_S M2_IFSTACKTBL;
typedef STATUS (* M2_PKT_COUNT_RTN) (M2_ID *, UINT, UCHAR *, ULONG);
typedef STATUS (* M2_CTR_UPDATE_RTN) (M2_ID *, UINT, ULONG);
typedef STATUS (* M2_VAR_UPDATE_RTN) (M2_ID *, UINT, caddr_t);

 

typedef struct
    {
    M2_INTERFACETBL   mibIfTbl;          
    M2_2233TBL        mibXIfTbl;         
    } M2_DATA;

 

struct M2_ID_S
    {
    M2_DATA           m2Data;            
    M2_PKT_COUNT_RTN  m2PktCountRtn;     
    M2_CTR_UPDATE_RTN m2CtrUpdateRtn;    
    M2_VAR_UPDATE_RTN m2VarUpdateRtn;    
    };

 

struct M2_IFSTACKTBL_S
    {
    UINT                     index;        
    int                      status;      
    struct M2_IFSTACKTBL_S * pNextLower;  
    };

 

typedef struct M2_IFRCVADDRTBL_S 
    {
    M2_PHYADDR                 ifRcvAddrAddr; 


    int                        ifRcvAddrStatus;  
    int                        ifRcvAddrType;    
    struct M2_IFRCVADDRTBL_S * pNextEntry;       
    } M2_IFRCVADDRTBL;
    
 
    
typedef struct M2_IFINDEX_S
    {
    AVL_NODE          ifNode;         
    int               ifType;        
    int               ifIndex;       
    M2_OBJECTID       ifOid;         
    void *            pIfStats;      


    M2_IFSTACKTBL *   pNextLower;    
    M2_IFRCVADDRTBL * pRcvAddr;      

		       
		       
		       
		       
    int               (*ifIoctl) (struct socket*, u_long, caddr_t);
    STATUS            (*rcvAddrGet) (struct ifnet *, struct M2_IFINDEX_S *);
    BOOL              mibStyle;      
    } M2_IFINDEX;

 
    
typedef struct ifSetentry
    {
    unsigned int    varToSet;
    int             ifIndex;
    long            ifAdminStatus;
    UINT            ifPromiscuousMode;
    UINT            ifLinkUpDownTrapEnable;
    char            ifAlias[256];
    } IF_SETENTRY;

 




typedef struct
    {
    long            ipForwarding;
    long            ipDefaultTTL;
    unsigned long   ipInReceives;
    unsigned long   ipInHdrErrors;
    unsigned long   ipInAddrErrors;
    unsigned long   ipForwDatagrams;
    unsigned long   ipInUnknownProtos;
    unsigned long   ipInDiscards;
    unsigned long   ipInDelivers;
    unsigned long   ipOutRequests;
    unsigned long   ipOutDiscards;
    unsigned long   ipOutNoRoutes;
    long            ipReasmTimeout;
    unsigned long   ipReasmReqds;
    unsigned long   ipReasmOKs;
    unsigned long   ipReasmFails;
    unsigned long   ipFragOKs;
    unsigned long   ipFragFails;
    unsigned long   ipFragCreates;
    unsigned long   ipRoutingDiscards;

    } M2_IP;


 

typedef struct
    {
    unsigned long   ipAdEntAddr;
    long            ipAdEntIfIndex;
    unsigned long   ipAdEntNetMask;
    long            ipAdEntBcastAddr;
    long            ipAdEntReasmMaxSize;

    } M2_IPADDRTBL;

 

typedef struct
    {
    unsigned long   ipRouteDest;
    long            ipRouteIfIndex;
    long            ipRouteMetric1;
    long            ipRouteMetric2;
    long            ipRouteMetric3;
    long            ipRouteMetric4;
    unsigned long   ipRouteNextHop;
    long            ipRouteType;   
    long            ipRouteProto;
    long            ipRouteAge;
    unsigned long   ipRouteMask;
    long            ipRouteMetric5;
    M2_OBJECTID     ipRouteInfo;

    } M2_IPROUTETBL;

 






 

typedef struct
    {
    long            ipNetToMediaIfIndex;
    M2_PHYADDR 	    ipNetToMediaPhysAddress;
    unsigned long   ipNetToMediaNetAddress;
    long            ipNetToMediaType; 

    } M2_IPATRANSTBL;

 

typedef struct
    {
    unsigned long   icmpInMsgs;
    unsigned long   icmpInErrors;
    unsigned long   icmpInDestUnreachs;
    unsigned long   icmpInTimeExcds;
    unsigned long   icmpInParmProbs;
    unsigned long   icmpInSrcQuenchs;
    unsigned long   icmpInRedirects;
    unsigned long   icmpInEchos;
    unsigned long   icmpInEchoReps;
    unsigned long   icmpInTimestamps;
    unsigned long   icmpInTimestampReps;
    unsigned long   icmpInAddrMasks;
    unsigned long   icmpInAddrMaskReps;
    unsigned long   icmpOutMsgs;
    unsigned long   icmpOutErrors;
    unsigned long   icmpOutDestUnreachs;
    unsigned long   icmpOutTimeExcds;
    unsigned long   icmpOutParmProbs;
    unsigned long   icmpOutSrcQuenchs;
    unsigned long   icmpOutRedirects;
    unsigned long   icmpOutEchos;
    unsigned long   icmpOutEchoReps;
    unsigned long   icmpOutTimestamps;
    unsigned long   icmpOutTimestampReps;
    unsigned long   icmpOutAddrMasks;
    unsigned long   icmpOutAddrMaskReps;

    } M2_ICMP;


 

typedef struct 
    {
    long            tcpRtoAlgorithm;
    long            tcpRtoMin;
    long            tcpRtoMax;
    long            tcpMaxConn;
    unsigned long   tcpActiveOpens;
    unsigned long   tcpPassiveOpens;
    unsigned long   tcpAttemptFails;
    unsigned long   tcpEstabResets;
    unsigned long   tcpCurrEstab;
    unsigned long   tcpInSegs;
    unsigned long   tcpOutSegs;
    unsigned long   tcpRetransSegs;
    unsigned long   tcpInErrs;
    unsigned long   tcpOutRsts;

    } M2_TCPINFO;


 

typedef struct
    {
    long            tcpConnState;
    unsigned long   tcpConnLocalAddress;
    long            tcpConnLocalPort;
    unsigned long   tcpConnRemAddress;
    long            tcpConnRemPort;

    } M2_TCPCONNTBL;


 

typedef struct
    {
    unsigned long   udpInDatagrams;
    unsigned long   udpNoPorts;
    unsigned long   udpInErrors;
    unsigned long   udpOutDatagrams;

    } M2_UDP;

 

typedef struct
    {
    unsigned long   udpLocalAddress;
    long            udpLocalPort;

    } M2_UDPTBL;
 
typedef struct
    {
    ULONG       igmpInterfaceIfIndex; 
    ULONG       igmpInterfaceQueryInterval; 
    ULONG       igmpInterfaceStatus; 
    ULONG       igmpInterfaceVersion;
    ULONG       igmpInterfaceQuerier;
    ULONG       igmpInterfaceQueryMaxResponseTime;
    ULONG       igmpInterfaceQuerierPresentTimeout;
    ULONG       igmpInterfaceLeaveEnabled;
    ULONG       igmpInterfaceVersion1QuerierTimer;
    ULONG       igmpInterfaceWrongVersionQueries;
    ULONG       igmpInterfaceJoins;
    ULONG       igmpInterfaceLeaves;
    ULONG	igmpInterfaceGroups;
    ULONG       igmpInterfaceRobustness;
    ULONG       igmpInterfaceQuerierUpTime;
    ULONG       igmpInterfaceLastMembQueryIntvl;
    } M2_IGMP;
    
typedef struct 
    {
    ULONG       igmpCacheAddress;
    ULONG       igmpCacheIfIndex;
    ULONG       igmpCacheSelf;                
    ULONG       igmpCacheLastReporter;
    ULONG       igmpCacheUpTime;
    ULONG       igmpCacheExpiryTime;
    ULONG       igmpCacheStatus;
    ULONG       igmpCacheVersion1HostTimer;
    } M2_IGMP_CACHE;
        

    
 
 


extern STATUS m2SysInit (char *	mib2SysDescr, char * mib2SysContact,
		 char *	mib2SysLocation, M2_OBJECTID * pObjectId);

extern STATUS m2SysGroupInfoGet (M2_SYSTEM * pSysInfo);
extern STATUS m2SysGroupInfoSet (unsigned int varToSet, M2_SYSTEM * pSysInfo);
extern STATUS m2SysDelete (void);

extern M2_ID * m2IfAlloc (ULONG, UCHAR *, ULONG, ULONG, ULONG, char *, int);
extern STATUS  m2IfFree (M2_ID *);
extern STATUS  m2IfGenericPacketCount (M2_ID *, UINT, UCHAR *, ULONG);
extern STATUS  m2IfCounterUpdate (M2_ID *, UINT, ULONG);
extern STATUS  m2IfVariableUpdate (M2_ID *, UINT, caddr_t);
extern STATUS  m2IfPktCountRtnInstall (M2_ID *, M2_PKT_COUNT_RTN);
extern STATUS  m2IfCtrUpdateRtnInstall (M2_ID *, M2_CTR_UPDATE_RTN);
extern STATUS  m2IfVarUpdateRtnInstall (M2_ID *, M2_VAR_UPDATE_RTN);
extern STATUS  m2If8023PacketCount (M2_ID *, UINT, UCHAR *, ULONG);

extern STATUS m2IfInit (FUNCPTR pTrapRtn, void * pTrapArg);
extern STATUS m2IfTableUpdate (struct ifnet *, UINT,
		 int (*func) (struct socket*, u_long, caddr_t),
		 STATUS (func2) (struct ifnet*, M2_IFINDEX*));
extern STATUS m2IfGroupInfoGet (M2_INTERFACE * pIfInfo);
extern STATUS m2IfTblEntryGet (int search, void * pIfTblEntry);
extern STATUS m2IfTblEntrySet (void *);
extern STATUS m2IfStackTblUpdate (UINT lowerIndex, UINT higherIndex, int action);
extern STATUS m2IfStackEntryGet (int, int *,  M2_IFSTACKTBL *);
extern STATUS m2IfStackEntrySet (int, M2_IFSTACKTBL *);
extern STATUS m2IfRcvAddrEntryGet (int, int *, M2_IFRCVADDRTBL *);
extern STATUS m2IfRcvAddrEntrySet (int, int, M2_IFRCVADDRTBL *);
extern STATUS m2IfDelete (void);

extern STATUS m2IpInit (int maxRouteTableSize);
extern STATUS m2IpGroupInfoGet (M2_IP * pIpInfo);
extern STATUS m2IpGroupInfoSet (unsigned int varToSet, M2_IP * pIpInfo);

extern STATUS
	   m2IpAddrTblEntryGet (int search, M2_IPADDRTBL * pIpAddrTblEnry);

extern STATUS
m2IpRouteTblEntryGet (int   search, M2_IPROUTETBL * pIpRouteTblEntry);

extern STATUS
m2IpRouteTblEntrySet (int varToSet, M2_IPROUTETBL * pIpRouteTblEntry);

extern STATUS
    m2IpAtransTblEntryGet (int search, M2_IPATRANSTBL * pIpAtEntry);
extern STATUS
    m2IpAtransTblEntrySet (M2_IPATRANSTBL * pIpAtEntry);
extern STATUS m2IpDelete (void);

extern STATUS m2IcmpInit (void);
extern STATUS m2IcmpGroupInfoGet (M2_ICMP * pIcmpInfo);

extern STATUS m2TcpInit (void);
extern STATUS m2TcpGroupInfoGet (M2_TCPINFO * pTcpInfo);

extern STATUS m2TcpConnEntryGet (int search, M2_TCPCONNTBL * pTcpConnEntry);
extern STATUS m2TcpConnEntrySet (M2_TCPCONNTBL * pTcpConnEntry);

extern STATUS m2UdpInit (void);
extern STATUS m2UdpGroupInfoGet (M2_UDP * pUdpInfo);

extern STATUS m2UdpTblEntryGet (int search, M2_UDPTBL * pUdpEntry);
STATUS m2Init (char * mib2SysDescr, char * mib2SysContact, 
               char * mib2SysLocation, M2_OBJECTID * pMib2SysObjectId,
	       FUNCPTR pTrapRtn, void * pTrapArg, int maxRouteTableSize);
extern STATUS m2Delete (void);
extern STATUS m2TcpDelete (void);
extern STATUS m2UdpDelete (void);
extern STATUS m2IcmpDelete (void);
extern STATUS m2SetIfLastChange (int ifIndex);
extern STATUS m2IgmpInterfaceEntrySet(M2_IGMP *data, int varsToSet);
extern STATUS m2IgmpInterfaceEntryGet(M2_IGMP *data);
extern STATUS m2IgmpInterfaceEntryNextGet(M2_IGMP *data);
extern STATUS m2IgmpCacheEntryGet(M2_IGMP_CACHE *data);
extern STATUS m2IgmpCacheEntryNextGet(M2_IGMP_CACHE *data);
extern M2_IGMP_CACHE * igmpCacheEntry_first(void);
extern M2_IGMP_CACHE * igmpCacheEntry_next_inst(M2_IGMP_CACHE * data);
extern unsigned igmpCacheEntry_build_instance(M2_IGMP_CACHE * data, int * inst);


# 1109 "d:/Tornado2.2/target/h/m2Lib.h"











# 77 "d:/Tornado2.2/target/h/end.h" 2



# 1 "d:/Tornado2.2/target/h/net/if_llc.h" 1
 

 

 
# 39 "d:/Tornado2.2/target/h/net/if_llc.h"

 
# 50 "d:/Tornado2.2/target/h/net/if_llc.h"












 







struct llc {
	u_char	llc_dsap;
	u_char	llc_ssap;
	union {
	    struct {
		u_char control;
		u_char format_id;
		u_char u_class;
		u_char window_x2;
	    } type_u;
	    struct {
		u_char num_snd_x2;
		u_char num_rcv_x2;
	    } type_i;
	    struct {
		u_char control;
		u_char num_rcv_x2;
	    } type_s;
	    struct {
	        u_char control;
		struct frmrinfo {
			u_char rej_pdu_0;
			u_char rej_pdu_1;
			u_char frmr_control;
			u_char frmr_control_ext;
			u_char frmr_cause;
		} frmrinfo;
	    } type_frmr;
	    struct {
		u_char control;
		u_char org_code[3];
		u_short ether_type;
	    } type_snap;
	    struct {
		u_char control;
		u_char control_ext;
	    } type_raw;
	} llc_un;
};












 







 



















 






 




 
















# 81 "d:/Tornado2.2/target/h/end.h" 2





 






 






 



                                 


                                 

 







 





 












typedef struct end_err
    {
    INT32 errCode;            
    char* pMesg;              
    void* pSpare;             
    } END_ERR;
    
 
typedef struct 
    {
    NODE node;		      
    char  addr[6];	      
    long   refcount;	      
    } ETHER_MULTI; 

typedef struct 
    {
    long len;		 
    char *pTable;		 
    } MULTI_TABLE;

 

typedef struct
    {
    int query;		 
    int queryLen;	 
    char queryData[4];  
    } END_QUERY;

 







typedef struct dev_obj 
    {
    char name[8];
    int unit;
    char description[80];
    void* pDevice;		 
    } DEV_OBJ;
	
 








typedef struct llHdrInfo
    {
    int		destAddrOffset;		 
    int		destSize; 		 
    int		srcAddrOffset;		 
    int		srcSize;		 
    int		ctrlAddrOffset;		 
    int		ctrlSize;		 
    int		pktType;		 
    int		dataOffset;		 
    } LL_HDR_INFO;

 
# 213 "d:/Tornado2.2/target/h/end.h"
typedef struct end_object
    {
    NODE node;



    DEV_OBJ devObject;		 
    STATUS (*receiveRtn) ();
                                 
    struct net_protocol *outputFilter;
                                 
    void* pOutputFilterSpare;    
    BOOL attached;		 
    SEM_ID txSem;		 
    long flags;			 
    struct net_funcs *pFuncTable;	 
    M2_INTERFACETBL mib2Tbl;	 
    LIST multiList;		 
    int	nMulti;			 
    LIST protocols;		 
    int snarfCount;              
    NET_POOL_ID pNetPool;        



    M2_ID * pMib2Tbl;            
    } END_OBJ;

    
 
# 251 "d:/Tornado2.2/target/h/end.h"
typedef struct net_protocol 
    {
    NODE node;			 
    char name[32];      
    long type;			 
    BOOL nptFlag; 		 
    BOOL (*stackRcvRtn) ();
                                 
				 
    STATUS (*stackShutdownRtn) ();
                                 
				 
    STATUS (*stackTxRestartRtn) ();
                                 
    void (*stackErrorRtn) ();
                                 
    END_OBJ * pEnd; 		 
    void* pSpare;                
                                 
    void * pNptCookie; 		 
    } NET_PROTOCOL;



 








typedef struct net_funcs
    {
    STATUS (*start) (END_OBJ*);		    
    STATUS (*stop) (END_OBJ*);		    
    STATUS (*unload) (END_OBJ*);		    
    int (*ioctl) (END_OBJ*, int, caddr_t);     
    STATUS (*send) (END_OBJ* , M_BLK_ID);	    
    STATUS (*mCastAddrAdd) (END_OBJ*, char*);  
    STATUS (*mCastAddrDel) (END_OBJ*, char*);  
    STATUS (*mCastAddrGet) (END_OBJ*, MULTI_TABLE*);
                                            
    STATUS (*pollSend) (END_OBJ*, M_BLK_ID);   
    STATUS (*pollRcv) (END_OBJ*, M_BLK_ID);    
    M_BLK_ID (*formAddress) (M_BLK_ID, M_BLK_ID, M_BLK_ID, BOOL);
                                            
    STATUS (*packetDataGet) (M_BLK_ID, LL_HDR_INFO *);
                                            
    STATUS (*addrGet) (M_BLK_ID, M_BLK_ID, M_BLK_ID, M_BLK_ID, M_BLK_ID);
                                            
    int (*endBind) (void*, void*, void*, long type); 
					 
					  
    } NET_FUNCS; 

 
# 331 "d:/Tornado2.2/target/h/end.h"

# 1 "d:/Tornado2.2/target/h/ioctl.h" 1
 

 

 





# 1 "d:/Tornado2.2/target/h/sys/ioctl.h" 1
 

 

 
# 23 "d:/Tornado2.2/target/h/sys/ioctl.h"








 

 











 

 






 















# 88 "d:/Tornado2.2/target/h/sys/ioctl.h"





































 










# 12 "d:/Tornado2.2/target/h/ioctl.h" 2

# 333 "d:/Tornado2.2/target/h/end.h" 2

 







 




 




 


 


 


 







 


 


 


 




 


 



 





typedef struct end_tbl_row
    {
    NODE node;                   
    char name[8];	 
    LIST units;                  
    } END_TBL_ROW;

 


typedef struct end_tbl_entry
    {
    int unit;                                 
    END_OBJ* (*endLoadFunc) (char*, void*);          
    char* endLoadString;                      
    BOOL endLoan;                             
    void* pBSP;                               
    BOOL processed;                           
    } END_TBL_ENTRY;
    

    










# 45 "sysLn97xEnd.c" 2
# 1 "d:/Tornado2.2/target/h/drv/end/ln97xEnd.h" 1
 

 
 
 























     


# 51 "d:/Tornado2.2/target/h/drv/end/ln97xEnd.h"

 
    





 




 
























 


    
 
    




    
 

typedef struct
    {
    ULONG       rdp;             
    ULONG       rap;             
    ULONG       rst;             
    ULONG       bdp;             
    } LN_DEVICE;

 

typedef struct lnIB
    {
    ULONG       lnIBMode;	 
    UCHAR       lnIBPadr [8];    
    UCHAR       lnIBLadrf [8];   
    ULONG       lnIBRdra;        
    ULONG       lnIBTdra;        
    } LN_IB;

 

typedef struct lnRMD
    {
    ULONG       lnRMD0;          
    ULONG       lnRMD1;          
    ULONG       lnRMD2;          
    ULONG       lnRMD3;          
    } LN_RMD;

 

typedef struct lnTMD
    {
    ULONG       lnTMD0;          
    ULONG       lnTMD1;          
    ULONG       lnTMD2;          
    ULONG       lnTMD3;          
    } LN_TMD;

 




 















 






























 






 










 





 
    
typedef struct freeArgs
    {
    void * arg1;
    void * arg2;
    } FREE_ARGS;

 

typedef struct ln97xDevice
    {
    END_OBJ	endObj;			 
    LN_IB *	ib;			 
    int 	unit;			 
    int         rmdIndex;                
    int         rringSize;               
    int         rringLen;                
    LN_RMD *    pRring;                  
    int         tmdIndex;                
    int         tmdIndexC;               
    int         tringSize;               
    int         tringLen;                
    LN_TMD *    pTring;                  
    int         ivec;                    
    int         ilevel;                  
    UINT32 *	pRdp;                    
    UINT32 *	pRap;                    
    UINT32 *	pReset;                  
    UINT32 *	pBdp;                    
    UINT32      devAdrs;                 
    UINT16	csr3B;			 
    char *	pShMem;                  
    char *	memBase;                 
    char *	memAdrs;                 
    int         memSize;                 
    int         memWidth;                
    int         offset;			 
    UINT32      flags;               	 
    UINT32	pciMemBase;		 
    UINT8	enetAddr[6];		 
    CACHE_FUNCS cacheFuncs;              
    BOOL        txBlocked;               
    BOOL        txCleaning;		 
    FUNCPTR     freeRtn [128];           
    FREE_ARGS   freeData [128];		 
    CL_POOL_ID  pClPoolId;		 
    M_CL_CONFIG	mClCfg;			 
    CL_DESC	clDesc;			 
    END_ERR     lastError;               
    } LN_97X_DRV_CTRL;

 















 















 






















































 


# 370 "d:/Tornado2.2/target/h/drv/end/ln97xEnd.h"
	
 


# 385 "d:/Tornado2.2/target/h/drv/end/ln97xEnd.h"

 
    


 
    













 
    






































































extern END_OBJ * ln97xEndLoad (char * initString);
extern STATUS 	 ln97xInitParse (LN_97X_DRV_CTRL * pDrvCtrl,char * initString);













# 46 "sysLn97xEnd.c" 2


 

 



 










 






 

 











 

extern STATUS    sysMmuMapAdd (void * address, UINT len,
                               UINT initialStateMask,
                               UINT initialState);

extern END_OBJ * ln97xEndLoad (char *);


 
 
static int ln97XUnits = 0;   

 



static const char * ln97xStrDesc [] =
    {
    "AMD 79C97x PCI Enhanced Network Driver",
    "AMD Am79C970A PCnet-PCI II Enhanced Network Driver",
    "AMD Am79C971 PCnet-FAST Enhanced Network Driver",
    "AMD Am79C972 PCnet-FAST+ Enhanced Network Driver",
    "AMD Am79C973 PCnet-FAST III Enhanced Network Driver"
    };

 





 
static PCI_BOARD_RESOURCE ln97xPciResources [(8)] =
    {
    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    },

    {(-1), (-1), (-1), (0x1022), (0x2000),
     (0x10), (1), (-1), (-1),
    {(-1), (-1), (-1), (-1), (-1), (-1)}, ((void *)0)
    }
    };


 

static UINT32 sysLn97xDev2Type (UINT32, UINT32, UINT8);



 
# 208 "sysLn97xEnd.c"
END_OBJ * sysLn97xEndLoad
    (
    char *      pParamStr,    
    void *      unused        
    )
    {
    END_OBJ *   pEnd;
    char        paramStr [255];

    static const char * const paramTemplate = 
        "%d:0x%x:0x%x:0x%x:%d:%d:-1:-1:-1:0x%x:%d:0x%x:%p";


     

    PCI_BOARD_RESOURCE * const pciRsrc = ln97xPciResources;


    if (strlen (pParamStr) == 0)
        {
         



        pEnd = ln97xEndLoad (pParamStr);
        }
    else
        {
         








        int    typeIdx;    

        char * holder  = ((void *)0);
        int    endUnit = atoi (strtok_r (pParamStr, ":", &holder));


         

        if (endUnit >= ln97XUnits)
            {
             

            return ((void *)0);
            }


         

        typeIdx = (pciRsrc[endUnit].boardType);


         

        sprintf (paramStr, paramTemplate,
                 endUnit,                      
                 (-1),      
                 pciRsrc[endUnit].bar[0],      
                 (0),           
                 pciRsrc[endUnit].irqvec,      
                 pciRsrc[endUnit].irq,         
                 (0),             
                 (0),             
                 (0),             
                 &ln97xStrDesc[typeIdx]        
                );

        if ((pEnd = ln97xEndLoad (paramStr)) == (END_OBJ *) ((void *)0))
            {
            printf ("Error sysLn97xEndLoad: device failed.\n");
            }
        }

    return (pEnd);
    }

 
# 345 "sysLn97xEnd.c"
static UINT32 sysLn97xDev2Type
    (
    UINT32 vendorId,     
    UINT32 deviceId,     
    UINT8  revisionId    
    )
    {
    if ((vendorId == (0x1022)) &&
        (deviceId == (0x2000)))
        {
         



        if ((revisionId & (0x10)) ||
            (revisionId & (0x20)) ||
            (revisionId & (0x30)) ||
            (revisionId & (0x40)))
            {
             

            return (UINT32)(revisionId >> 4);
            }
        }

    return ((-1));
    }

 
# 394 "sysLn97xEnd.c"
STATUS sysLan97xPciInit
    (
    UINT32  pciBus,            
    UINT32  pciDevice,         
    UINT32  pciFunc,           
    UINT32  vendorId,          
    UINT32  deviceId,          
    UINT8   revisionId         
    )
    {
    UINT32  boardType;         

    UINT32  ioBase;            
    UINT32  memIo32;           
    UINT8   irq;               


     

    if (ln97XUnits >= (8))
        {
        return ((-1));
        }

    if ((boardType = sysLn97xDev2Type (vendorId, deviceId, revisionId))
        == (-1))
        {
        return ((-1));
        }


    pciConfigInLong  (pciBus, pciDevice, pciFunc,
                      0x10, &ioBase);
    pciConfigInLong  (pciBus, pciDevice, pciFunc,
                      0x14, &memIo32);

    memIo32 &=  ~0xf;
    ioBase  &=  ~0x3;

     

    if (sysMmuMapAdd ((void *)(memIo32 & (~(4096 - 1))),
        (4096), 0x03 | 0x0c | 0x30, 0x01 | 0x04 | 0x00) == (-1))
        {
        return ((-1));
        }


     

    pciConfigInByte (pciBus, pciDevice, pciFunc,
                     0x3c, &irq);


     

    ln97xPciResources[ln97XUnits].bar[0]     = ioBase;
    ln97xPciResources[ln97XUnits].bar[1]     = memIo32;
    ln97xPciResources[ln97XUnits].irq        = irq;
    ln97xPciResources[ln97XUnits].irqvec     = (sysInumTbl[(int)irq]);

    ln97xPciResources[ln97XUnits].vendorID   = vendorId;
    ln97xPciResources[ln97XUnits].deviceID   = deviceId;
    ln97xPciResources[ln97XUnits].revisionID = revisionId;
    ln97xPciResources[ln97XUnits].boardType  = boardType;

     

    pciConfigOutWord (pciBus, pciDevice, pciFunc, 0x04,
                      0x0002 | 0x0001 |
                      0x0004);

     

    pciConfigOutByte (pciBus, pciDevice, pciFunc, 0x43,
                      0x00);


    ++ln97XUnits;   

    return (0);
    }

 
# 486 "sysLn97xEnd.c"
STATUS sysLan97xIntEnable
    (
    int level            
    )
    {
    return (sysIntEnablePIC (level));
    }

 
# 503 "sysLn97xEnd.c"
STATUS sysLan97xIntDisable
    (
    int level            
    )
    {
    return (sysIntDisablePIC (level));
    }

 
# 538 "sysLn97xEnd.c"
STATUS sysLan97xEnetAddrGet
    (
    LN_97X_DRV_CTRL *  pDrvCtrl,    
    char *             enetAdrs
    )
    {
    char          aprom [32];   

    int           numBytes = (32 >> 1);
    register int  ix;


     

    UINT8 * const ioaddr = (UINT8 * const)(pDrvCtrl->devAdrs);


     

    if (pDrvCtrl->flags & 0x100)
        {
        for (ix = 0; ix < numBytes; ++ix)
            {
            aprom[ix] = *(ioaddr + ix);
            }
        }
    else
        {
        for (ix = 0; ix < numBytes; ++ix)
            {
            aprom[ix] = sysInByte ((int)(ioaddr + ix));
            }
        }


     

    if ((aprom [0xe] != 'W') || (aprom [0xf] != 'W'))
        {
        logMsg ("sysLn97xEnetAddrGet:  W's not stored in aprom\n",
                0, 1, 2, 3, 4, 5);

        return (-1);
        }

    bcopy (aprom, enetAdrs, 6);

    return (0);
    }



# 39 "sysNet.c" 2
# 1 "sysNe2000End.c" 1
 
 
 
 
 
# 14 "sysNe2000End.c"


 
# 37 "sysNe2000End.c"



# 159 "sysNe2000End.c"

# 40 "sysNet.c" 2
# 1 "sysUltraEnd.c" 1
 

 

 








 
# 34 "sysUltraEnd.c"



# 186 "sysUltraEnd.c"

# 41 "sysNet.c" 2










 

typedef STATUS (* INIT_FUNCPTR) (UINT32, UINT32, UINT32, UINT32, UINT32, UINT8);

typedef struct vendIdDesc                
    {
    UINT32              vendorId;        
    INIT_FUNCPTR        pPciInitRtn;     

    } VEND_ID_DESC;


 

 



static VEND_ID_DESC vendorIdEnet [] =
    {
    



    
    {(0x1022),      sysLan97xPciInit},
    

    



    



    



    {0xffffffff, ((void *)0)}         
    };



 
# 119 "sysNet.c"
STATUS sysNetPciInit
    (
    UINT32              pciBus,         
    UINT32              pciDevice,      
    UINT32              pciFunc,        
    void *              pArg            
    )
    {
    UINT32              classCodeReg;   


    pciConfigInLong (pciBus, pciDevice, pciFunc, 0x08,
                     &classCodeReg);

    if (((classCodeReg >> 8) & 0x00ffffff) == ((0x02 << 16) | ((0x00) << 8)))
        {
        UINT32        vendorId;     
        UINT32        deviceId;     
        UINT8         revisionId;   
        int           i;            


         

        pciConfigInLong (pciBus, pciDevice, pciFunc,
                         0x00, &vendorId);

         

        pciConfigInByte (pciBus, pciDevice, pciFunc,
                         0x08, &revisionId);

         

        deviceId = ((vendorId >> 16) & 0x0000ffff);
        vendorId = (vendorId & 0x0000ffff);

         

        for (i = 0; (vendorIdEnet[i].pPciInitRtn) != ((void *)0); ++i)
            {
            if ((vendorId == vendorIdEnet[i].vendorId) &&
                (*(vendorIdEnet[i].pPciInitRtn))
                (pciBus, pciDevice, pciFunc,
                 vendorId, deviceId, revisionId) == 0)
                {
                 

                return 0;
                }
            }
        }

    return (0);
    }





# 233 "sysNet.c"


# 949 "sysLib.c" 2






 





 








char *sysModel (void)

    {





    return ("PC PENTIUM");







    }

 
# 997 "sysLib.c"

char * sysBspRev (void)
    {
    return ("1.2" "/2");
    }



 
# 1023 "sysLib.c"

void sysHwInit0 (void)
    {
    (void) sysCpuProbe ();
    }



 
# 1042 "sysLib.c"

void sysHwInit (void)
    {
    PHYS_MEM_DESC *pMmu;
    int ix = 0;




     
    
    pentiumMsrInit ();


# 1071 "sysLib.c"










     

    pentiumMcaEnable (1);


# 1100 "sysLib.c"



     

    pMmu = &sysPhysMemDesc[0];

    for (ix = 0; ix < (sizeof (sysPhysMemDesc) / sizeof ((sysPhysMemDesc) [0])); ix++) 
        if (pMmu->virtualAddr != (void *) -1)
            pMmu++;
        else
            break;

    sysPhysMemDescNumEnt = ix;

     



    pciConfigLibInit (1, 0x0cf8, 0x0cfc, (-1));
    sysPciIntInit ();			 



     

    sysIntInitPIC ();		 
    intEoiGet = sysIntEoiGet;	 

     




# 1142 "sysLib.c"

     










     

     pciConfigForeachFunc (0, 1, (PCI_FOREACH_FUNC) sysNetPciInit, ((void *)0));









     
    

# 1207 "sysLib.c"










     

    sysSerialHwInit ();       










     



    vxPowerModeSet((0x4));


    }

 
# 1248 "sysLib.c"

void sysHwInit2 (void)

    {



     








 
     



 
    if ((UINT32)(&end) < 0x100000)
        {
         
 
        if ((UINT32)(memTopPhys) >= (0x00200000 + (0x00200000)))
            {
            memAddToPool ((char *)memTopPhys - (0x00200000),
                          (0x00200000));
            }
        }


 
     









    (void)intConnect (((VOIDFUNCPTR *) (((sysInumTbl[(int)0x00])) << 3)), sysClkInt, 0);
    (void)intConnect (((VOIDFUNCPTR *) (((sysInumTbl[(int)0x08])) << 3)), sysAuxClkInt, 0);


       

    sysSerialHwInit2();

       







    (void)intConnect (((VOIDFUNCPTR *) (((sysInumTbl[(int)0x07])) << 3)), sysStrayInt, 0);
    (void)intConnect (((VOIDFUNCPTR *) (((sysInumTbl[(int)0x0f])) << 3)), 
		      sysStrayInt, 0);




     

    (void) intConnect (((VOIDFUNCPTR *) (((sysInumTbl[(int)0x01])) << 3)), kbdIntr, 0);




# 1333 "sysLib.c"
    }



 
# 1350 "sysLib.c"
__inline__ static void WRITE_MEMORY_TEST_PATTERN
    (
    int * pTestAddr,
    int * pSaveAddr
    )
    {
    pSaveAddr[0] = pTestAddr[0];
    pSaveAddr[1] = pTestAddr[1];
    pSaveAddr[2] = pTestAddr[2];

    pTestAddr[0] = (0x57696E64);
    pTestAddr[1] = (0x52697665);
    pTestAddr[2] = (0x72537973);

    cacheFlush (DATA_CACHE, pTestAddr, 16);
    }

 
# 1379 "sysLib.c"
__inline__ static void RESTORE_MEMORY_TEST_ADDRS
    (
    int *       pTestAddr,
    const int * pSaveAddr
    )
    {
    pTestAddr[0] = pSaveAddr[0];
    pTestAddr[1] = pSaveAddr[1];
    pTestAddr[2] = pSaveAddr[2];
    }


 
# 1441 "sysLib.c"
char * sysPhysMemTop (void)
    {
    PHYS_MEM_DESC * pMmu;        
    char            gdtr[6];     

    BOOL            found = 0;


    if (memTopPhys != ((void *)0))
        {
        return (memTopPhys);
        }



    {
     



    const UINT32 pageSize = 0x1000;

     




    UINT8 * pPage = (UINT8 *) (((int) (((UINT32)(&end) > 0x100000) ?
                          (UINT32)(&end) : (0x100000)) + ( pageSize - 1)) & ~( pageSize - 1));


     





    const UINT32 pageNoUsed  = ((UINT32) pPage / pageSize);
    const UINT32 pageNoTotal = (((0x100000000ull)) / pageSize) - pageNoUsed;
    UINT32       delta       = (((pageNoTotal) + 1) >> 1);

    int temp[4];


     

    for (pPage += (pageSize * delta); delta != 0; delta >>= 1)
        {
        WRITE_MEMORY_TEST_PATTERN ((int *) pPage, &temp[0]);

        if (*((int *) pPage) != (0x57696E64))
            {
             






            UINT8 * pPrevPage = (UINT8 *)((UINT32) pPage - pageSize);

            WRITE_MEMORY_TEST_PATTERN ((int *) pPrevPage, &temp[0]);

            if (*((int *) pPrevPage) == (0x57696E64))
                {
                RESTORE_MEMORY_TEST_ADDRS ((int *) pPrevPage, &temp[0]);

                memTopPhys = pPage;
                found      = 1;
                break;
                }

            pPage -= (pageSize * (((delta) + 1) >> 1));
            }
        else
            {
             






            UINT8 * pNextPage = (UINT8 *)((UINT32) pPage + pageSize);

            RESTORE_MEMORY_TEST_ADDRS ((int *) pPage, &temp[0]);

            WRITE_MEMORY_TEST_PATTERN ((int *) pNextPage, &temp[0]);

            if (*((int *) pNextPage) != (0x57696E64))
                {
                memTopPhys = pNextPage;
                found      = 1;
                break;
                }

            RESTORE_MEMORY_TEST_ADDRS ((int *) pNextPage, &temp[0]);

            pPage += (pageSize * (((delta) + 1) >> 1));
            }
        }
    }



    if (!found)
        {
        memTopPhys = (char *)((0x00100000) + ((0x00800000) - (0x00100000)));
        }

     

    bcopy ((char *)sysGdt, (char *)pSysGdt, 5 * sizeof(GDT));
    *(short *)&gdtr[0]	= 5 * sizeof(GDT) - 1;
    *(int *)&gdtr[2]	= (int)pSysGdt;

 







# 1579 "sysLib.c"

     

    sysLoadGdt (gdtr);


# 1600 "sysLib.c"

     

    (UINT32)memTopPhys &= ~(4096 - 1);	 


    pMmu = &sysPhysMemDesc[4];		 
    pMmu->len = (UINT32) memTopPhys - (UINT32) pMmu->physicalAddr;





    return (memTopPhys);
    }

 
# 1629 "sysLib.c"

char * sysMemTop (void)
    {
    static char * memTop = ((void *)0);

    if (memTop == ((void *)0))
        {
        memTop = sysPhysMemTop () - (0);

        if ((UINT32)(&end) < 0x100000)		 
            memTop = (char *)0x9d000;	 
        else if ((UINT32)(&end) < (0x00308000))	 
            memTop = (char *)((0x00308000) & 0xfff00000);
        }

    return (memTop);
    }

 
# 1658 "sysLib.c"

STATUS sysToMonitor
    (
    int startType    
    )
    {
    FUNCPTR pEntry;
    INT16 * pDst;
    
    ((vmLibInfo.pVmEnableRtn == ((void *)0)) ?     ((-1)) :     ((*vmLibInfo.pVmEnableRtn) (0)));			 




    pentiumMsrInit ();			 



     

    if ((UINT32)(&end) > (0x00308000))
	{
	pDst = (short *)(0x00108000);	 
	pEntry = (FUNCPTR)((0x00108000) + 0x10);
	}
    else
	{
	pDst = (short *)(0x00308000);	 
	pEntry = (FUNCPTR)((0x00308000) + 0x20);
	}


# 1710 "sysLib.c"

     






# 1744 "sysLib.c"


# 1758 "sysLib.c"


    if ((sysWarmType == 1) || (sysWarmType == 2) || 
	(sysWarmType == 3))
	{
	u_char * pChar;

         

        if (((void *)0) != dosFsVolDescGet("/vxboot/", &pChar))
            {
            goto bootDevExists;  
            }
        }



    if (sysWarmType == 1)
	{
	extern int dosFsDrvNum;

        fdDrv ((sysInumTbl[(int)0x06]), 0x06);	 
	if (dosFsDrvNum == (-1))
    	    dosFsInit (20);	 

	if (usrFdConfig (sysWarmFdDrive, sysWarmFdType, "/vxboot/") == (-1))
	    {
	    printErr ("usrFdConfig failed.\n");
	    return ((-1));
	    }
	}



    if (sysWarmType == 2)
	{
	ATA_RESOURCE *pAtaResource  = &ataResources[sysWarmAtaCtrl];
	extern int dosFsDrvNum;

        if (ataDrv (sysWarmAtaCtrl, pAtaResource->drives,
	    pAtaResource->intVector, pAtaResource->intLevel,
	    pAtaResource->configType, pAtaResource->semTimeout,
	    pAtaResource->wdgTimeout) == (-1))	 
	    {
	    printErr ("Could not initialize.\n");
	    return ((-1));
	    }
	if (dosFsDrvNum == (-1))
    	    dosFsInit (20);         

	if ((-1) == usrAtaConfig (sysWarmAtaCtrl, 
                                   sysWarmAtaDrive, "/vxboot/"))
	    {
	    printErr ("usrAtaConfig failed.\n");
	    return ((-1));
	    }
	}



# 1833 "sysLib.c"



bootDevExists:   

    if ((sysWarmType == 1) || (sysWarmType == 2) || 
        (sysWarmType == 3))
        {
        int  fd;
        BOOL hasAoutHdr = 0;

        if ((fd = open ("/vxboot/bootrom.sys", 0, 0644)) == (-1))
            {
            printErr ("Error opening file \"%s\", trying \"%s\" ... \n",
                      "/vxboot/bootrom.sys", "/vxboot/bootrom.dat");

            if ((fd = open ("/vxboot/bootrom.dat", 0, 0644)) == (-1))
                {
                printErr ("Error opening file \"%s\"\n", "/vxboot/bootrom.dat");
                return ((-1));
                }
            if (read (fd, (char *) pDst, 0x20) == (-1))  
                {
                printErr ("Error reading file \"%s\"\n", "/vxboot/bootrom.dat");
                return ((-1));
                }

            hasAoutHdr = 1;
            }

         

        if (read (fd, (char *) pDst, 0x98000) == (-1))
            {
            printErr ("Error reading file \"%s\"\n",
                      hasAoutHdr ?  "/vxboot/bootrom.dat" : "/vxboot/bootrom.sys");

            return ((-1));
            }


         

        if (1 == sysWarmType)
            {
            sysOutByte(0x3f2,(0x04 | 0x08));
            sysDelay ();
            }


	goto sysToMonitorJump;		 
	}


     

    {
    intLock ();





    sysClkDisable ();

    sysWait ();
    sysOutByte (0x64, 0xfe);	 
    sysWait ();
    sysOutByte (0x64, 0xff);	 

    sysReboot ();			 

    return (0);	 
    }

     

sysToMonitorJump:		 

    sysClkDisable ();		 
    sysIntLock ();		 


# 1927 "sysLib.c"

    (*pEntry) (startType);

    return (0);	 
    }

 
# 1943 "sysLib.c"

static void sysIntInitPIC (void)
    {


# 2007 "sysLib.c"
    i8259Init ();

    }

 
# 2021 "sysLib.c"

VOID sysIntLock (void)

    {
    INT32 oldLevel = intLock ();	 








    i8259IntLock ();


    intUnlock (oldLevel);		 
    }

 
# 2050 "sysLib.c"

VOID sysIntUnlock (void)

    {
    INT32 oldLevel = intLock ();	 








    i8259IntUnlock ();


    intUnlock (oldLevel);		 
    }

 
# 2079 "sysLib.c"

STATUS sysIntDisablePIC
    (
    int irqNo		 
    )
    {






    return (i8259IntDisable (irqNo));

    }

 
# 2105 "sysLib.c"

STATUS sysIntEnablePIC
    (
    int irqNo		 
    )
    {






    return (i8259IntEnable (irqNo));

    }

 
# 2133 "sysLib.c"

static void sysIntEoiGet
    (
    VOIDFUNCPTR * vector,	 
    VOIDFUNCPTR * routineBoi,	 
    int * parameterBoi,		 
    VOIDFUNCPTR * routineEoi,	 
    int * parameterEoi		 
    )
    {
    int intNum = ((int) (vector) >> 3);
    int irqNo;

     

    *routineBoi   = ((void *)0);
    *parameterBoi = 0;

     

    for (irqNo = 0; irqNo < sysInumTblNumEnt; irqNo++)
	{
	if (sysInumTbl[irqNo] == intNum)
	    break;
	}

    *parameterEoi = irqNo;	 


# 2174 "sysLib.c"


# 2187 "sysLib.c"

     

    *parameterBoi = irqNo;
    *parameterEoi = irqNo;

     

    if (irqNo == 0)			 
	{







        *routineBoi   = ((void *)0);

	}
    else if ((irqNo == 0x07) || 
	     (irqNo == 0x0f))
	{
        *routineBoi   = i8259IntBoi;
	}

     

    if (irqNo == 0)			 
	{






        *routineEoi   = i8259IntEoiMaster;

	}
    else if (irqNo < 8)			 
	{



        *routineEoi   = i8259IntEoiMaster;

	}
    else				 
	{



        *routineEoi   = i8259IntEoiSlaveNfnm;

	}


    }

 
# 2259 "sysLib.c"

int sysIntLevel 
    (
    int arg		 
    )
    {
    UINT32 * pStack;
    UCHAR * pInst;
    INT32 ix;
    INT32 irqNo = sysInumTblNumEnt;  

    pStack = &arg;		 
    pStack += 3;		 

     





    for (ix = 0; ix < 10; ix++, pStack++)
	{
	pInst = (UCHAR *)*pStack;		 
	if ((*pInst == 0x50) && 		 
	    ((*(int *)(pInst - 4) + (int)pInst) == (int)intEnt))
	    {
    	    irqNo = *(int *)(pInst + 24);	 
	    break;
	    }
	}

    return (irqNo);
    }

 
# 2304 "sysLib.c"

int sysProcNumGet (void)
    {
    return (sysProcNum);
    }

 
# 2323 "sysLib.c"

void sysProcNumSet
    (
    int procNum		 
    )
    {
    sysProcNum = procNum;
    }

 
# 2341 "sysLib.c"

void sysDelay (void)
    {
    char ix;

    ix = sysInByte (0x84);	 
    }

 






static void sysStrayInt (void)
    {
    sysStrayIntCount++;
    }

   
# 2385 "sysLib.c"

STATUS sysMmuMapAdd 
    (
    void * address,            
    UINT   length,             
    UINT   initialStateMask,   
    UINT   initialState        
    )
    {
    STATUS result = 0;

    PHYS_MEM_DESC * const pMmu = &sysPhysMemDesc[sysPhysMemDescNumEnt];


    if (pMmu->virtualAddr != (void *)  -1)
        {
        result = (-1);
        }
    else
        {
        address = (void *)(((UINT32) address / 4096) * 4096);

        if ((length % 4096) != 0)
            length = (length / 4096 + 1) * 4096;

        pMmu->virtualAddr	= address;
        pMmu->physicalAddr	= address;
        pMmu->len		= length;
        pMmu->initialStateMask	= initialStateMask;
        pMmu->initialState	= initialState;
        sysPhysMemDescNumEnt	+= 1;
        }

    return (result);
    }
