/* evtLogLib.c - event logging library */

/* Copyright 1994-1998 Wind River Systems, Inc. */
#include "copyright_wrs.h"

/*
modification history
--------------------
03m,14aug98,cth  removed MEM_ROUND_UP from evtLogPoint
03m,10aug98,pr   added i960 function pointers to evtLogFuncBind
03l,30jul98,cjtc removed logMsg EVTLOG_RESERVE_BUFF_SPACE macros which resulted
		 in stack corruption of the calling task (SPR 21993)
03k,13may98,pr   modified logMsg content
03j,12may98,pr   added logMsg and stop windview if buffer is full
03i,17apr98,cth  removed function evtHeaderLog
03h,15apr98,cth  added binding of _func_evtLogReserveTaskName
03g,10apr98,cjtc architecture port for i960 processors.
		 fixed bug in evtLogT0_noInt in which timestamp was written to
		 the event buffer before it was read.
		 Removed unused local variable "level" from evtLogT0_noInt
03f,09apr98,pr   added evtLogT0_noInt declaration
03e,08apr98,pr   modified evtLogO to be of general use. Added evtLogT0_noInt
03d,06apr98,nps  68k family nows shares portable code.
03c,18mar98,nps  fixed check for 'thin' mode when creating header.
03b,17feb98,dvs  added events for memory instrumentation in evtLogO and 
	    pr	 fixed evtLogO buffer size.
03a,03feb98,cth  changed evtBufferId from static to global
02z,27jan98,cth  added evtObjLogFuncBind, evtLogFuncBind, evtBufferBind and
		 evtHeaderLog, updated copyright
02y,25jan98,pr   changed size in evtLogT1_noTS
02x,22jan98,pr   fixed evtsched
02w,18dec97,cth  changed include buffer.h to wvBufferP.h, changed tmpBufId to
		 evtBufferId
02v,16nov97,cth  removed evtBuf and rBuff references 
		 changed buffer writes to use generic WV2.0 buffers
02u,22oct97,pr   fixed EVTLOG_RESERVE_BUFF_SPACE_L for evtLogT1_noTS
02t,21oct97,nps  use modified rBuff API
02s,18aug97,nps  fixed bug in evtLogM1
02r,20jul97,nps  added ring buffer support
02q,24jun97,pr   commented the evtLogTIsOn for evtLogPoint
02p,08jul96,pr   added evtLogT1_noTS for PPC
02o,06dec94,rdc  fixed bogus intlocks that should have been unlocks.
02n,08nov94,rdc  added 960 kernel instrumentation routines.
02m,02nov94,rdc  added argument to evtLogString to support lockCount param
		 in EVENT_TASKNAME.
02l,02nov94,rdc  unlocked interrupts before returning because of errors.
02k,27may94,smb  now use alignment macros to store data in buffer.
02j,23may94,pme  removed taskIdLogin for EVENT_WIND_EXIT_NODISPATCH
		 made evtsched equivalent to the 68k assembly version
01i,05may94,smb  sparc porting
01h,16mar94,smb  removed EVENT_WIND_EXIT_IDLENOT
		 level 1 optimisations.
01g,22feb94,smb  changed typedef EVENT_TYPE to event_t (SPR #3064)
01f,24jan94,smb  fixed return values for eventPoint()
01e,19jan94,smb  event buffer fix SPR #2904
01d,14jan94,c_s  evtLogOInt now handles EVENT_SIGWRAPPER correctly (SPR #2883).
01c,04jan94,c_s  evtLogPoint now validates the user event ID correctly. 
		   SPR #2724.
01b,30dec93,c_s  evtLogPoint now uses memcpy (), rather than strncpy (), to 
		   transfer the user's buffer of data for user-defined events
		   to the logging area.  SPR #2799.
01a,10dec93,smb  created
*/

/*
DESCRIPTION
This library provides routines which log events to the buffer for different
types of events generated by the instrumented code.

INCLUDE FILES: 

SEE ALSO: 
NOMANUAL
*/

#include "vxWorks.h"
#include "intLib.h"
#include "logLib.h"
#include "wvLib.h"
#include "string.h"
#include "taskLib.h"
#include "sysLib.h"

#include "private/taskLibP.h"
#include "private/eventP.h"
#include "private/kernelLibP.h"
#include "private/workQLibP.h"
#include "private/wvBufferP.h"
#include "private/evtLogLibP.h"
#include "private/kernelLibP.h"


/* optimized version no longer used for 680X0 */

#define evtLogLib_PORTABLE

/* defines */

#define MAX_WV_TASKS    500        /* should be the same MAX_DSP_TASKS */

#define EVTLOG_RESERVE_BUFF_SPACE(EVENT_SIZE)                     \
eventBase = (event_t *) evtBufferId->writeRtn (evtBufferId,NULL,EVENT_SIZE);  \
                                                                  \
if (!eventBase)                                                   \
    {                                                             \
    wvEvtLogStop();						  \
    intUnlock (level);                                            \
    return;                                                       \
    }

#define EVTLOG_RESERVE_BUFF_SPACE_STAT(EVENT_SIZE)                \
eventBase = (event_t *) evtBufferId->writeRtn (evtBufferId,NULL,EVENT_SIZE);  \
                                                                  \
if (!eventBase)                                                   \
    {                                                             \
    wvEvtLogStop();						  \
    intUnlock (level);                                            \
    return (ERROR);                                               \
    }

#define EVTLOG_RESERVE_BUFF_SPACE_L(EVENT_SIZE)                   \
eventBase = (event_t *) evtBufferId->writeRtn (evtBufferId,NULL,EVENT_SIZE);  \
                                                                  \
if (!eventBase)                                                   \
    {                                                             \
    wvEvtLogStop();						  \
    return;                                                       \
    }



/* globals */

IMPORT	Q_HEAD	readyQHead;	/* multi-way ready queue head */

/* local */

BUFFER_ID evtBufferId;             /* event buffer identifier */


/* forward declarations */

void evtLogTasks (void);
void evtLogOInt  (event_t  action, int nParam, int param1, int param2, 
				int param3, int param4, int param5);
void evtLogO     (event_t action, int nParam, int param1, int param2, 
				int param3, int param4, int param5);
void evtLogString (event_t action, int arg1, int arg2, int arg3,
				int addrId, const char *string);
int evtLogPoint  (event_t action, void * addr, size_t nbytes, 
				char * buffer);
void evtsched ( event_t action, int arg1, int arg2);

void evtLogM0  (event_t action);
void evtLogM1  (event_t action, int param1);
void evtLogM2  (event_t action, int param1, int param2);
void evtLogM3  (event_t action, int param1, int param2, int param3);
void evtLogT0  (event_t action);
void evtLogT0_noInt  (event_t action);
void evtLogT1  (event_t action, int param);

#if CPU_FAMILY==PPC

void evtLogT1_noTS  (event_t action, int param);

#endif /* CPU_FAMILY==PPC */

#if CPU_FAMILY==I960

void windInst1 (void);
void windInstDispatch (void);
void windInstIdle (void);
void windInstIntEnt (void);
void windInstIntExit (void);

#endif /* CPU_FAMILY==I960 */

/*******************************************************************************
*
* evtObjLogFuncBind - bind object-level logging functions
*
* This routine binds the function pointers used to log system-object events
* to the appropriate functions in this library.
*
* RETURNS: N/A
* NOMANUAL
*/

void evtObjLogFuncBind (void)
    {
    _func_evtLogO        = (VOIDFUNCPTR) evtLogO;
    _func_evtLogOIntLock = (VOIDFUNCPTR) evtLogOInt;
    }

/*******************************************************************************
*
* evtLogFuncBind - bind general event-logging functions
*
* This function binds instrumentation function pointers to logging functions
* in this file.  Event logging routines associated with class-1 (object-
* class) logging must be bound earlier, with a call to evtObjLogFuncBind.
*
* RETURNS: N/A
* NOMANUAL
*/

void evtLogFuncBind (void)
    {

    /* Task-transition logging. */

    _func_evtLogM0 = (VOIDFUNCPTR) evtLogM0;    
    _func_evtLogM1 = (VOIDFUNCPTR) evtLogM1;
    _func_evtLogM2 = (VOIDFUNCPTR) evtLogM2;
    _func_evtLogM3 = (VOIDFUNCPTR) evtLogM3;

    /* Context-switch logging. */

    _func_evtLogT0 = (VOIDFUNCPTR) evtLogT0;    
    _func_evtLogT1 = (VOIDFUNCPTR) evtLogT1;
    _func_evtLogT0_noInt = (VOIDFUNCPTR) evtLogT0_noInt;
#if CPU_FAMILY==PPC
    _func_evtLogT1_noTS = (VOIDFUNCPTR) evtLogT1_noTS;
#endif /* CPU_FAMILY==PPC */
    _func_evtLogTSched = (VOIDFUNCPTR) evtsched;  /* iff portable kernel */

    /* Special logging functions. */

    _func_evtLogPoint = (FUNCPTR) evtLogPoint;
    _func_evtLogString = (VOIDFUNCPTR) evtLogString;
    _func_evtLogReserveTaskName = (FUNCPTR) wvTaskNamesBufAdd;

    /* i960 specific functione pointers used in windALib.s */

#if CPU_FAMILY==I960

    _func_windInst1 = (VOIDFUNCPTR) windInst1;
    _func_windInstDispatch = (VOIDFUNCPTR) windInstDispatch;
    _func_windInstIdle = (VOIDFUNCPTR) windInstIdle;
    _func_windInstIntEnt = (VOIDFUNCPTR) windInstIntEnt;
    _func_windInstIntExit = (VOIDFUNCPTR) windInstIntExit;

#endif /* CPU_FAMILY==I960 */

    }

/*******************************************************************************
*
* evtBufferBind - bind logging routines to a specific event buffer
*
* This routine associates a specific event buffer with the event-logging
* routines.
*
* RETURNS: N/A
* NOMANUAL
*/

void evtBufferBind
    (
    BUFFER_ID bufId	/* bind logging functions to this buffer */
    )
    {
    evtBufferId = bufId;
    }

#ifdef evtLogLib_PORTABLE

/*******************************************************************************
*
* evtLogT0 - log event id
*
* This event logging routine stores
*       event id        (short )
*       time		(int )
* This routine is called by level 3 (context switch events) 
* taskLock, taskUnlock and tickAnnounce.
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogT0
    (
    event_t action           /* event id */
    )
    {
    int              level;                  /* interrupt level */
    event_t *        eventBase;
    int *            intBase;
    int		     timestamp;

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(EVTLOG_T0_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    timestamp = (* _func_tmrStamp) ();
    EVT_STORE_UINT32 (intBase, timestamp);

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }

/*******************************************************************************
*
* evtLogT0_noInt - log event id without locking interrupts 
*
* This event logging routine stores
*       event id        (short )
*       time            (int )
* This routine is called by level 3 (context switch events) when interrupt
* are already locked (in particular by arch dependent code).
*
* SEE ALSO:
* NOMANUAL
*/


void evtLogT0_noInt
    (
    event_t action           /* event id */
    )
    {
    event_t *        eventBase;
    int *            intBase;
    int		     timestamp;

    EVTLOG_RESERVE_BUFF_SPACE_L(EVTLOG_T0_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    timestamp = (* _func_tmrStamp) ();
    EVT_STORE_UINT32 (intBase, timestamp);

    }

/*******************************************************************************
*
* evtLogT1 - log event id
*
* This event logging routine stores
*       event id        (short )
*       time            (int )
*       param           (int )
*
* This routine is called by level 3 (context switch events)
* taskLock, taskUnlock and tickAnnounce.
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogT1
    (
    event_t action,          /* event id */
    int     param
    )
    {
    int       	     level;                  /* interrupt level */
    event_t *        eventBase = NULL;
    int *            intBase = NULL;
    int		     timestamp;

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(EVTLOG_T1_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    timestamp = (* _func_tmrStamp) ();
    EVT_STORE_UINT32 (intBase, timestamp);
    EVT_STORE_UINT32 (intBase, param);

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }


/*******************************************************************************
*
* evtLogM0 - log event id 
* 
* This event logging routine stores
*	event id	(short )
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogM0 
    (
    event_t action		/* event id */
    )
    {
    int              level;			/* interrupt level */
    event_t *        eventBase;

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(EVTLOG_M0_SIZE);

    EVT_STORE_UINT16 (eventBase, action);

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }

/*******************************************************************************
*
* evtLogM1 - log an event 
*
* This event logging routine stores
*       event id        (short )
*       param1          (int )
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogM1
    (
    event_t action,
    int     param1
    )
    {
    int              level;
    event_t * 	     eventBase;
    int *            intBase;

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(EVTLOG_M1_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    EVT_STORE_UINT32 (intBase, param1);

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }

/*******************************************************************************
*
* evtLogM2 - log an event 
* 
* This event logging routine stores
*	event id	(short )
*	param1		(int )
*	param2		(int )
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogM2
    (
    event_t action, 
    int     param1, 
    int     param2
    )
    {
    int              level;
    event_t *        eventBase;
    int *            intBase;

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(EVTLOG_M2_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    EVT_STORE_UINT32 (intBase, param1);
    EVT_STORE_UINT32 (intBase, param2);

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }

/*******************************************************************************
*
* evtLogM3 - log an event 
*
* This event logging routine stores
*	event id	(short )
*	param1		(int )
*	param2		(int )
*	param3		(int )
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogM3
    (
    event_t action,
    int     param1,
    int     param2,
    int     param3
    )
    {
    int              level;
    event_t *        eventBase;
    int *            intBase;

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(EVTLOG_M3_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    EVT_STORE_UINT32 (intBase, param1);
    EVT_STORE_UINT32 (intBase, param2);
    EVT_STORE_UINT32 (intBase, param3);

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }

#endif /* evtLogLib_PORTABLE */

/*******************************************************************************
*
* evtLogOInt - For level 1s, the object state events.
*
* This event logging routine stores
*	event id	(short )
*	timestamp	(int )
*	param[0..5]	(int )	 - no. of param logged depends on the event id.
*
* This routine is used when interrupts must be locked by this code.
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogOInt 
    (
    event_t  action,		    /* event action */
    int      nParam,
    int      param1,
    int      param2,
    int      param3,
    int      param4,
    int      param5
    )
    {
    int level;

    level = intLock();

    evtLogO(action, nParam, param1, param2, param3, param4, param5);

    intUnlock(level);
    }

/*******************************************************************************
*
* evtLogO - For level 1s, the object state events.
*
* This event logging routine stores
*	event id	(short )
*	timestamp	(int )
*	param[0..5]	(int )	 - no. of param logged depends on the event id.
*
* Called from within an interrupt lock area.
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogO
    (
    event_t  action,             /* event action */
    int      nParam,
    int      param1,
    int      param2,
    int      param3,
    int      param4,
    int      param5
    )
    {
    event_t * 	     eventBase;
    int *            intBase;
    int		     timestamp;

    EVTLOG_RESERVE_BUFF_SPACE_L(6 + (nParam * 4));

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    timestamp = (* _func_tmrStamp) ();
    EVT_STORE_UINT32 (intBase, timestamp);

    switch (nParam)
        {
        case 5:
            EVT_STORE_UINT32 (intBase, param5);

        case 4:
            EVT_STORE_UINT32 (intBase, param4);

        case 3:
            EVT_STORE_UINT32 (intBase, param3);

        case 2:
            EVT_STORE_UINT32 (intBase, param2);

        case 1:
            EVT_STORE_UINT32 (intBase, param1);
        }
    }

/*******************************************************************************
*
* evtLogString - Add a string to the event log.
*
* This event logging routine stores
*	event id	(short )
*	arg		(int)
*	arg		(int)
*	arg		(int)
*	address		(int)
*	string size	(int)   - if size is ZERO the string does not exist.
*	string		(char)
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogString
    (
    event_t 	     action,		/* the event id */
    int	       	     arg1,		/* an extra argument */
    int	       	     arg2,		/* an extra argument */
    int	       	     arg3,		/* an extra argument */
    int        	     addrId,		/* an address */
    const char *     string		/* series of characters */
    )
    {
    event_t *        eventBase;
    int *            intBase;
    int              evtSize = strlen (string);
    int              level;

    evtSize = MEM_ROUND_UP (evtSize);

    level = intLock ();                 /* LOCK INTERRUPTS */

    EVTLOG_RESERVE_BUFF_SPACE(evtSize + EVTLOG_STR_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    EVT_STORE_UINT32 (intBase, arg1);
    EVT_STORE_UINT32 (intBase, arg2);
    EVT_STORE_UINT32 (intBase, arg3);
    EVT_STORE_UINT32 (intBase, addrId);
    EVT_STORE_UINT32 (intBase, evtSize);

    if (evtSize != 0)
	{
        strncpy ((char *) intBase, string, evtSize);
	}

    intUnlock (level);                  /* UNLOCK INTERRUPTS */
    }

/*******************************************************************************
*
* evtLogPoint - logs a user defined event or eventpoint via event () or e ().
*
* This event logging routine stores
*	event id	(short )
*	timestamp	(int)
*	address		(int)
*	buffer size	(int)	- if size is ZERO the buffer does not exist.
*	buffer		(char)
*
* RETURNS: OK, or ERROR if unable to log event point
* SEE ALSO:
* NOMANUAL
*/

STATUS evtLogPoint 
    (
    event_t    action,		/* event id */
    void *     addr, 		/* pc address */
    size_t     nbytes,		/* buffer size */
    char *     buffer		/* buffer */
    )
    {
    event_t *        eventBase;
    event_t 	     biasedAction;
    int * 	     intBase;
    int 	     level;
    int 	     timestamp;

    biasedAction = action + MIN_USER_ID;

    /* if (evtLogTIsOn) */
	{

        /* is event id within the range of user event ids? */
        if (biasedAction < MIN_USER_ID || biasedAction > MAX_USER_ID)
	    return (ERROR);

        level = intLock ();                 /* LOCK INTERRUPTS */

        EVTLOG_RESERVE_BUFF_SPACE_STAT(nbytes + EVTLOG_PT_SIZE);

        EVT_STORE_UINT16 (eventBase, biasedAction);
        intBase = (int *) eventBase;
        timestamp = (* _func_tmrStamp) ();
	EVT_STORE_UINT32 (intBase, timestamp);
        EVT_STORE_UINT32 (intBase, (int) addr);
        EVT_STORE_UINT32 (intBase, nbytes);

	/* copy buffer contents into event buffer */

        if ((nbytes != 0) && (buffer != NULL))
	    {
	    memcpy ((char *) intBase, buffer, nbytes);
	    }

        intUnlock (level);                  /* UNLOCK INTERRUPTS */
        }
    return (OK);
    }

/*******************************************************************************
*
* evtLogTasks -	log name, status and priority of all tasks in the system
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogTasks (void)
    {
    int         nTasks;                 /* number of task */
    int         idList[MAX_WV_TASKS];   /* list of active IDs */
    int         ix;                     /* index */

    /* get list of tasks in the system */
    nTasks = taskIdListGet (idList, NELEMENTS (idList));

    /* sort the task list */
    taskIdListSort (idList, nTasks);

    /* log the name of each task in the system */
    for (ix = 0; ix < nTasks; ++ix)
        {
        if (taskIdVerify (idList[ix]) == OK)
            {
            evtLogString (EVENT_TASKNAME, 
	  	          ((WIND_TCB *)idList[ix])->status,
	  	          ((WIND_TCB *)idList[ix])->priority,
	  	          ((WIND_TCB *)idList[ix])->lockCnt,
		          idList[ix], taskName (idList[ix]));
	    }
        }
    }

/*******************************************************************************
* 
* evtSched - log events from the portable kernel 
*
* This event logging routine stores
*       event id        (short)
*	time stamp	(int)
*	taskIdCurrent   (int)	|	if event is EVENT_WIND_EXIT_DISPATCH or
*	priority	(int)	|	EVENT_WIND_EXIT_NODISPATCH
* directly onto the buffer.
* It is used for the portable workQLib.
* Assume that interrupts are already locked.
*
* SEE ALSO:
* NOMANUAL
*/

void evtsched
    (
    event_t action,           /* event id */
    int     arg1,	      /* taskIdCurrent or not logged */
    int     arg2	      /* priority or not logged */
    )
    {
    event_t *        eventBase;
    int *            intBase;
    int		     timestamp;

#if 0 /* need this? NPS */

    if (evtBufOverflow)		/* leave if buffer is full */
	return;
#endif

    timestamp = (* _func_tmrStamp) ();

    switch (action)
    {
    case EVENT_WIND_EXIT_IDLE: 
	{
        EVTLOG_RESERVE_BUFF_SPACE_L(6);

        EVT_STORE_UINT16 (eventBase, action);
        intBase = (int *) eventBase;
        EVT_STORE_UINT32 (intBase, timestamp);
	break;
	}
    case EVENT_WIND_EXIT_NODISPATCH:
    case EVENT_WIND_EXIT_NODISPATCH_PI:
	{
        EVTLOG_RESERVE_BUFF_SPACE_L(10);

        EVT_STORE_UINT16 (eventBase, action);
        intBase = (int *) eventBase;
        EVT_STORE_UINT32 (intBase, timestamp);
	EVT_STORE_UINT32 (intBase, arg2);	/* priority */
	break;
	}
    case EVENT_WIND_EXIT_DISPATCH:
    case EVENT_WIND_EXIT_DISPATCH_PI:
	{
        EVTLOG_RESERVE_BUFF_SPACE_L(14);

        EVT_STORE_UINT16 (eventBase, action);
        intBase = (int *) eventBase;
        EVT_STORE_UINT32 (intBase, timestamp);
	EVT_STORE_UINT32 (intBase, arg1);	/* taskIdCurrent */
	EVT_STORE_UINT32 (intBase, arg2);	/* priority */
	}
    }
    }

#if CPU_FAMILY==PPC

/*******************************************************************************
*
* evtLogT1_noTS - log event id without getting timestamp
*
* This event logging routine stores
*       event id        (short )
*       time            (int )
*
* This routines is very similar to the evtLogT1. The main difference
* is that no timestamp is here. The parameter passed is actually the
* current timestamp for this event. This routine is called when an
* interrupt is entered. It is used for PPC architecture. PPC generates
* only one kind of interrupt. When the interrupt is entered, the timestamp
* for windview is obtained. No information about the type of interrupt is
* known at that point. Only when the sysIbcIntHandler routine is called,
* the interrupt vector handler is obtained and it is passed to this
* routine, together with the timestamp.
* When this routine is called, interrupts must be locked already.
*
* SEE ALSO:
* NOMANUAL
*/

void evtLogT1_noTS
    (
    event_t action,           /* event id */
    int     param            /* timestamp */
    )
    {
    event_t *        eventBase;
    int *            intBase;


    EVTLOG_RESERVE_BUFF_SPACE_L(EVTLOG_T0_SIZE);

    EVT_STORE_UINT16 (eventBase, action);
    intBase = (int *) eventBase;
    EVT_STORE_UINT32 (intBase, param);

    }

#endif /* CPU_FAMILY==PPC */

#if CPU_FAMILY==I960

/*******************************************************************************
* 
* windInst1 - log events from the 960 assembly language kernel 
*
* Interrupts are locked when this is called
*
* SEE ALSO:
* NOMANUAL
*/


void windInst1 (void)
    {
    EVT_CTX_NODISP ((int)taskIdCurrent,
		    taskIdCurrent->priority,
		    taskIdCurrent->priNormal);
    }


/*******************************************************************************
* 
* windInstDispatch - 
*
* interrupts are locked out when this is called.
*
* SEE ALSO:
* NOMANUAL
*/


void windInstDispatch (void)
    {
    /*
     * At this point, we need to decide whether to log an event
     * EVENT_WIND_EXIT_DISPATCH or EVENT_WIND_EXIT_DISPATCH_PI.
     * This is done in the macro EVT_CTX_DISP by comparing
     * taskIdCurrent->priority and taskIdCurrent->priNormal. As
     * a result, the first parameter to the EVT_CTX_DISP macro is
     * not actually used and could be removed in a future code tidy up.
     */

    EVT_CTX_DISP (EVENT_WIND_EXIT_DISPATCH_PI,
		  (int) taskIdCurrent, 
		  taskIdCurrent->priority, 
		  taskIdCurrent->priNormal);
    }

/*******************************************************************************
* 
* windInstIdle - 
*
* interrupts are locked out when this is called.
*
* SEE ALSO:
* NOMANUAL
*/

void windInstIdle (void)
    {
    EVT_CTX_IDLE(EVENT_WIND_EXIT_IDLE, &readyQHead);
    }

/*******************************************************************************
* 
* windInstIntEnt -
*
* Interrupts are NOT locked when this is called.
* evtAction has already been checked for non-zero.
*
* SEE ALSO:
* NOMANUAL
*/

void windInstIntEnt (void)
    {
    int 	level;
    event_t	evtId;

    /* 
     * shift and mask off bits returned by intLock to obtain
     * I960 specific interrupt level. Then convert to event ID
     */

    level = intLock ();
    evtId = (event_t) EVENT_INT_ENT ((level >> 16) & 0x001f);

    if ( WV_EVTCLASS_IS_SET(WV_CLASS_1|WV_ON) )
	( * _func_evtLogT0_noInt) (evtId);

    intUnlock (level);

    if (TRG_EVTCLASS_IS_SET(TRG_CLASS_1|TRG_ON))
	( * _func_trgCheck) (evtId, TRG_CLASS1_INDEX, 
	                     NULL, NULL, NULL, NULL, NULL, NULL);
    }

/*******************************************************************************
* 
* windInstIntExit -
*
* Interrupts are NOT locked when this is called.
* evtAction has already been checked for non-zero.
*
* SEE ALSO:
* NOMANUAL
*/

void windInstIntExit (void)
    {
    int 	level;
    event_t	evtId;

    level = intLock ();
    
    if (workQIsEmpty)
    	evtId = EVENT_INT_EXIT;
    else
    	evtId = EVENT_INT_EXIT_K;

    if ( WV_EVTCLASS_IS_SET(WV_CLASS_1|WV_ON) )
	( * _func_evtLogT0_noInt) (evtId);

    intUnlock (level);

    if (TRG_EVTCLASS_IS_SET(TRG_CLASS_1|TRG_ON))
	( * _func_trgCheck) (evtId, TRG_CLASS1_INDEX, 
	                     NULL, NULL, NULL, NULL, NULL, NULL);
    }

#endif /* CPU_FAMILY==I960 */
