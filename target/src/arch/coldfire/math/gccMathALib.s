/* gccMathALib.s - math support routines for gcc */

/* Copyright 1984-2000 Wind River Systems, Inc. */
	.data
	.globl	_copyright_wind_river
	.long	_copyright_wind_river

/*
modification history
--------------------
01c,26nov01,dee  remove reference to _DIAB_TOOL, use TOOL_FAMILY instead
01b,12sep00,dh   Removed all non-coldfire stuff, added 5400.
01a,17mar00,dra  Created from T1.0.1 ColdFire and T2 m68k ports.
*/

/*
DESCRIPTION

This library contains various support routines for using gcc.  The
compiler will generate subroutine calls to the functions in this file
when the software floating point option is used.  The function names 
are those which are automatically generated by the gcc compiler.

This library also contains routines to perform long (32-bit) arithmetic
on a Motorola 68000 or 68010 processor.  Multiply, divide, and
modulus operations are provided, each in signed and unsigned modes.

AUTHOR
Compare routines supplied by Cygnus Support.

Original 32-bit multiply and divide routines for 68000/10 written by 
Kai-Uwe Bloem (I5110401@dbstu1.bitnet).

NOMANUAL
*/


#define	_ASMLANGUAGE

#include "vxWorks.h"
#include "asm.h"

	
	.globl	___divsi3
	.globl	___udivsi3
	.globl	___modsi3
	.globl	___umodsi3

#if (TOOL_FAMILY == diab)
	.globl	ldivd
	.globl	uldivd
	.globl	lremd
	.globl	ulremd
#endif	/* TOOL_FAMILY==diab */

	.globl	_gccMathInit

	.text
	.even


/*******************************************************************************
*
* gccMathInit -  This routine will cause this module to be included in
*	         the vxWorks build.
*
* RETURNS: 
*
* NOMANUAL
*/

_gccMathInit:
	link	a6,#-4
	unlk	a6
	rts



/******************************************************************************
*
* divsi3 - long integer division routine for 5200 using gcc
*
* Based on the 68000/10 version.
*
* RETURNS: signed 32-bit division result.
*
* NOMANUAL
*/

___divsi3:
	movel	d2,a0		| save registers
	movel	d3,a1
	clrl	sp@-		| sign flag
	clrl	d3		| temp sign flag
	clrl	d0		| prepare result
	movel	sp@(12),d2	| get divisor
	jeq	9f		| divisor = 0 causes a division trap
	jpl	0f		| divisor < 0 ?
	negl	d2		| negate it
	notl	d3		| remember sign
0:	movel	sp@(8),d1	| get dividend
	jpl	0f		| dividend < 0 ?
	negl	d1		| negate it
	notl	d3		| remember sign
0:
	movel	d3,sp@		| store sign
|== case 1) divident < divisor
	cmpl	d2,d1		| is divident smaller then divisor ?
	jcs	8f		| yes, return immediately
|== case 3) divisor > 16 bits (corollary is dividend > 16 bits, see case 1)
	moveq	#31,d3		| loop count
3:
	addl	d1,d1		| shift divident ...
	addxl	d0,d0		|  ... into d0
	cmpl	d2,d0		| compare with divisor
	jcs	0f
	subl	d2,d0		| big enough, subtract
	addl	#1,d1		| and note bit into result
0:
	subql	#1,d3
	bpl	3b
	movel	d1,d2		| put quotient and remainder in their registers
	movel	d0,d1
	movel	d2,d0
8:
	tstl	sp@(8)		| must the remainder be corrected ?
	jpl	0f
	negl	d1		| yes, apply sign
| the following line would be correct if modulus is defined as in algebra
|	addl	sp@(8),d1	| algebraic correction: modulus can only be >= 0
0:	tstl	sp@+		| result should be negative ?
	jpl	0f
	negl	d0		| yes, negate it
0:
	movel	a1,d3
	movel	a0,d2
	rts
9:
	/* XXX - need to do an exception #5 here */
	trap	#0		| cause division trap
	jra	8b		| back to user

/******************************************************************************
*
* udivsi3 - unsigned long integer division routine for 5200 using gcc
*
* Based on the 68000/10 version above.
*
* RETURNS: unsigned 32-bit division result.
*
* NOMANUAL
*/

___udivsi3:
	movel	d2,a0		| save registers
	movel	d3,a1
	clrl	d0		| prepare result
	movel	sp@(8),d2	| get divisor
	jeq	9f		| divisor = 0 causes a division trap
	movel	sp@(4),d1	| get dividend
|== case 1) divident < divisor
	cmpl	d2,d1		| is divident smaller then divisor ?
	jcs	8f		| yes, return immediately
|== case 2) divisor > 16 bits (corollary is dividend > 16 bits, see case 1)
	moveq	#31,d3		| loop count
3:
	addl	d1,d1		| shift divident ...
	addxl	d0,d0		|  ... into d0
	cmpl	d2,d0		| compare with divisor
	jcs	0f
	subl	d2,d0		| big enough, subtract
	addl	#1,d1		| and note bit in result
0:
	subql	#1,d3
	bpl	3b
	movel	d1,d2		| put quotient and remainder in their registers
	movel	d0,d1
	movel	d2,d0
8:
	movel	a1,d3
	movel	a0,d2
	rts
9:
	/* XXX - need to do exception #5 here */
	trap	#0		| cause division trap
	jra	8b		| back to user

/*******************************************************************************
*
* modsi3 - long integer modulo routine for 68000/10 using gcc
*
* Revision 1.1, kub 03-90
*
* RETURNS: signed 32-bit modulo result.
*
* AUTHOR:
* written by Kai-Uwe Bloem (I5110401@dbstu1.bitnet).
*
* NOMANUAL
*/

___modsi3:
	movel	sp@(8),sp@-	| push divisor
	movel	sp@(8),sp@-	| push dividend
	jbsr	___divsi3
	addql	#8,sp
	movel	d1,d0		| return the remainder in d0
	rts

/*******************************************************************************
*
* umodsi3 - unsigned long integer modulo routine for 68000/10 using gcc
*
* Revision 1.1, kub 03-90
*
* RETURNS: unsigned 32-bit modulo result.
*
* AUTHOR:
* written by Kai-Uwe Bloem (I5110401@dbstu1.bitnet).
*
* NOMANUAL
*/

___umodsi3:
	movel	sp@(8),sp@-	| push divisor
	movel	sp@(8),sp@-	| push dividend
	jbsr	___udivsi3
	addql	#8,sp
	movel	d1,d0		| return the remainder in d0
	rts


#if (TOOL_FAMILY == diab)
/*******************************************************************************
*
* ldivd, uldivd, lremd, ulremd - Diab Data wrappers.
*
* RETURNS: arithmatic results as needed.
*
* NOMANUAL
*/

ldivd:
	movel	d1,a7@-
	movel	d0,a7@-
	jbsr	___divsi3
	addl	#8,a7
	rts

uldivd:
	movel	d1,a7@-
	movel	d0,a7@-
	jbsr	___udivsi3
	addl	#8,a7
	rts

lremd:
	movel	d1,a7@-
	movel	d0,a7@-
	jbsr	___umodsi3
	addl	#8,a7
	rts

ulremd:
	movel	d1,a7@-
	movel	d0,a7@-
	jbsr	___umodsi3
	addl	#8,a7
	rts

#endif	/* TOOL_FAMILY == diab */
